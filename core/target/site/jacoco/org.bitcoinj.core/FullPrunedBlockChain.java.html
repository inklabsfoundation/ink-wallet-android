<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FullPrunedBlockChain.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bitcoinj</a> &gt; <a href="index.source.html" class="el_package">org.bitcoinj.core</a> &gt; <span class="el_source">FullPrunedBlockChain.java</span></div><h1>FullPrunedBlockChain.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2012 Matt Corallo.
 * Copyright 2014 Andreas Schildbach
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bitcoinj.core;

import org.bitcoinj.script.Script;
import org.bitcoinj.script.Script.VerifyFlag;
import org.bitcoinj.store.BlockStoreException;
import org.bitcoinj.store.FullPrunedBlockStore;
import org.bitcoinj.utils.*;
import org.bitcoinj.wallet.Wallet;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Set;
import java.util.concurrent.*;

import static com.google.common.base.Preconditions.checkState;

/**
 * &lt;p&gt;A FullPrunedBlockChain works in conjunction with a {@link FullPrunedBlockStore} to verify all the rules of the
 * Bitcoin system, with the downside being a large cost in system resources. Fully verifying means all unspent
 * transaction outputs are stored. Once a transaction output is spent and that spend is buried deep enough, the data
 * related to it is deleted to ensure disk space usage doesn't grow forever. For this reason a pruning node cannot
 * serve the full block chain to other clients, but it nevertheless provides the same security guarantees as Bitcoin
 * Core does.&lt;/p&gt;
 */
public class FullPrunedBlockChain extends AbstractBlockChain {
<span class="fc" id="L48">    private static final Logger log = LoggerFactory.getLogger(FullPrunedBlockChain.class);</span>

    /**
     * Keeps a map of block hashes to StoredBlocks.
     */
    protected final FullPrunedBlockStore blockStore;

    // Whether or not to execute scriptPubKeys before accepting a transaction (i.e. check signatures).
<span class="fc" id="L56">    private boolean runScripts = true;</span>

    /**
     * Constructs a block chain connected to the given wallet and store. To obtain a {@link Wallet} you can construct
     * one from scratch, or you can deserialize a saved wallet from disk using
     * {@link Wallet#loadFromFile(java.io.File, WalletExtension...)}
     */
    public FullPrunedBlockChain(Context context, Wallet wallet, FullPrunedBlockStore blockStore) throws BlockStoreException {
<span class="nc" id="L64">        this(context, new ArrayList&lt;Wallet&gt;(), blockStore);</span>
<span class="nc" id="L65">        addWallet(wallet);</span>
<span class="nc" id="L66">    }</span>

    /**
     * Constructs a block chain connected to the given wallet and store. To obtain a {@link Wallet} you can construct
     * one from scratch, or you can deserialize a saved wallet from disk using
     * {@link Wallet#loadFromFile(java.io.File, WalletExtension...)}
     */
    public FullPrunedBlockChain(NetworkParameters params, Wallet wallet, FullPrunedBlockStore blockStore) throws BlockStoreException {
<span class="nc" id="L74">        this(Context.getOrCreate(params), wallet, blockStore);</span>
<span class="nc" id="L75">    }</span>

    /**
     * Constructs a block chain connected to the given store.
     */
    public FullPrunedBlockChain(Context context, FullPrunedBlockStore blockStore) throws BlockStoreException {
<span class="fc" id="L81">        this(context, new ArrayList&lt;Wallet&gt;(), blockStore);</span>
<span class="fc" id="L82">    }</span>

    /**
     * See {@link #FullPrunedBlockChain(Context, Wallet, FullPrunedBlockStore)}
     */
    public FullPrunedBlockChain(NetworkParameters params, FullPrunedBlockStore blockStore) throws BlockStoreException {
<span class="fc" id="L88">        this(Context.getOrCreate(params), blockStore);</span>
<span class="fc" id="L89">    }</span>

    /**
     * Constructs a block chain connected to the given list of wallets and a store.
     */
    public FullPrunedBlockChain(Context context, List&lt;Wallet&gt; listeners, FullPrunedBlockStore blockStore) throws BlockStoreException {
<span class="fc" id="L95">        super(context, listeners, blockStore);</span>
<span class="fc" id="L96">        this.blockStore = blockStore;</span>
        // Ignore upgrading for now
<span class="fc" id="L98">        this.chainHead = blockStore.getVerifiedChainHead();</span>
<span class="fc" id="L99">    }</span>

    /**
     * See {@link #FullPrunedBlockChain(Context, List, FullPrunedBlockStore)}
     */
    public FullPrunedBlockChain(NetworkParameters params, List&lt;Wallet&gt; listeners,
                                FullPrunedBlockStore blockStore) throws BlockStoreException {
<span class="nc" id="L106">        this(Context.getOrCreate(params), listeners, blockStore);</span>
<span class="nc" id="L107">    }</span>

    @Override
    protected StoredBlock addToBlockStore(StoredBlock storedPrev, Block header, TransactionOutputChanges txOutChanges)
            throws BlockStoreException, VerificationException {
<span class="fc" id="L112">        StoredBlock newBlock = storedPrev.build(header);</span>
<span class="fc" id="L113">        blockStore.put(newBlock, new StoredUndoableBlock(newBlock.getHeader().getHash(), txOutChanges));</span>
<span class="fc" id="L114">        return newBlock;</span>
    }

    @Override
    protected StoredBlock addToBlockStore(StoredBlock storedPrev, Block block)
            throws BlockStoreException, VerificationException {
<span class="fc" id="L120">        StoredBlock newBlock = storedPrev.build(block);</span>
<span class="fc" id="L121">        blockStore.put(newBlock, new StoredUndoableBlock(newBlock.getHeader().getHash(), block.transactions));</span>
<span class="fc" id="L122">        return newBlock;</span>
    }

    @Override
    protected void rollbackBlockStore(int height) throws BlockStoreException {
<span class="nc" id="L127">        throw new BlockStoreException(&quot;Unsupported&quot;);</span>
    }

    @Override
    protected boolean shouldVerifyTransactions() {
<span class="fc" id="L132">        return true;</span>
    }

    /**
     * Whether or not to run scripts whilst accepting blocks (i.e. checking signatures, for most transactions).
     * If you're accepting data from an untrusted node, such as one found via the P2P network, this should be set
     * to true (which is the default). If you're downloading a chain from a node you control, script execution
     * is redundant because you know the connected node won't relay bad data to you. In that case it's safe to set
     * this to false and obtain a significant speedup.
     */
    public void setRunScripts(boolean value) {
<span class="fc" id="L143">        this.runScripts = value;</span>
<span class="fc" id="L144">    }</span>

    // TODO: Remove lots of duplicated code in the two connectTransactions

    // TODO: execute in order of largest transaction (by input count) first
<span class="fc" id="L149">    ExecutorService scriptVerificationExecutor = Executors.newFixedThreadPool(</span>
<span class="fc" id="L150">            Runtime.getRuntime().availableProcessors(), new ContextPropagatingThreadFactory(&quot;Script verification&quot;));</span>

    /**
     * A job submitted to the executor which verifies signatures.
     */
    private static class Verifier implements Callable&lt;VerificationException&gt; {
        final Transaction tx;
        final List&lt;Script&gt; prevOutScripts;
        final Set&lt;VerifyFlag&gt; verifyFlags;

<span class="fc" id="L160">        public Verifier(final Transaction tx, final List&lt;Script&gt; prevOutScripts, final Set&lt;VerifyFlag&gt; verifyFlags) {</span>
<span class="fc" id="L161">            this.tx = tx;</span>
<span class="fc" id="L162">            this.prevOutScripts = prevOutScripts;</span>
<span class="fc" id="L163">            this.verifyFlags = verifyFlags;</span>
<span class="fc" id="L164">        }</span>

        @Nullable
        @Override
        public VerificationException call() throws Exception {
            try {
<span class="fc" id="L170">                ListIterator&lt;Script&gt; prevOutIt = prevOutScripts.listIterator();</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">                for (int index = 0; index &lt; tx.getInputs().size(); index++) {</span>
<span class="fc" id="L172">                    tx.getInputs().get(index).getScriptSig().correctlySpends(tx, index, prevOutIt.next(), verifyFlags);</span>
                }
<span class="fc" id="L174">            } catch (VerificationException e) {</span>
<span class="fc" id="L175">                return e;</span>
<span class="fc" id="L176">            }</span>
<span class="fc" id="L177">            return null;</span>
        }
    }

    /**
     * Get the {@link Script} from the script bytes or return Script of empty byte array.
     */
    private Script getScript(byte[] scriptBytes) {
        try {
<span class="fc" id="L186">            return new Script(scriptBytes);</span>
<span class="fc" id="L187">        } catch (Exception e) {</span>
<span class="fc" id="L188">            return new Script(new byte[0]);</span>
        }
    }

    /**
     * Get the address from the {@link Script} if it exists otherwise return empty string &quot;&quot;.
     *
     * @param script The script.
     * @return The address.
     */
    private String getScriptAddress(@Nullable Script script) {
<span class="fc" id="L199">        String address = &quot;&quot;;</span>
        try {
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">            if (script != null) {</span>
<span class="fc" id="L202">                address = script.getToAddress(params, true).toString();</span>
            }
<span class="fc" id="L204">        } catch (Exception e) {</span>
<span class="fc" id="L205">        }</span>
<span class="fc" id="L206">        return address;</span>
    }

    @Override
    protected TransactionOutputChanges connectTransactions(int height, Block block)
            throws VerificationException, BlockStoreException {
<span class="fc" id="L212">        checkState(lock.isHeldByCurrentThread());</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">        if (block.transactions == null)</span>
<span class="nc" id="L214">            throw new RuntimeException(&quot;connectTransactions called with Block that didn't have transactions!&quot;);</span>
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">        if (!params.passesCheckpoint(height, block.getHash()))</span>
<span class="nc" id="L216">            throw new VerificationException(&quot;Block failed checkpoint lockin at &quot; + height);</span>

<span class="fc" id="L218">        blockStore.beginDatabaseBatchWrite();</span>

<span class="fc" id="L220">        LinkedList&lt;UTXO&gt; txOutsSpent = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L221">        LinkedList&lt;UTXO&gt; txOutsCreated = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L222">        long sigOps = 0;</span>

<span class="fc bfc" id="L224" title="All 2 branches covered.">        if (scriptVerificationExecutor.isShutdown())</span>
<span class="fc" id="L225">            scriptVerificationExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span>

<span class="fc" id="L227">        List&lt;Future&lt;VerificationException&gt;&gt; listScriptVerificationResults = new ArrayList&lt;&gt;(block.transactions.size());</span>
        try {
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">            if (!params.isCheckpoint(height)) {</span>
                // BIP30 violator blocks are ones that contain a duplicated transaction. They are all in the
                // checkpoints list and we therefore only check non-checkpoints for duplicated transactions here. See the
                // BIP30 document for more details on this: https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki
<span class="fc bfc" id="L233" title="All 2 branches covered.">                for (Transaction tx : block.transactions) {</span>
<span class="fc" id="L234">                    final Set&lt;VerifyFlag&gt; verifyFlags = params.getTransactionVerificationFlags(block, tx, getVersionTally(), height);</span>
<span class="fc" id="L235">                    Sha256Hash hash = tx.getHash();</span>
                    // If we already have unspent outputs for this hash, we saw the tx already. Either the block is
                    // being added twice (bug) or the block is a BIP30 violator.
<span class="fc bfc" id="L238" title="All 2 branches covered.">                    if (blockStore.hasUnspentOutputs(hash, tx.getOutputs().size()))</span>
<span class="fc" id="L239">                        throw new VerificationException(&quot;Block failed BIP30 test!&quot;);</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">                    if (verifyFlags.contains(VerifyFlag.P2SH)) // We already check non-BIP16 sigops in Block.verifyTransactions(true)</span>
<span class="fc" id="L241">                        sigOps += tx.getSigOpCount();</span>
<span class="fc" id="L242">                }</span>
            }
<span class="fc" id="L244">            Coin totalFees = Coin.ZERO;</span>
<span class="fc" id="L245">            Coin coinbaseValue = null;</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">            for (final Transaction tx : block.transactions) {</span>
<span class="fc" id="L247">                boolean isCoinBase = tx.isCoinBase();</span>
<span class="fc" id="L248">                Coin valueIn = Coin.ZERO;</span>
<span class="fc" id="L249">                Coin valueOut = Coin.ZERO;</span>
<span class="fc" id="L250">                final List&lt;Script&gt; prevOutScripts = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L251">                final Set&lt;VerifyFlag&gt; verifyFlags = params.getTransactionVerificationFlags(block, tx, getVersionTally(), height);</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">                if (!isCoinBase) {</span>
                    // For each input of the transaction remove the corresponding output from the set of unspent
                    // outputs.
<span class="fc bfc" id="L255" title="All 2 branches covered.">                    for (int index = 0; index &lt; tx.getInputs().size(); index++) {</span>
<span class="fc" id="L256">                        TransactionInput in = tx.getInputs().get(index);</span>
<span class="fc" id="L257">                        UTXO prevOut = blockStore.getTransactionOutput(in.getOutpoint().getHash(),</span>
<span class="fc" id="L258">                                in.getOutpoint().getIndex());</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">                        if (prevOut == null)</span>
<span class="fc" id="L260">                            throw new VerificationException(&quot;Attempted to spend a non-existent or already spent output!&quot;);</span>
                        // Coinbases can't be spent until they mature, to avoid re-orgs destroying entire transaction
                        // chains. The assumption is there will ~never be re-orgs deeper than the spendable coinbase
                        // chain depth.
<span class="fc bfc" id="L264" title="All 2 branches covered.">                        if (prevOut.isCoinbase()) {</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">                            if (height - prevOut.getHeight() &lt; params.getSpendableCoinbaseDepth()) {</span>
<span class="fc" id="L266">                                throw new VerificationException(&quot;Tried to spend coinbase at depth &quot; + (height - prevOut.getHeight()));</span>
                            }
                        }
                        // TODO: Check we're not spending the genesis transaction here. Bitcoin Core won't allow it.
<span class="fc" id="L270">                        valueIn = valueIn.add(prevOut.getValue());</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">                        if (verifyFlags.contains(VerifyFlag.P2SH)) {</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">                            if (prevOut.getScript().isPayToScriptHash())</span>
<span class="fc" id="L273">                                sigOps += Script.getP2SHSigOpCount(in.getScriptBytes());</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">                            if (sigOps &gt; Block.MAX_BLOCK_SIGOPS)</span>
<span class="fc" id="L275">                                throw new VerificationException(&quot;Too many P2SH SigOps in block&quot;);</span>
                        }

<span class="fc" id="L278">                        prevOutScripts.add(prevOut.getScript());</span>
<span class="fc" id="L279">                        blockStore.removeUnspentTransactionOutput(prevOut);</span>
<span class="fc" id="L280">                        txOutsSpent.add(prevOut);</span>
                    }
                }
<span class="fc" id="L283">                Sha256Hash hash = tx.getHash();</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">                for (TransactionOutput out : tx.getOutputs()) {</span>
<span class="fc" id="L285">                    valueOut = valueOut.add(out.getValue());</span>
                    // For each output, add it to the set of unspent outputs so it can be consumed in future.
<span class="fc" id="L287">                    Script script = getScript(out.getScriptBytes());</span>
<span class="fc" id="L288">                    UTXO newOut = new UTXO(hash,</span>
<span class="fc" id="L289">                            out.getIndex(),</span>
<span class="fc" id="L290">                            out.getValue(),</span>
                            height, isCoinBase,
                            script,
<span class="fc" id="L293">                            getScriptAddress(script));</span>
<span class="fc" id="L294">                    blockStore.addUnspentTransactionOutput(newOut);</span>
<span class="fc" id="L295">                    txOutsCreated.add(newOut);</span>
<span class="fc" id="L296">                }</span>
                // All values were already checked for being non-negative (as it is verified in Transaction.verify())
                // but we check again here just for defence in depth. Transactions with zero output value are OK.
<span class="pc bpc" id="L299" title="2 of 4 branches missed.">                if (valueOut.signum() &lt; 0 || valueOut.compareTo(params.getMaxMoney()) &gt; 0)</span>
<span class="nc" id="L300">                    throw new VerificationException(&quot;Transaction output value out of range&quot;);</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">                if (isCoinBase) {</span>
<span class="fc" id="L302">                    coinbaseValue = valueOut;</span>
                } else {
<span class="pc bpc" id="L304" title="1 of 4 branches missed.">                    if (valueIn.compareTo(valueOut) &lt; 0 || valueIn.compareTo(params.getMaxMoney()) &gt; 0)</span>
<span class="fc" id="L305">                        throw new VerificationException(&quot;Transaction input value out of range&quot;);</span>
<span class="fc" id="L306">                    totalFees = totalFees.add(valueIn.subtract(valueOut));</span>
                }

<span class="fc bfc" id="L309" title="All 4 branches covered.">                if (!isCoinBase &amp;&amp; runScripts) {</span>
                    // Because correctlySpends modifies transactions, this must come after we are done with tx
<span class="fc" id="L311">                    FutureTask&lt;VerificationException&gt; future = new FutureTask&lt;&gt;(new Verifier(tx, prevOutScripts, verifyFlags));</span>
<span class="fc" id="L312">                    scriptVerificationExecutor.execute(future);</span>
<span class="fc" id="L313">                    listScriptVerificationResults.add(future);</span>
                }
<span class="fc" id="L315">            }</span>
<span class="pc bpc" id="L316" title="1 of 4 branches missed.">            if (totalFees.compareTo(params.getMaxMoney()) &gt; 0 || block.getBlockInflation(height).add(totalFees).compareTo(coinbaseValue) &lt; 0)</span>
<span class="fc" id="L317">                throw new VerificationException(&quot;Transaction fees out of range&quot;);</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">            for (Future&lt;VerificationException&gt; future : listScriptVerificationResults) {</span>
                VerificationException e;
                try {
<span class="fc" id="L321">                    e = future.get();</span>
<span class="nc" id="L322">                } catch (InterruptedException thrownE) {</span>
<span class="nc" id="L323">                    throw new RuntimeException(thrownE); // Shouldn't happen</span>
<span class="nc" id="L324">                } catch (ExecutionException thrownE) {</span>
<span class="nc" id="L325">                    log.error(&quot;Script.correctlySpends threw a non-normal exception: &quot; + thrownE.getCause());</span>
<span class="nc" id="L326">                    throw new VerificationException(&quot;Bug in Script.correctlySpends, likely script malformed in some new and interesting way.&quot;, thrownE);</span>
<span class="fc" id="L327">                }</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">                if (e != null)</span>
<span class="fc" id="L329">                    throw e;</span>
<span class="fc" id="L330">            }</span>
<span class="fc" id="L331">        } catch (VerificationException e) {</span>
<span class="fc" id="L332">            scriptVerificationExecutor.shutdownNow();</span>
<span class="fc" id="L333">            blockStore.abortDatabaseBatchWrite();</span>
<span class="fc" id="L334">            throw e;</span>
<span class="nc" id="L335">        } catch (BlockStoreException e) {</span>
<span class="nc" id="L336">            scriptVerificationExecutor.shutdownNow();</span>
<span class="nc" id="L337">            blockStore.abortDatabaseBatchWrite();</span>
<span class="nc" id="L338">            throw e;</span>
<span class="fc" id="L339">        }</span>
<span class="fc" id="L340">        return new TransactionOutputChanges(txOutsCreated, txOutsSpent);</span>
    }

    @Override
    /**
     * Used during reorgs to connect a block previously on a fork
     */
    protected synchronized TransactionOutputChanges connectTransactions(StoredBlock newBlock)
            throws VerificationException, BlockStoreException, PrunedException {
<span class="fc" id="L349">        checkState(lock.isHeldByCurrentThread());</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">        if (!params.passesCheckpoint(newBlock.getHeight(), newBlock.getHeader().getHash()))</span>
<span class="nc" id="L351">            throw new VerificationException(&quot;Block failed checkpoint lockin at &quot; + newBlock.getHeight());</span>

<span class="fc" id="L353">        blockStore.beginDatabaseBatchWrite();</span>
<span class="fc" id="L354">        StoredUndoableBlock block = blockStore.getUndoBlock(newBlock.getHeader().getHash());</span>
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">        if (block == null) {</span>
            // We're trying to re-org too deep and the data needed has been deleted.
<span class="nc" id="L357">            blockStore.abortDatabaseBatchWrite();</span>
<span class="nc" id="L358">            throw new PrunedException(newBlock.getHeader().getHash());</span>
        }
        TransactionOutputChanges txOutChanges;
        try {
<span class="fc" id="L362">            List&lt;Transaction&gt; transactions = block.getTransactions();</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">            if (transactions != null) {</span>
<span class="fc" id="L364">                LinkedList&lt;UTXO&gt; txOutsSpent = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L365">                LinkedList&lt;UTXO&gt; txOutsCreated = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L366">                long sigOps = 0;</span>

<span class="pc bpc" id="L368" title="1 of 2 branches missed.">                if (!params.isCheckpoint(newBlock.getHeight())) {</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">                    for (Transaction tx : transactions) {</span>
<span class="fc" id="L370">                        Sha256Hash hash = tx.getHash();</span>
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">                        if (blockStore.hasUnspentOutputs(hash, tx.getOutputs().size()))</span>
<span class="nc" id="L372">                            throw new VerificationException(&quot;Block failed BIP30 test!&quot;);</span>
<span class="fc" id="L373">                    }</span>
                }
<span class="fc" id="L375">                Coin totalFees = Coin.ZERO;</span>
<span class="fc" id="L376">                Coin coinbaseValue = null;</span>

<span class="fc bfc" id="L378" title="All 2 branches covered.">                if (scriptVerificationExecutor.isShutdown())</span>
<span class="fc" id="L379">                    scriptVerificationExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span>
<span class="fc" id="L380">                List&lt;Future&lt;VerificationException&gt;&gt; listScriptVerificationResults = new ArrayList&lt;&gt;(transactions.size());</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">                for (final Transaction tx : transactions) {</span>
<span class="fc" id="L382">                    final Set&lt;VerifyFlag&gt; verifyFlags =</span>
<span class="fc" id="L383">                        params.getTransactionVerificationFlags(newBlock.getHeader(), tx, getVersionTally(), Integer.SIZE);</span>
<span class="fc" id="L384">                    boolean isCoinBase = tx.isCoinBase();</span>
<span class="fc" id="L385">                    Coin valueIn = Coin.ZERO;</span>
<span class="fc" id="L386">                    Coin valueOut = Coin.ZERO;</span>
<span class="fc" id="L387">                    final List&lt;Script&gt; prevOutScripts = new LinkedList&lt;&gt;();</span>

<span class="fc bfc" id="L389" title="All 2 branches covered.">                    if (!isCoinBase) {</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">                        for (int index = 0; index &lt; tx.getInputs().size(); index++) {</span>
<span class="fc" id="L391">                            final TransactionInput in = tx.getInputs().get(index);</span>
<span class="fc" id="L392">                            final UTXO prevOut = blockStore.getTransactionOutput(in.getOutpoint().getHash(),</span>
<span class="fc" id="L393">                                    in.getOutpoint().getIndex());</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">                            if (prevOut == null)</span>
<span class="fc" id="L395">                                throw new VerificationException(&quot;Attempted spend of a non-existent or already spent output!&quot;);</span>
<span class="fc bfc" id="L396" title="All 4 branches covered.">                            if (prevOut.isCoinbase() &amp;&amp; newBlock.getHeight() - prevOut.getHeight() &lt; params.getSpendableCoinbaseDepth())</span>
<span class="fc" id="L397">                                throw new VerificationException(&quot;Tried to spend coinbase at depth &quot; + (newBlock.getHeight() - prevOut.getHeight()));</span>
<span class="fc" id="L398">                            valueIn = valueIn.add(prevOut.getValue());</span>
<span class="pc bpc" id="L399" title="1 of 2 branches missed.">                            if (verifyFlags.contains(VerifyFlag.P2SH)) {</span>
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">                                if (prevOut.getScript().isPayToScriptHash())</span>
<span class="nc" id="L401">                                    sigOps += Script.getP2SHSigOpCount(in.getScriptBytes());</span>
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">                                if (sigOps &gt; Block.MAX_BLOCK_SIGOPS)</span>
<span class="nc" id="L403">                                    throw new VerificationException(&quot;Too many P2SH SigOps in block&quot;);</span>
                            }

                            // TODO: Enforce DER signature format

<span class="fc" id="L408">                            prevOutScripts.add(prevOut.getScript());</span>

<span class="fc" id="L410">                            blockStore.removeUnspentTransactionOutput(prevOut);</span>
<span class="fc" id="L411">                            txOutsSpent.add(prevOut);</span>
                        }
                    }
<span class="fc" id="L414">                    Sha256Hash hash = tx.getHash();</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">                    for (TransactionOutput out : tx.getOutputs()) {</span>
<span class="fc" id="L416">                        valueOut = valueOut.add(out.getValue());</span>
<span class="fc" id="L417">                        Script script = getScript(out.getScriptBytes());</span>
<span class="fc" id="L418">                        UTXO newOut = new UTXO(hash,</span>
<span class="fc" id="L419">                                out.getIndex(),</span>
<span class="fc" id="L420">                                out.getValue(),</span>
<span class="fc" id="L421">                                newBlock.getHeight(),</span>
                                isCoinBase,
                                script,
<span class="fc" id="L424">                                getScriptAddress(script));</span>
<span class="fc" id="L425">                        blockStore.addUnspentTransactionOutput(newOut);</span>
<span class="fc" id="L426">                        txOutsCreated.add(newOut);</span>
<span class="fc" id="L427">                    }</span>
                    // All values were already checked for being non-negative (as it is verified in Transaction.verify())
                    // but we check again here just for defence in depth. Transactions with zero output value are OK.
<span class="pc bpc" id="L430" title="2 of 4 branches missed.">                    if (valueOut.signum() &lt; 0 || valueOut.compareTo(params.getMaxMoney()) &gt; 0)</span>
<span class="nc" id="L431">                        throw new VerificationException(&quot;Transaction output value out of range&quot;);</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">                    if (isCoinBase) {</span>
<span class="fc" id="L433">                        coinbaseValue = valueOut;</span>
                    } else {
<span class="pc bpc" id="L435" title="2 of 4 branches missed.">                        if (valueIn.compareTo(valueOut) &lt; 0 || valueIn.compareTo(params.getMaxMoney()) &gt; 0)</span>
<span class="nc" id="L436">                            throw new VerificationException(&quot;Transaction input value out of range&quot;);</span>
<span class="fc" id="L437">                        totalFees = totalFees.add(valueIn.subtract(valueOut));</span>
                    }

<span class="fc bfc" id="L440" title="All 2 branches covered.">                    if (!isCoinBase) {</span>
                        // Because correctlySpends modifies transactions, this must come after we are done with tx
<span class="fc" id="L442">                        FutureTask&lt;VerificationException&gt; future = new FutureTask&lt;&gt;(new Verifier(tx, prevOutScripts, verifyFlags));</span>
<span class="fc" id="L443">                        scriptVerificationExecutor.execute(future);</span>
<span class="fc" id="L444">                        listScriptVerificationResults.add(future);</span>
                    }
<span class="fc" id="L446">                }</span>
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">                if (totalFees.compareTo(params.getMaxMoney()) &gt; 0 ||</span>
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">                        newBlock.getHeader().getBlockInflation(newBlock.getHeight()).add(totalFees).compareTo(coinbaseValue) &lt; 0)</span>
<span class="nc" id="L449">                    throw new VerificationException(&quot;Transaction fees out of range&quot;);</span>
<span class="fc" id="L450">                txOutChanges = new TransactionOutputChanges(txOutsCreated, txOutsSpent);</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">                for (Future&lt;VerificationException&gt; future : listScriptVerificationResults) {</span>
                    VerificationException e;
                    try {
<span class="fc" id="L454">                        e = future.get();</span>
<span class="nc" id="L455">                    } catch (InterruptedException thrownE) {</span>
<span class="nc" id="L456">                        throw new RuntimeException(thrownE); // Shouldn't happen</span>
<span class="nc" id="L457">                    } catch (ExecutionException thrownE) {</span>
<span class="nc" id="L458">                        log.error(&quot;Script.correctlySpends threw a non-normal exception: &quot; + thrownE.getCause());</span>
<span class="nc" id="L459">                        throw new VerificationException(&quot;Bug in Script.correctlySpends, likely script malformed in some new and interesting way.&quot;, thrownE);</span>
<span class="fc" id="L460">                    }</span>
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">                    if (e != null)</span>
<span class="nc" id="L462">                        throw e;</span>
<span class="fc" id="L463">                }</span>
<span class="fc" id="L464">            } else {</span>
<span class="fc" id="L465">                txOutChanges = block.getTxOutChanges();</span>
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">                if (!params.isCheckpoint(newBlock.getHeight()))</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">                    for (UTXO out : txOutChanges.txOutsCreated) {</span>
<span class="fc" id="L468">                        Sha256Hash hash = out.getHash();</span>
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">                        if (blockStore.getTransactionOutput(hash, out.getIndex()) != null)</span>
<span class="nc" id="L470">                            throw new VerificationException(&quot;Block failed BIP30 test!&quot;);</span>
<span class="fc" id="L471">                    }</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">                for (UTXO out : txOutChanges.txOutsCreated)</span>
<span class="fc" id="L473">                    blockStore.addUnspentTransactionOutput(out);</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">                for (UTXO out : txOutChanges.txOutsSpent)</span>
<span class="fc" id="L475">                    blockStore.removeUnspentTransactionOutput(out);</span>
            }
<span class="fc" id="L477">        } catch (VerificationException e) {</span>
<span class="fc" id="L478">            scriptVerificationExecutor.shutdownNow();</span>
<span class="fc" id="L479">            blockStore.abortDatabaseBatchWrite();</span>
<span class="fc" id="L480">            throw e;</span>
<span class="nc" id="L481">        } catch (BlockStoreException e) {</span>
<span class="nc" id="L482">            scriptVerificationExecutor.shutdownNow();</span>
<span class="nc" id="L483">            blockStore.abortDatabaseBatchWrite();</span>
<span class="nc" id="L484">            throw e;</span>
<span class="fc" id="L485">        }</span>
<span class="fc" id="L486">        return txOutChanges;</span>
    }

    /**
     * This is broken for blocks that do not pass BIP30, so all BIP30-failing blocks which are allowed to fail BIP30
     * must be checkpointed.
     */
    @Override
    protected void disconnectTransactions(StoredBlock oldBlock) throws PrunedException, BlockStoreException {
<span class="fc" id="L495">        checkState(lock.isHeldByCurrentThread());</span>
<span class="fc" id="L496">        blockStore.beginDatabaseBatchWrite();</span>
        try {
<span class="fc" id="L498">            StoredUndoableBlock undoBlock = blockStore.getUndoBlock(oldBlock.getHeader().getHash());</span>
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">            if (undoBlock == null) throw new PrunedException(oldBlock.getHeader().getHash());</span>
<span class="fc" id="L500">            TransactionOutputChanges txOutChanges = undoBlock.getTxOutChanges();</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">            for (UTXO out : txOutChanges.txOutsSpent)</span>
<span class="fc" id="L502">                blockStore.addUnspentTransactionOutput(out);</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">            for (UTXO out : txOutChanges.txOutsCreated)</span>
<span class="fc" id="L504">                blockStore.removeUnspentTransactionOutput(out);</span>
<span class="nc" id="L505">        } catch (PrunedException e) {</span>
<span class="nc" id="L506">            blockStore.abortDatabaseBatchWrite();</span>
<span class="nc" id="L507">            throw e;</span>
<span class="nc" id="L508">        } catch (BlockStoreException e) {</span>
<span class="nc" id="L509">            blockStore.abortDatabaseBatchWrite();</span>
<span class="nc" id="L510">            throw e;</span>
<span class="fc" id="L511">        }</span>
<span class="fc" id="L512">    }</span>

    @Override
    protected void doSetChainHead(StoredBlock chainHead) throws BlockStoreException {
<span class="fc" id="L516">        checkState(lock.isHeldByCurrentThread());</span>
<span class="fc" id="L517">        blockStore.setVerifiedChainHead(chainHead);</span>
<span class="fc" id="L518">        blockStore.commitDatabaseBatchWrite();</span>
<span class="fc" id="L519">    }</span>

    @Override
    protected void notSettingChainHead() throws BlockStoreException {
<span class="fc" id="L523">        blockStore.abortDatabaseBatchWrite();</span>
<span class="fc" id="L524">    }</span>

    @Override
    protected StoredBlock getStoredBlockInCurrentScope(Sha256Hash hash) throws BlockStoreException {
<span class="fc" id="L528">        checkState(lock.isHeldByCurrentThread());</span>
<span class="fc" id="L529">        return blockStore.getOnceUndoableStoredBlock(hash);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>