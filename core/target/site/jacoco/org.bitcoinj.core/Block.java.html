<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Block.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bitcoinj</a> &gt; <a href="index.source.html" class="el_package">org.bitcoinj.core</a> &gt; <span class="el_source">Block.java</span></div><h1>Block.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2011 Google Inc.
 * Copyright 2014 Andreas Schildbach
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bitcoinj.core;

import com.google.common.annotations.*;
import com.google.common.base.*;
import com.google.common.collect.*;
import org.bitcoinj.script.*;
import org.slf4j.*;

import javax.annotation.*;
import java.io.*;
import java.math.*;
import java.util.*;

import static org.bitcoinj.core.Coin.*;
import static org.bitcoinj.core.Sha256Hash.*;

/**
 * &lt;p&gt;A block is a group of transactions, and is one of the fundamental data structures of the Bitcoin system.
 * It records a set of {@link Transaction}s together with some data that links it into a place in the global block
 * chain, and proves that a difficult calculation was done over its contents. See
 * &lt;a href=&quot;http://www.bitcoin.org/bitcoin.pdf&quot;&gt;the Bitcoin technical paper&lt;/a&gt; for
 * more detail on blocks. &lt;p/&gt;
 *
 * &lt;p&gt;To get a block, you can either build one from the raw bytes you can get from another implementation, or request one
 * specifically using {@link Peer#getBlock(Sha256Hash)}, or grab one from a downloaded {@link BlockChain}.&lt;/p&gt;
 * 
 * &lt;p&gt;Instances of this class are not safe for use by multiple threads.&lt;/p&gt;
 */
public class Block extends Message {
    /**
     * Flags used to control which elements of block validation are done on
     * received blocks.
     */
<span class="pc" id="L51">    public enum VerifyFlag {</span>
        /** Check that block height is in coinbase transaction (BIP 34). */
<span class="fc" id="L53">        HEIGHT_IN_COINBASE</span>
    }

<span class="fc" id="L56">    private static final Logger log = LoggerFactory.getLogger(Block.class);</span>

    /** How many bytes are required to represent a block header WITHOUT the trailing 00 length byte. */
    public static final int HEADER_SIZE = 80;

    static final long ALLOWED_TIME_DRIFT = 2 * 60 * 60; // Same value as Bitcoin Core.

    /**
     * A constant shared by the entire network: how large in bytes a block is allowed to be. One day we may have to
     * upgrade everyone to change this, so Bitcoin can continue to grow. For now it exists as an anti-DoS measure to
     * avoid somebody creating a titanically huge but valid block and forcing everyone to download/store it forever.
     */
    public static final int MAX_BLOCK_SIZE = 1 * 1000 * 1000;
    /**
     * A &quot;sigop&quot; is a signature verification operation. Because they're expensive we also impose a separate limit on
     * the number in a block to prevent somebody mining a huge block that has way more sigops than normal, so is very
     * expensive/slow to verify.
     */
    public static final int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE / 50;

    /** A value for difficultyTarget (nBits) that allows half of all possible hash solutions. Used in unit testing. */
    public static final long EASIEST_DIFFICULTY_TARGET = 0x207fFFFFL;

    /** Value to use if the block height is unknown */
    public static final int BLOCK_HEIGHT_UNKNOWN = -1;
    /** Height of the first block */
    public static final int BLOCK_HEIGHT_GENESIS = 0;

    public static final long BLOCK_VERSION_GENESIS = 1;
    /** Block version introduced in BIP 34: Height in coinbase */
    public static final long BLOCK_VERSION_BIP34 = 2;
    /** Block version introduced in BIP 66: Strict DER signatures */
    public static final long BLOCK_VERSION_BIP66 = 3;
    /** Block version introduced in BIP 65: OP_CHECKLOCKTIMEVERIFY */
    public static final long BLOCK_VERSION_BIP65 = 4;

    // Fields defined as part of the protocol format.
    private long version;
    private Sha256Hash prevBlockHash;
    private Sha256Hash merkleRoot;
    private long time;
    private long difficultyTarget; // &quot;nBits&quot;
    private long nonce;

    // TODO: Get rid of all the direct accesses to this field. It's a long-since unnecessary holdover from the Dalvik days.
    /** If null, it means this object holds only the headers. */
    @Nullable List&lt;Transaction&gt; transactions;

    /** Stores the hash of the block. If null, getHash() will recalculate it. */
    private Sha256Hash hash;

    protected boolean headerBytesValid;
    protected boolean transactionBytesValid;
    
    // Blocks can be encoded in a way that will use more bytes than is optimal (due to VarInts having multiple encodings)
    // MAX_BLOCK_SIZE must be compared to the optimal encoding, not the actual encoding, so when parsing, we keep track
    // of the size of the ideal encoding in addition to the actual message size (which Message needs)
    protected int optimalEncodingMessageSize;

    /** Special case constructor, used for the genesis node, cloneAsHeader and unit tests. */
    Block(NetworkParameters params, long setVersion) {
<span class="fc" id="L117">        super(params);</span>
        // Set up a few basic things. We are not complete after this though.
<span class="fc" id="L119">        version = setVersion;</span>
<span class="fc" id="L120">        difficultyTarget = 0x1d07fff8L;</span>
<span class="fc" id="L121">        time = System.currentTimeMillis() / 1000;</span>
<span class="fc" id="L122">        prevBlockHash = Sha256Hash.ZERO_HASH;</span>

<span class="fc" id="L124">        length = HEADER_SIZE;</span>
<span class="fc" id="L125">    }</span>

    /**
     * Constructs a block object from the Bitcoin wire format.
     * @deprecated Use {@link BitcoinSerializer#makeBlock(byte[])} instead.
     */
    @Deprecated
    public Block(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
<span class="nc" id="L133">        super(params, payloadBytes, 0, params.getDefaultSerializer(), payloadBytes.length);</span>
<span class="nc" id="L134">    }</span>

    /**
     * Construct a block object from the Bitcoin wire format.
     * @param params NetworkParameters object.
     * @param payloadBytes the payload to extract the block from.
     * @param serializer the serializer to use for this message.
     * @param length The length of message if known.  Usually this is provided when deserializing of the wire
     * as the length will be provided as part of the header.  If unknown then set to Message.UNKNOWN_LENGTH
     * @throws ProtocolException
     */
    public Block(NetworkParameters params, byte[] payloadBytes, MessageSerializer serializer, int length)
            throws ProtocolException {
<span class="nc" id="L147">        super(params, payloadBytes, 0, serializer, length);</span>
<span class="nc" id="L148">    }</span>

    /**
     * Construct a block object from the Bitcoin wire format.
     * @param params NetworkParameters object.
     * @param payloadBytes the payload to extract the block from.
     * @param offset The location of the first payload byte within the array.
     * @param serializer the serializer to use for this message.
     * @param length The length of message if known.  Usually this is provided when deserializing of the wire
     * as the length will be provided as part of the header.  If unknown then set to Message.UNKNOWN_LENGTH
     * @throws ProtocolException
     */
    public Block(NetworkParameters params, byte[] payloadBytes, int offset, MessageSerializer serializer, int length)
            throws ProtocolException {
<span class="fc" id="L162">        super(params, payloadBytes, offset, serializer, length);</span>
<span class="fc" id="L163">    }</span>

    /**
     * Construct a block object from the Bitcoin wire format. Used in the case of a block
     * contained within another message (i.e. for AuxPoW header).
     *
     * @param params NetworkParameters object.
     * @param payloadBytes Bitcoin protocol formatted byte array containing message content.
     * @param offset The location of the first payload byte within the array.
     * @param parent The message element which contains this block, maybe null for no parent.
     * @param serializer the serializer to use for this block.
     * @param length The length of message if known.  Usually this is provided when deserializing of the wire
     * as the length will be provided as part of the header.  If unknown then set to Message.UNKNOWN_LENGTH
     * @throws ProtocolException
     */
    public Block(NetworkParameters params, byte[] payloadBytes, int offset, @Nullable Message parent, MessageSerializer serializer, int length)
            throws ProtocolException {
        // TODO: Keep the parent
<span class="nc" id="L181">        super(params, payloadBytes, offset, serializer, length);</span>
<span class="nc" id="L182">    }</span>

    /**
     * Construct a block initialized with all the given fields.
     * @param params Which network the block is for.
     * @param version This should usually be set to 1 or 2, depending on if the height is in the coinbase input.
     * @param prevBlockHash Reference to previous block in the chain or {@link Sha256Hash#ZERO_HASH} if genesis.
     * @param merkleRoot The root of the merkle tree formed by the transactions.
     * @param time UNIX time when the block was mined.
     * @param difficultyTarget Number which this block hashes lower than.
     * @param nonce Arbitrary number to make the block hash lower than the target.
     * @param transactions List of transactions including the coinbase.
     */
    public Block(NetworkParameters params, long version, Sha256Hash prevBlockHash, Sha256Hash merkleRoot, long time,
                 long difficultyTarget, long nonce, List&lt;Transaction&gt; transactions) {
<span class="nc" id="L197">        super(params);</span>
<span class="nc" id="L198">        this.version = version;</span>
<span class="nc" id="L199">        this.prevBlockHash = prevBlockHash;</span>
<span class="nc" id="L200">        this.merkleRoot = merkleRoot;</span>
<span class="nc" id="L201">        this.time = time;</span>
<span class="nc" id="L202">        this.difficultyTarget = difficultyTarget;</span>
<span class="nc" id="L203">        this.nonce = nonce;</span>
<span class="nc" id="L204">        this.transactions = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L205">        this.transactions.addAll(transactions);</span>
<span class="nc" id="L206">    }</span>


    /**
     * &lt;p&gt;A utility method that calculates how much new Bitcoin would be created by the block at the given height.
     * The inflation of Bitcoin is predictable and drops roughly every 4 years (210,000 blocks). At the dawn of
     * the system it was 50 coins per block, in late 2012 it went to 25 coins per block, and so on. The size of
     * a coinbase transaction is inflation plus fees.&lt;/p&gt;
     *
     * &lt;p&gt;The half-life is controlled by {@link org.bitcoinj.core.NetworkParameters#getSubsidyDecreaseBlockCount()}.
     * &lt;/p&gt;
     */
    public Coin getBlockInflation(int height) {
<span class="fc" id="L219">        return FIFTY_COINS.shiftRight(height / params.getSubsidyDecreaseBlockCount());</span>
    }

    /**
     * Parse transactions from the block.
     * 
     * @param transactionsOffset Offset of the transactions within the block.
     * Useful for non-Bitcoin chains where the block header may not be a fixed
     * size.
     */
    protected void parseTransactions(final int transactionsOffset) throws ProtocolException {
<span class="fc" id="L230">        cursor = transactionsOffset;</span>
<span class="fc" id="L231">        optimalEncodingMessageSize = HEADER_SIZE;</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">        if (payload.length == cursor) {</span>
            // This message is just a header, it has no transactions.
<span class="fc" id="L234">            transactionBytesValid = false;</span>
<span class="fc" id="L235">            return;</span>
        }

<span class="fc" id="L238">        int numTransactions = (int) readVarInt();</span>
<span class="fc" id="L239">        optimalEncodingMessageSize += VarInt.sizeOf(numTransactions);</span>
<span class="fc" id="L240">        transactions = new ArrayList&lt;&gt;(numTransactions);</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">        for (int i = 0; i &lt; numTransactions; i++) {</span>
<span class="fc" id="L242">            Transaction tx = new Transaction(params, payload, cursor, this, serializer, UNKNOWN_LENGTH);</span>
            // Label the transaction as coming from the P2P network, so code that cares where we first saw it knows.
<span class="fc" id="L244">            tx.getConfidence().setSource(TransactionConfidence.Source.NETWORK);</span>
<span class="fc" id="L245">            transactions.add(tx);</span>
<span class="fc" id="L246">            cursor += tx.getMessageSize();</span>
<span class="fc" id="L247">            optimalEncodingMessageSize += tx.getOptimalEncodingMessageSize();</span>
        }
<span class="fc" id="L249">        transactionBytesValid = serializer.isParseRetainMode();</span>
<span class="fc" id="L250">    }</span>

    @Override
    protected void parse() throws ProtocolException {
        // header
<span class="fc" id="L255">        cursor = offset;</span>
<span class="fc" id="L256">        version = readUint32();</span>
<span class="fc" id="L257">        prevBlockHash = readHash();</span>
<span class="fc" id="L258">        merkleRoot = readHash();</span>
<span class="fc" id="L259">        time = readUint32();</span>
<span class="fc" id="L260">        difficultyTarget = readUint32();</span>
<span class="fc" id="L261">        nonce = readUint32();</span>
<span class="fc" id="L262">        hash = Sha256Hash.wrapReversed(Sha256Hash.hashTwice(payload, offset, cursor - offset));</span>
<span class="fc" id="L263">        headerBytesValid = serializer.isParseRetainMode();</span>

        // transactions
<span class="fc" id="L266">        parseTransactions(offset + HEADER_SIZE);</span>
<span class="fc" id="L267">        length = cursor - offset;</span>
<span class="fc" id="L268">    }</span>
    
    public int getOptimalEncodingMessageSize() {
<span class="fc bfc" id="L271" title="All 2 branches covered.">        if (optimalEncodingMessageSize != 0)</span>
<span class="fc" id="L272">            return optimalEncodingMessageSize;</span>
<span class="fc" id="L273">        optimalEncodingMessageSize = bitcoinSerialize().length;</span>
<span class="fc" id="L274">        return optimalEncodingMessageSize;</span>
    }

    // default for testing
    void writeHeader(OutputStream stream) throws IOException {
        // try for cached write first
<span class="pc bpc" id="L280" title="5 of 6 branches missed.">        if (headerBytesValid &amp;&amp; payload != null &amp;&amp; payload.length &gt;= offset + HEADER_SIZE) {</span>
<span class="nc" id="L281">            stream.write(payload, offset, HEADER_SIZE);</span>
<span class="nc" id="L282">            return;</span>
        }
        // fall back to manual write
<span class="fc" id="L285">        Utils.uint32ToByteStreamLE(version, stream);</span>
<span class="fc" id="L286">        stream.write(prevBlockHash.getReversedBytes());</span>
<span class="fc" id="L287">        stream.write(getMerkleRoot().getReversedBytes());</span>
<span class="fc" id="L288">        Utils.uint32ToByteStreamLE(time, stream);</span>
<span class="fc" id="L289">        Utils.uint32ToByteStreamLE(difficultyTarget, stream);</span>
<span class="fc" id="L290">        Utils.uint32ToByteStreamLE(nonce, stream);</span>
<span class="fc" id="L291">    }</span>

    private void writeTransactions(OutputStream stream) throws IOException {
        // check for no transaction conditions first
        // must be a more efficient way to do this but I'm tired atm.
<span class="fc bfc" id="L296" title="All 2 branches covered.">        if (transactions == null) {</span>
<span class="fc" id="L297">            return;</span>
        }

        // confirmed we must have transactions either cached or as objects.
<span class="pc bpc" id="L301" title="2 of 6 branches missed.">        if (transactionBytesValid &amp;&amp; payload != null &amp;&amp; payload.length &gt;= offset + length) {</span>
<span class="fc" id="L302">            stream.write(payload, offset + HEADER_SIZE, length - HEADER_SIZE);</span>
<span class="fc" id="L303">            return;</span>
        }

<span class="pc bpc" id="L306" title="1 of 2 branches missed.">        if (transactions != null) {</span>
<span class="fc" id="L307">            stream.write(new VarInt(transactions.size()).encode());</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">            for (Transaction tx : transactions) {</span>
<span class="fc" id="L309">                tx.bitcoinSerialize(stream);</span>
<span class="fc" id="L310">            }</span>
        }
<span class="fc" id="L312">    }</span>

    /**
     * Special handling to check if we have a valid byte array for both header
     * and transactions
     *
     * @throws IOException
     */
    @Override
    public byte[] bitcoinSerialize() {
        // we have completely cached byte array.
<span class="pc bpc" id="L323" title="1 of 4 branches missed.">        if (headerBytesValid &amp;&amp; transactionBytesValid) {</span>
<span class="fc" id="L324">            Preconditions.checkNotNull(payload, &quot;Bytes should never be null if headerBytesValid &amp;&amp; transactionBytesValid&quot;);</span>
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">            if (length == payload.length) {</span>
<span class="fc" id="L326">                return payload;</span>
            } else {
                // byte array is offset so copy out the correct range.
<span class="nc" id="L329">                byte[] buf = new byte[length];</span>
<span class="nc" id="L330">                System.arraycopy(payload, offset, buf, 0, length);</span>
<span class="nc" id="L331">                return buf;</span>
            }
        }

        // At least one of the two cacheable components is invalid
        // so fall back to stream write since we can't be sure of the length.
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">        ByteArrayOutputStream stream = new UnsafeByteArrayOutputStream(length == UNKNOWN_LENGTH ? HEADER_SIZE + guessTransactionsLength() : length);</span>
        try {
<span class="fc" id="L339">            writeHeader(stream);</span>
<span class="fc" id="L340">            writeTransactions(stream);</span>
<span class="nc" id="L341">        } catch (IOException e) {</span>
            // Cannot happen, we are serializing to a memory stream.
<span class="fc" id="L343">        }</span>
<span class="fc" id="L344">        return stream.toByteArray();</span>
    }

    @Override
    protected void bitcoinSerializeToStream(OutputStream stream) throws IOException {
<span class="fc" id="L349">        writeHeader(stream);</span>
        // We may only have enough data to write the header.
<span class="fc" id="L351">        writeTransactions(stream);</span>
<span class="fc" id="L352">    }</span>

    /**
     * Provides a reasonable guess at the byte length of the transactions part of the block.
     * The returned value will be accurate in 99% of cases and in those cases where not will probably slightly
     * oversize.
     *
     * This is used to preallocate the underlying byte array for a ByteArrayOutputStream.  If the size is under the
     * real value the only penalty is resizing of the underlying byte array.
     */
    private int guessTransactionsLength() {
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (transactionBytesValid)</span>
<span class="nc" id="L364">            return payload.length - HEADER_SIZE;</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">        if (transactions == null)</span>
<span class="nc" id="L366">            return 0;</span>
<span class="nc" id="L367">        int len = VarInt.sizeOf(transactions.size());</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">        for (Transaction tx : transactions) {</span>
            // 255 is just a guess at an average tx length
<span class="nc bnc" id="L370" title="All 2 branches missed.">            len += tx.length == UNKNOWN_LENGTH ? 255 : tx.length;</span>
<span class="nc" id="L371">        }</span>
<span class="nc" id="L372">        return len;</span>
    }

    @Override
    protected void unCache() {
        // Since we have alternate uncache methods to use internally this will only ever be called by a child
        // transaction so we only need to invalidate that part of the cache.
<span class="fc" id="L379">        unCacheTransactions();</span>
<span class="fc" id="L380">    }</span>

    private void unCacheHeader() {
<span class="fc" id="L383">        headerBytesValid = false;</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">        if (!transactionBytesValid)</span>
<span class="fc" id="L385">            payload = null;</span>
<span class="fc" id="L386">        hash = null;</span>
<span class="fc" id="L387">    }</span>

    private void unCacheTransactions() {
<span class="fc" id="L390">        transactionBytesValid = false;</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">        if (!headerBytesValid)</span>
<span class="fc" id="L392">            payload = null;</span>
        // Current implementation has to uncache headers as well as any change to a tx will alter the merkle root. In
        // future we can go more granular and cache merkle root separately so rest of the header does not need to be
        // rewritten.
<span class="fc" id="L396">        unCacheHeader();</span>
        // Clear merkleRoot last as it may end up being parsed during unCacheHeader().
<span class="fc" id="L398">        merkleRoot = null;</span>
<span class="fc" id="L399">    }</span>

    /**
     * Calculates the block hash by serializing the block and hashing the
     * resulting bytes.
     */
    private Sha256Hash calculateHash() {
        try {
<span class="fc" id="L407">            ByteArrayOutputStream bos = new UnsafeByteArrayOutputStream(HEADER_SIZE);</span>
<span class="fc" id="L408">            writeHeader(bos);</span>
<span class="fc" id="L409">            return Sha256Hash.wrapReversed(Sha256Hash.hashTwice(bos.toByteArray()));</span>
<span class="nc" id="L410">        } catch (IOException e) {</span>
<span class="nc" id="L411">            throw new RuntimeException(e); // Cannot happen.</span>
        }
    }

    /**
     * Returns the hash of the block (which for a valid, solved block should be below the target) in the form seen on
     * the block explorer. If you call this on block 1 in the mainnet chain
     * you will get &quot;00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048&quot;.
     */
    public String getHashAsString() {
<span class="fc" id="L421">        return getHash().toString();</span>
    }

    /**
     * Returns the hash of the block (which for a valid, solved block should be
     * below the target). Big endian.
     */
    @Override
    public Sha256Hash getHash() {
<span class="fc bfc" id="L430" title="All 2 branches covered.">        if (hash == null)</span>
<span class="fc" id="L431">            hash = calculateHash();</span>
<span class="fc" id="L432">        return hash;</span>
    }

    /**
     * The number that is one greater than the largest representable SHA-256
     * hash.
     */
<span class="fc" id="L439">    private static BigInteger LARGEST_HASH = BigInteger.ONE.shiftLeft(256);</span>

    /**
     * Returns the work represented by this block.&lt;p&gt;
     *
     * Work is defined as the number of tries needed to solve a block in the
     * average case. Consider a difficulty target that covers 5% of all possible
     * hash values. Then the work of the block will be 20. As the target gets
     * lower, the amount of work goes up.
     */
    public BigInteger getWork() throws VerificationException {
<span class="fc" id="L450">        BigInteger target = getDifficultyTargetAsInteger();</span>
<span class="fc" id="L451">        return LARGEST_HASH.divide(target.add(BigInteger.ONE));</span>
    }

    /** Returns a copy of the block, but without any transactions. */
    public Block cloneAsHeader() {
<span class="fc" id="L456">        Block block = new Block(params, BLOCK_VERSION_GENESIS);</span>
<span class="fc" id="L457">        copyBitcoinHeaderTo(block);</span>
<span class="fc" id="L458">        return block;</span>
    }

    /** Copy the block without transactions into the provided empty block. */
    protected final void copyBitcoinHeaderTo(final Block block) {
<span class="fc" id="L463">        block.nonce = nonce;</span>
<span class="fc" id="L464">        block.prevBlockHash = prevBlockHash;</span>
<span class="fc" id="L465">        block.merkleRoot = getMerkleRoot();</span>
<span class="fc" id="L466">        block.version = version;</span>
<span class="fc" id="L467">        block.time = time;</span>
<span class="fc" id="L468">        block.difficultyTarget = difficultyTarget;</span>
<span class="fc" id="L469">        block.transactions = null;</span>
<span class="fc" id="L470">        block.hash = getHash();</span>
<span class="fc" id="L471">    }</span>

    /**
     * Returns a multi-line string containing a description of the contents of
     * the block. Use for debugging purposes only.
     */
    @Override
    public String toString() {
<span class="fc" id="L479">        StringBuilder s = new StringBuilder();</span>
<span class="fc" id="L480">        s.append(&quot; block: \n&quot;);</span>
<span class="fc" id="L481">        s.append(&quot;   hash: &quot;).append(getHashAsString()).append('\n');</span>
<span class="fc" id="L482">        s.append(&quot;   version: &quot;).append(version);</span>
<span class="fc bfc" id="L483" title="All 4 branches covered.">        String bips = Joiner.on(&quot;, &quot;).skipNulls().join(isBIP34() ? &quot;BIP34&quot; : null, isBIP66() ? &quot;BIP66&quot; : null,</span>
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">                isBIP65() ? &quot;BIP65&quot; : null);</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">        if (!bips.isEmpty())</span>
<span class="fc" id="L486">            s.append(&quot; (&quot;).append(bips).append(')');</span>
<span class="fc" id="L487">        s.append('\n');</span>
<span class="fc" id="L488">        s.append(&quot;   previous block: &quot;).append(getPrevBlockHash()).append(&quot;\n&quot;);</span>
<span class="fc" id="L489">        s.append(&quot;   merkle root: &quot;).append(getMerkleRoot()).append(&quot;\n&quot;);</span>
<span class="fc" id="L490">        s.append(&quot;   time: &quot;).append(time).append(&quot; (&quot;).append(Utils.dateTimeFormat(time * 1000)).append(&quot;)\n&quot;);</span>
<span class="fc" id="L491">        s.append(&quot;   difficulty target (nBits): &quot;).append(difficultyTarget).append(&quot;\n&quot;);</span>
<span class="fc" id="L492">        s.append(&quot;   nonce: &quot;).append(nonce).append(&quot;\n&quot;);</span>
<span class="fc bfc" id="L493" title="All 4 branches covered.">        if (transactions != null &amp;&amp; transactions.size() &gt; 0) {</span>
<span class="fc" id="L494">            s.append(&quot;   with &quot;).append(transactions.size()).append(&quot; transaction(s):\n&quot;);</span>
<span class="fc bfc" id="L495" title="All 2 branches covered.">            for (Transaction tx : transactions) {</span>
<span class="fc" id="L496">                s.append(tx);</span>
<span class="fc" id="L497">            }</span>
        }
<span class="fc" id="L499">        return s.toString();</span>
    }

    /**
     * &lt;p&gt;Finds a value of nonce that makes the blocks hash lower than the difficulty target. This is called mining, but
     * solve() is far too slow to do real mining with. It exists only for unit testing purposes.
     *
     * &lt;p&gt;This can loop forever if a solution cannot be found solely by incrementing nonce. It doesn't change
     * extraNonce.&lt;/p&gt;
     */
    public void solve() {
        while (true) {
            try {
                // Is our proof of work valid yet?
<span class="fc bfc" id="L513" title="All 2 branches covered.">                if (checkProofOfWork(false))</span>
<span class="fc" id="L514">                    return;</span>
                // No, so increment the nonce and try again.
<span class="fc" id="L516">                setNonce(getNonce() + 1);</span>
<span class="nc" id="L517">            } catch (VerificationException e) {</span>
<span class="nc" id="L518">                throw new RuntimeException(e); // Cannot happen.</span>
<span class="fc" id="L519">            }</span>
        }
    }

    /**
     * Returns the difficulty target as a 256 bit value that can be compared to a SHA-256 hash. Inside a block the
     * target is represented using a compact form. If this form decodes to a value that is out of bounds, an exception
     * is thrown.
     */
    public BigInteger getDifficultyTargetAsInteger() throws VerificationException {
<span class="fc" id="L529">        BigInteger target = Utils.decodeCompactBits(difficultyTarget);</span>
<span class="pc bpc" id="L530" title="1 of 4 branches missed.">        if (target.signum() &lt;= 0 || target.compareTo(params.maxTarget) &gt; 0)</span>
<span class="fc" id="L531">            throw new VerificationException(&quot;Difficulty target is bad: &quot; + target.toString());</span>
<span class="fc" id="L532">        return target;</span>
    }

    /** Returns true if the hash of the block is OK (lower than difficulty target). */
    protected boolean checkProofOfWork(boolean throwException) throws VerificationException {
        // This part is key - it is what proves the block was as difficult to make as it claims
        // to be. Note however that in the context of this function, the block can claim to be
        // as difficult as it wants to be .... if somebody was able to take control of our network
        // connection and fork us onto a different chain, they could send us valid blocks with
        // ridiculously easy difficulty and this function would accept them.
        //
        // To prevent this attack from being possible, elsewhere we check that the difficultyTarget
        // field is of the right value. This requires us to have the preceeding blocks.
<span class="fc" id="L545">        BigInteger target = getDifficultyTargetAsInteger();</span>

<span class="fc" id="L547">        BigInteger h = getHash().toBigInteger();</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">        if (h.compareTo(target) &gt; 0) {</span>
            // Proof of work check failed!
<span class="fc bfc" id="L550" title="All 2 branches covered.">            if (throwException)</span>
<span class="fc" id="L551">                throw new VerificationException(&quot;Hash is higher than target: &quot; + getHashAsString() + &quot; vs &quot;</span>
<span class="fc" id="L552">                        + target.toString(16));</span>
            else
<span class="fc" id="L554">                return false;</span>
        }
<span class="fc" id="L556">        return true;</span>
    }

    private void checkTimestamp() throws VerificationException {
<span class="fc" id="L560">        final long allowedTime = Utils.currentTimeSeconds() + ALLOWED_TIME_DRIFT;</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">        if (time &gt; allowedTime)</span>
<span class="fc" id="L562">            throw new VerificationException(String.format(Locale.US,</span>
<span class="fc" id="L563">                    &quot;Block too far in future: %s (%d) vs allowed %s (%d)&quot;, Utils.dateTimeFormat(time * 1000), time,</span>
<span class="fc" id="L564">                    Utils.dateTimeFormat(allowedTime * 1000), allowedTime));</span>
<span class="fc" id="L565">    }</span>

    private void checkSigOps() throws VerificationException {
        // Check there aren't too many signature verifications in the block. This is an anti-DoS measure, see the
        // comments for MAX_BLOCK_SIGOPS.
<span class="fc" id="L570">        int sigOps = 0;</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">        for (Transaction tx : transactions) {</span>
<span class="fc" id="L572">            sigOps += tx.getSigOpCount();</span>
<span class="fc" id="L573">        }</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">        if (sigOps &gt; MAX_BLOCK_SIGOPS)</span>
<span class="fc" id="L575">            throw new VerificationException(&quot;Block had too many Signature Operations&quot;);</span>
<span class="fc" id="L576">    }</span>

    private void checkMerkleRoot() throws VerificationException {
<span class="fc" id="L579">        Sha256Hash calculatedRoot = calculateMerkleRoot();</span>
<span class="fc bfc" id="L580" title="All 2 branches covered.">        if (!calculatedRoot.equals(merkleRoot)) {</span>
<span class="fc" id="L581">            log.error(&quot;Merkle tree did not verify&quot;);</span>
<span class="fc" id="L582">            throw new VerificationException(&quot;Merkle hashes do not match: &quot; + calculatedRoot + &quot; vs &quot; + merkleRoot);</span>
        }
<span class="fc" id="L584">    }</span>

    private Sha256Hash calculateMerkleRoot() {
<span class="fc" id="L587">        List&lt;byte[]&gt; tree = buildMerkleTree();</span>
<span class="fc" id="L588">        return Sha256Hash.wrap(tree.get(tree.size() - 1));</span>
    }

    private List&lt;byte[]&gt; buildMerkleTree() {
        // The Merkle root is based on a tree of hashes calculated from the transactions:
        //
        //     root
        //      / \
        //   A      B
        //  / \    / \
        // t1 t2 t3 t4
        //
        // The tree is represented as a list: t1,t2,t3,t4,A,B,root where each
        // entry is a hash.
        //
        // The hashing algorithm is double SHA-256. The leaves are a hash of the serialized contents of the transaction.
        // The interior nodes are hashes of the concenation of the two child hashes.
        //
        // This structure allows the creation of proof that a transaction was included into a block without having to
        // provide the full block contents. Instead, you can provide only a Merkle branch. For example to prove tx2 was
        // in a block you can just provide tx2, the hash(tx1) and B. Now the other party has everything they need to
        // derive the root, which can be checked against the block header. These proofs aren't used right now but
        // will be helpful later when we want to download partial block contents.
        //
        // Note that if the number of transactions is not even the last tx is repeated to make it so (see
        // tx3 above). A tree with 5 transactions would look like this:
        //
        //         root
        //        /     \
        //       1        5
        //     /   \     / \
        //    2     3    4  4
        //  / \   / \   / \
        // t1 t2 t3 t4 t5 t5
<span class="fc" id="L622">        ArrayList&lt;byte[]&gt; tree = new ArrayList&lt;&gt;();</span>
        // Start by adding all the hashes of the transactions as leaves of the tree.
<span class="fc bfc" id="L624" title="All 2 branches covered.">        for (Transaction t : transactions) {</span>
<span class="fc" id="L625">            tree.add(t.getHash().getBytes());</span>
<span class="fc" id="L626">        }</span>
<span class="fc" id="L627">        int levelOffset = 0; // Offset in the list where the currently processed level starts.</span>
        // Step through each level, stopping when we reach the root (levelSize == 1).
<span class="fc bfc" id="L629" title="All 2 branches covered.">        for (int levelSize = transactions.size(); levelSize &gt; 1; levelSize = (levelSize + 1) / 2) {</span>
            // For each pair of nodes on that level:
<span class="fc bfc" id="L631" title="All 2 branches covered.">            for (int left = 0; left &lt; levelSize; left += 2) {</span>
                // The right hand node can be the same as the left hand, in the case where we don't have enough
                // transactions.
<span class="fc" id="L634">                int right = Math.min(left + 1, levelSize - 1);</span>
<span class="fc" id="L635">                byte[] leftBytes = Utils.reverseBytes(tree.get(levelOffset + left));</span>
<span class="fc" id="L636">                byte[] rightBytes = Utils.reverseBytes(tree.get(levelOffset + right));</span>
<span class="fc" id="L637">                tree.add(Utils.reverseBytes(hashTwice(leftBytes, 0, 32, rightBytes, 0, 32)));</span>
            }
            // Move to the next level.
<span class="fc" id="L640">            levelOffset += levelSize;</span>
        }
<span class="fc" id="L642">        return tree;</span>
    }

    /**
     * Verify the transactions on a block.
     *
     * @param height block height, if known, or -1 otherwise. If provided, used
     * to validate the coinbase input script of v2 and above blocks.
     * @throws VerificationException if there was an error verifying the block.
     */
    private void checkTransactions(final int height, final EnumSet&lt;VerifyFlag&gt; flags)
            throws VerificationException {
        // The first transaction in a block must always be a coinbase transaction.
<span class="fc bfc" id="L655" title="All 2 branches covered.">        if (!transactions.get(0).isCoinBase())</span>
<span class="fc" id="L656">            throw new VerificationException(&quot;First tx is not coinbase&quot;);</span>
<span class="pc bpc" id="L657" title="1 of 4 branches missed.">        if (flags.contains(Block.VerifyFlag.HEIGHT_IN_COINBASE) &amp;&amp; height &gt;= BLOCK_HEIGHT_GENESIS) {</span>
<span class="fc" id="L658">            transactions.get(0).checkCoinBaseHeight(height);</span>
        }
        // The rest must not be.
<span class="fc bfc" id="L661" title="All 2 branches covered.">        for (int i = 1; i &lt; transactions.size(); i++) {</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">            if (transactions.get(i).isCoinBase())</span>
<span class="fc" id="L663">                throw new VerificationException(&quot;TX &quot; + i + &quot; is coinbase when it should not be.&quot;);</span>
        }
<span class="fc" id="L665">    }</span>

    /**
     * Checks the block data to ensure it follows the rules laid out in the network parameters. Specifically,
     * throws an exception if the proof of work is invalid, or if the timestamp is too far from what it should be.
     * This is &lt;b&gt;not&lt;/b&gt; everything that is required for a block to be valid, only what is checkable independent
     * of the chain and without a transaction index.
     *
     * @throws VerificationException
     */
    public void verifyHeader() throws VerificationException {
        // Prove that this block is OK. It might seem that we can just ignore most of these checks given that the
        // network is also verifying the blocks, but we cannot as it'd open us to a variety of obscure attacks.
        //
        // Firstly we need to ensure this block does in fact represent real work done. If the difficulty is high
        // enough, it's probably been done by the network.
<span class="fc" id="L681">        checkProofOfWork(true);</span>
<span class="fc" id="L682">        checkTimestamp();</span>
<span class="fc" id="L683">    }</span>

    /**
     * Checks the block contents
     *
     * @param height block height, if known, or -1 otherwise. If valid, used
     * to validate the coinbase input script of v2 and above blocks.
     * @param flags flags to indicate which tests should be applied (i.e.
     * whether to test for height in the coinbase transaction).
     * @throws VerificationException if there was an error verifying the block.
     */
    public void verifyTransactions(final int height, final EnumSet&lt;VerifyFlag&gt; flags) throws VerificationException {
        // Now we need to check that the body of the block actually matches the headers. The network won't generate
        // an invalid block, but if we didn't validate this then an untrusted man-in-the-middle could obtain the next
        // valid block from the network and simply replace the transactions in it with their own fictional
        // transactions that reference spent or non-existant inputs.
<span class="fc bfc" id="L699" title="All 2 branches covered.">        if (transactions.isEmpty())</span>
<span class="fc" id="L700">            throw new VerificationException(&quot;Block had no transactions&quot;);</span>
<span class="fc bfc" id="L701" title="All 2 branches covered.">        if (this.getOptimalEncodingMessageSize() &gt; MAX_BLOCK_SIZE)</span>
<span class="fc" id="L702">            throw new VerificationException(&quot;Block larger than MAX_BLOCK_SIZE&quot;);</span>
<span class="fc" id="L703">        checkTransactions(height, flags);</span>
<span class="fc" id="L704">        checkMerkleRoot();</span>
<span class="fc" id="L705">        checkSigOps();</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">        for (Transaction transaction : transactions)</span>
<span class="fc" id="L707">            transaction.verify();</span>
<span class="fc" id="L708">        }</span>

    /**
     * Verifies both the header and that the transactions hash to the merkle root.
     *
     * @param height block height, if known, or -1 otherwise.
     * @param flags flags to indicate which tests should be applied (i.e.
     * whether to test for height in the coinbase transaction).
     * @throws VerificationException if there was an error verifying the block.
     */
    public void verify(final int height, final EnumSet&lt;VerifyFlag&gt; flags) throws VerificationException {
<span class="fc" id="L719">        verifyHeader();</span>
<span class="fc" id="L720">        verifyTransactions(height, flags);</span>
<span class="fc" id="L721">    }</span>

    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L725" title="1 of 2 branches missed.">        if (this == o) return true;</span>
<span class="pc bpc" id="L726" title="2 of 4 branches missed.">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L727">        return getHash().equals(((Block)o).getHash());</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L732">        return getHash().hashCode();</span>
    }

    /**
     * Returns the merkle root in big endian form, calculating it from transactions if necessary.
     */
    public Sha256Hash getMerkleRoot() {
<span class="fc bfc" id="L739" title="All 2 branches covered.">        if (merkleRoot == null) {</span>
            //TODO check if this is really necessary.
<span class="fc" id="L741">            unCacheHeader();</span>
<span class="fc" id="L742">            merkleRoot = calculateMerkleRoot();</span>
        }
<span class="fc" id="L744">        return merkleRoot;</span>
    }

    /** Exists only for unit testing. */
    void setMerkleRoot(Sha256Hash value) {
<span class="fc" id="L749">        unCacheHeader();</span>
<span class="fc" id="L750">        merkleRoot = value;</span>
<span class="fc" id="L751">        hash = null;</span>
<span class="fc" id="L752">    }</span>

    /** Adds a transaction to this block. The nonce and merkle root are invalid after this. */
    public void addTransaction(Transaction t) {
<span class="fc" id="L756">        addTransaction(t, true);</span>
<span class="fc" id="L757">    }</span>

    /** Adds a transaction to this block, with or without checking the sanity of doing so */
    void addTransaction(Transaction t, boolean runSanityChecks) {
<span class="fc" id="L761">        unCacheTransactions();</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">        if (transactions == null) {</span>
<span class="fc" id="L763">            transactions = new ArrayList&lt;&gt;();</span>
        }
<span class="fc" id="L765">        t.setParent(this);</span>
<span class="fc bfc" id="L766" title="All 6 branches covered.">        if (runSanityChecks &amp;&amp; transactions.size() == 0 &amp;&amp; !t.isCoinBase())</span>
<span class="fc" id="L767">            throw new RuntimeException(&quot;Attempted to add a non-coinbase transaction as the first transaction: &quot; + t);</span>
<span class="pc bpc" id="L768" title="1 of 6 branches missed.">        else if (runSanityChecks &amp;&amp; transactions.size() &gt; 0 &amp;&amp; t.isCoinBase())</span>
<span class="nc" id="L769">            throw new RuntimeException(&quot;Attempted to add a coinbase transaction when there already is one: &quot; + t);</span>
<span class="fc" id="L770">        transactions.add(t);</span>
<span class="fc" id="L771">        adjustLength(transactions.size(), t.length);</span>
        // Force a recalculation next time the values are needed.
<span class="fc" id="L773">        merkleRoot = null;</span>
<span class="fc" id="L774">        hash = null;</span>
<span class="fc" id="L775">    }</span>

    /** Returns the version of the block data structure as defined by the Bitcoin protocol. */
    public long getVersion() {
<span class="fc" id="L779">        return version;</span>
    }

    /**
     * Returns the hash of the previous block in the chain, as defined by the block header.
     */
    public Sha256Hash getPrevBlockHash() {
<span class="fc" id="L786">        return prevBlockHash;</span>
    }

    void setPrevBlockHash(Sha256Hash prevBlockHash) {
<span class="fc" id="L790">        unCacheHeader();</span>
<span class="fc" id="L791">        this.prevBlockHash = prevBlockHash;</span>
<span class="fc" id="L792">        this.hash = null;</span>
<span class="fc" id="L793">    }</span>

    /**
     * Returns the time at which the block was solved and broadcast, according to the clock of the solving node. This
     * is measured in seconds since the UNIX epoch (midnight Jan 1st 1970).
     */
    public long getTimeSeconds() {
<span class="fc" id="L800">        return time;</span>
    }

    /**
     * Returns the time at which the block was solved and broadcast, according to the clock of the solving node.
     */
    public Date getTime() {
<span class="fc" id="L807">        return new Date(getTimeSeconds()*1000);</span>
    }

    public void setTime(long time) {
<span class="fc" id="L811">        unCacheHeader();</span>
<span class="fc" id="L812">        this.time = time;</span>
<span class="fc" id="L813">        this.hash = null;</span>
<span class="fc" id="L814">    }</span>

    /**
     * Returns the difficulty of the proof of work that this block should meet encoded &lt;b&gt;in compact form&lt;/b&gt;. The {@link
     * BlockChain} verifies that this is not too easy by looking at the length of the chain when the block is added.
     * To find the actual value the hash should be compared against, use
     * {@link org.bitcoinj.core.Block#getDifficultyTargetAsInteger()}. Note that this is &lt;b&gt;not&lt;/b&gt; the same as
     * the difficulty value reported by the Bitcoin &quot;getdifficulty&quot; RPC that you may see on various block explorers.
     * That number is the result of applying a formula to the underlying difficulty to normalize the minimum to 1.
     * Calculating the difficulty that way is currently unsupported.
     */
    public long getDifficultyTarget() {
<span class="fc" id="L826">        return difficultyTarget;</span>
    }

    /** Sets the difficulty target in compact form. */
    public void setDifficultyTarget(long compactForm) {
<span class="fc" id="L831">        unCacheHeader();</span>
<span class="fc" id="L832">        this.difficultyTarget = compactForm;</span>
<span class="fc" id="L833">        this.hash = null;</span>
<span class="fc" id="L834">    }</span>

    /**
     * Returns the nonce, an arbitrary value that exists only to make the hash of the block header fall below the
     * difficulty target.
     */
    public long getNonce() {
<span class="fc" id="L841">        return nonce;</span>
    }

    /** Sets the nonce and clears any cached data. */
    public void setNonce(long nonce) {
<span class="fc" id="L846">        unCacheHeader();</span>
<span class="fc" id="L847">        this.nonce = nonce;</span>
<span class="fc" id="L848">        this.hash = null;</span>
<span class="fc" id="L849">    }</span>

    /** Returns an immutable list of transactions held in this block, or null if this object represents just a header. */
    @Nullable
    public List&lt;Transaction&gt; getTransactions() {
<span class="fc bfc" id="L854" title="All 2 branches covered.">        return transactions == null ? null : ImmutableList.copyOf(transactions);</span>
    }

    // ///////////////////////////////////////////////////////////////////////////////////////////////
    // Unit testing related methods.

    // Used to make transactions unique.
    private static int txCounter;

    /** Adds a coinbase transaction to the block. This exists for unit tests.
     * 
     * @param height block height, if known, or -1 otherwise.
     */
    @VisibleForTesting
    void addCoinbaseTransaction(byte[] pubKeyTo, Coin value, final int height) {
<span class="fc" id="L869">        unCacheTransactions();</span>
<span class="fc" id="L870">        transactions = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L871">        Transaction coinbase = new Transaction(params);</span>
<span class="fc" id="L872">        final ScriptBuilder inputBuilder = new ScriptBuilder();</span>

<span class="fc bfc" id="L874" title="All 2 branches covered.">        if (height &gt;= Block.BLOCK_HEIGHT_GENESIS) {</span>
<span class="fc" id="L875">            inputBuilder.number(height);</span>
        }
<span class="fc" id="L877">        inputBuilder.data(new byte[]{(byte) txCounter, (byte) (txCounter++ &gt;&gt; 8)});</span>

        // A real coinbase transaction has some stuff in the scriptSig like the extraNonce and difficulty. The
        // transactions are distinguished by every TX output going to a different key.
        //
        // Here we will do things a bit differently so a new address isn't needed every time. We'll put a simple
        // counter in the scriptSig so every transaction has a different hash.
<span class="fc" id="L884">        coinbase.addInput(new TransactionInput(params, coinbase,</span>
<span class="fc" id="L885">                inputBuilder.build().getProgram()));</span>
<span class="fc" id="L886">        coinbase.addOutput(new TransactionOutput(params, coinbase, value,</span>
<span class="fc" id="L887">                ScriptBuilder.createOutputScript(ECKey.fromPublicOnly(pubKeyTo)).getProgram()));</span>
<span class="fc" id="L888">        transactions.add(coinbase);</span>
<span class="fc" id="L889">        coinbase.setParent(this);</span>
<span class="fc" id="L890">        coinbase.length = coinbase.unsafeBitcoinSerialize().length;</span>
<span class="fc" id="L891">        adjustLength(transactions.size(), coinbase.length);</span>
<span class="fc" id="L892">    }</span>

<span class="fc" id="L894">    static final byte[] EMPTY_BYTES = new byte[32];</span>

    // It's pretty weak to have this around at runtime: fix later.
<span class="fc" id="L897">    private static final byte[] pubkeyForTesting = new ECKey().getPubKey();</span>

    /**
     * Returns a solved block that builds on top of this one. This exists for unit tests.
     */
    @VisibleForTesting
    public Block createNextBlock(Address to, long version, long time, int blockHeight) {
<span class="fc" id="L904">        return createNextBlock(to, version, null, time, pubkeyForTesting, FIFTY_COINS, blockHeight);</span>
    }

    /**
     * Returns a solved block that builds on top of this one. This exists for unit tests.
     * In this variant you can specify a public key (pubkey) for use in generating coinbase blocks.
     * 
     * @param height block height, if known, or -1 otherwise.
     */
    Block createNextBlock(@Nullable final Address to, final long version,
                          @Nullable TransactionOutPoint prevOut, final long time,
                          final byte[] pubKey, final Coin coinbaseValue,
                          final int height) {
<span class="fc" id="L917">        Block b = new Block(params, version);</span>
<span class="fc" id="L918">        b.setDifficultyTarget(difficultyTarget);</span>
<span class="fc" id="L919">        b.addCoinbaseTransaction(pubKey, coinbaseValue, height);</span>

<span class="fc bfc" id="L921" title="All 2 branches covered.">        if (to != null) {</span>
            // Add a transaction paying 50 coins to the &quot;to&quot; address.
<span class="fc" id="L923">            Transaction t = new Transaction(params);</span>
<span class="fc" id="L924">            t.addOutput(new TransactionOutput(params, t, FIFTY_COINS, to));</span>
            // The input does not really need to be a valid signature, as long as it has the right general form.
            TransactionInput input;
<span class="fc bfc" id="L927" title="All 2 branches covered.">            if (prevOut == null) {</span>
<span class="fc" id="L928">                input = new TransactionInput(params, t, Script.createInputScript(EMPTY_BYTES, EMPTY_BYTES));</span>
                // Importantly the outpoint hash cannot be zero as that's how we detect a coinbase transaction in isolation
                // but it must be unique to avoid 'different' transactions looking the same.
<span class="fc" id="L931">                byte[] counter = new byte[32];</span>
<span class="fc" id="L932">                counter[0] = (byte) txCounter;</span>
<span class="fc" id="L933">                counter[1] = (byte) (txCounter++ &gt;&gt; 8);</span>
<span class="fc" id="L934">                input.getOutpoint().setHash(Sha256Hash.wrap(counter));</span>
<span class="fc" id="L935">            } else {</span>
<span class="fc" id="L936">                input = new TransactionInput(params, t, Script.createInputScript(EMPTY_BYTES, EMPTY_BYTES), prevOut);</span>
            }
<span class="fc" id="L938">            t.addInput(input);</span>
<span class="fc" id="L939">            b.addTransaction(t);</span>
        }

<span class="fc" id="L942">        b.setPrevBlockHash(getHash());</span>
        // Don't let timestamp go backwards
<span class="fc bfc" id="L944" title="All 2 branches covered.">        if (getTimeSeconds() &gt;= time)</span>
<span class="fc" id="L945">            b.setTime(getTimeSeconds() + 1);</span>
        else
<span class="fc" id="L947">            b.setTime(time);</span>
<span class="fc" id="L948">        b.solve();</span>
        try {
<span class="fc" id="L950">            b.verifyHeader();</span>
<span class="nc" id="L951">        } catch (VerificationException e) {</span>
<span class="nc" id="L952">            throw new RuntimeException(e); // Cannot happen.</span>
<span class="fc" id="L953">        }</span>
<span class="pc bpc" id="L954" title="1 of 2 branches missed.">        if (b.getVersion() != version) {</span>
<span class="nc" id="L955">            throw new RuntimeException();</span>
        }
<span class="fc" id="L957">        return b;</span>
    }

    @VisibleForTesting
    public Block createNextBlock(@Nullable Address to, TransactionOutPoint prevOut) {
<span class="fc" id="L962">        return createNextBlock(to, BLOCK_VERSION_GENESIS, prevOut, getTimeSeconds() + 5, pubkeyForTesting, FIFTY_COINS, BLOCK_HEIGHT_UNKNOWN);</span>
    }

    @VisibleForTesting
    public Block createNextBlock(@Nullable Address to, Coin value) {
<span class="fc" id="L967">        return createNextBlock(to, BLOCK_VERSION_GENESIS, null, getTimeSeconds() + 5, pubkeyForTesting, value, BLOCK_HEIGHT_UNKNOWN);</span>
    }

    @VisibleForTesting
    public Block createNextBlock(@Nullable Address to) {
<span class="fc" id="L972">        return createNextBlock(to, FIFTY_COINS);</span>
    }

    @VisibleForTesting
    public Block createNextBlockWithCoinbase(long version, byte[] pubKey, Coin coinbaseValue, final int height) {
<span class="fc" id="L977">        return createNextBlock(null, version, (TransactionOutPoint) null,</span>
<span class="fc" id="L978">                               Utils.currentTimeSeconds(), pubKey, coinbaseValue, height);</span>
    }

    /**
     * Create a block sending 50BTC as a coinbase transaction to the public key specified.
     * This method is intended for test use only.
     */
    @VisibleForTesting
    Block createNextBlockWithCoinbase(long version, byte[] pubKey, final int height) {
<span class="fc" id="L987">        return createNextBlock(null, version, (TransactionOutPoint) null,</span>
<span class="fc" id="L988">                               Utils.currentTimeSeconds(), pubKey, FIFTY_COINS, height);</span>
    }

    @VisibleForTesting
    boolean isHeaderBytesValid() {
<span class="fc" id="L993">        return headerBytesValid;</span>
    }

    @VisibleForTesting
    boolean isTransactionBytesValid() {
<span class="fc" id="L998">        return transactionBytesValid;</span>
    }

    /**
     * Return whether this block contains any transactions.
     * 
     * @return  true if the block contains transactions, false otherwise (is
     * purely a header).
     */
    public boolean hasTransactions() {
<span class="pc bpc" id="L1008" title="1 of 2 branches missed.">        return !this.transactions.isEmpty();</span>
    }

    /**
     * Returns whether this block conforms to
     * &lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki&quot;&gt;BIP34: Height in Coinbase&lt;/a&gt;.
     */
    public boolean isBIP34() {
<span class="fc bfc" id="L1016" title="All 2 branches covered.">        return version &gt;= BLOCK_VERSION_BIP34;</span>
    }

    /**
     * Returns whether this block conforms to
     * &lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki&quot;&gt;BIP66: Strict DER signatures&lt;/a&gt;.
     */
    public boolean isBIP66() {
<span class="fc bfc" id="L1024" title="All 2 branches covered.">        return version &gt;= BLOCK_VERSION_BIP66;</span>
    }

    /**
     * Returns whether this block conforms to
     * &lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki&quot;&gt;BIP65: OP_CHECKLOCKTIMEVERIFY&lt;/a&gt;.
     */
    public boolean isBIP65() {
<span class="fc bfc" id="L1032" title="All 2 branches covered.">        return version &gt;= BLOCK_VERSION_BIP65;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>