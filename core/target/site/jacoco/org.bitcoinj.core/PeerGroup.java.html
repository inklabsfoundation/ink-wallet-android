<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PeerGroup.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bitcoinj</a> &gt; <a href="index.source.html" class="el_package">org.bitcoinj.core</a> &gt; <span class="el_source">PeerGroup.java</span></div><h1>PeerGroup.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013 Google Inc.
 * Copyright 2014 Andreas Schildbach
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bitcoinj.core;

import com.google.common.annotations.*;
import com.google.common.base.*;
import com.google.common.collect.*;
import com.google.common.net.*;
import com.google.common.primitives.*;
import com.google.common.util.concurrent.*;
import net.jcip.annotations.*;
import org.bitcoinj.core.listeners.*;
import org.bitcoinj.net.*;
import org.bitcoinj.net.discovery.*;
import org.bitcoinj.script.*;
import org.bitcoinj.utils.*;
import org.bitcoinj.utils.Threading;
import org.bitcoinj.wallet.Wallet;
import org.bitcoinj.wallet.listeners.KeyChainEventListener;
import org.bitcoinj.wallet.listeners.ScriptsChangeEventListener;
import org.bitcoinj.wallet.listeners.WalletCoinsReceivedEventListener;
import org.slf4j.*;

import javax.annotation.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.locks.*;

import okhttp3.OkHttpClient;

import static com.google.common.base.Preconditions.*;

/**
 * &lt;p&gt;Runs a set of connections to the P2P network, brings up connections to replace disconnected nodes and manages
 * the interaction between them all. Most applications will want to use one of these.&lt;/p&gt;
 * 
 * &lt;p&gt;PeerGroup tries to maintain a constant number of connections to a set of distinct peers.
 * Each peer runs a network listener in its own thread.  When a connection is lost, a new peer
 * will be tried after a delay as long as the number of connections less than the maximum.&lt;/p&gt;
 * 
 * &lt;p&gt;Connections are made to addresses from a provided list.  When that list is exhausted,
 * we start again from the head of the list.&lt;/p&gt;
 * 
 * &lt;p&gt;The PeerGroup can broadcast a transaction to the currently connected set of peers.  It can
 * also handle download of the blockchain from peers, restarting the process when peers die.&lt;/p&gt;
 *
 * &lt;p&gt;A PeerGroup won't do anything until you call the {@link PeerGroup#start()} method 
 * which will block until peer discovery is completed and some outbound connections 
 * have been initiated (it will return before handshaking is done, however). 
 * You should call {@link PeerGroup#stop()} when finished. Note that not all methods
 * of PeerGroup are safe to call from a UI thread as some may do network IO, 
 * but starting and stopping the service should be fine.&lt;/p&gt;
 */
public class PeerGroup implements TransactionBroadcaster {
<span class="fc" id="L72">    private static final Logger log = LoggerFactory.getLogger(PeerGroup.class);</span>

    // All members in this class should be marked with final, volatile, @GuardedBy or a mix as appropriate to define
    // their thread safety semantics. Volatile requires a Hungarian-style v prefix.

    // By default we don't require any services because any peer will do.
<span class="fc" id="L78">    private long requiredServices = 0;</span>
    /**
     * The default number of connections to the p2p network the library will try to build. This is set to 12 empirically.
     * It used to be 4, but because we divide the connection pool in two for broadcasting transactions, that meant we
     * were only sending transactions to two peers and sometimes this wasn't reliable enough: transactions wouldn't
     * get through.
     */
    public static final int DEFAULT_CONNECTIONS = 12;
<span class="fc" id="L86">    private volatile int vMaxPeersToDiscoverCount = 100;</span>
    private static final long DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS = 5000;
<span class="fc" id="L88">    private volatile long vPeerDiscoveryTimeoutMillis = DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS;</span>

<span class="fc" id="L90">    protected final ReentrantLock lock = Threading.lock(&quot;peergroup&quot;);</span>

    protected final NetworkParameters params;
    @Nullable protected final AbstractBlockChain chain;

    // This executor is used to queue up jobs: it's used when we don't want to use locks for mutual exclusion,
    // typically because the job might call in to user provided code that needs/wants the freedom to use the API
    // however it wants, or because a job needs to be ordered relative to other jobs like that.
    protected final ListeningScheduledExecutorService executor;

    // Whether the peer group is currently running. Once shut down it cannot be restarted.
    private volatile boolean vRunning;
    // Whether the peer group has been started or not. An unstarted PG does not try to access the network.
    private volatile boolean vUsedUp;

    // Addresses to try to connect to, excluding active peers.
    @GuardedBy(&quot;lock&quot;) private final PriorityQueue&lt;PeerAddress&gt; inactives;
    @GuardedBy(&quot;lock&quot;) private final Map&lt;PeerAddress, ExponentialBackoff&gt; backoffMap;

    // Currently active peers. This is an ordered list rather than a set to make unit tests predictable.
    private final CopyOnWriteArrayList&lt;Peer&gt; peers;
    // Currently connecting peers.
    private final CopyOnWriteArrayList&lt;Peer&gt; pendingPeers;
    private final ClientConnectionManager channels;

    // The peer that has been selected for the purposes of downloading announced data.
    @GuardedBy(&quot;lock&quot;) private Peer downloadPeer;
    // Callback for events related to chain download.
    @Nullable @GuardedBy(&quot;lock&quot;) private PeerDataEventListener downloadListener;
<span class="fc" id="L119">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;BlocksDownloadedEventListener&gt;&gt; peersBlocksDownloadedEventListeners</span>
        = new CopyOnWriteArrayList&lt;&gt;();
<span class="fc" id="L121">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;ChainDownloadStartedEventListener&gt;&gt; peersChainDownloadStartedEventListeners</span>
        = new CopyOnWriteArrayList&lt;&gt;();
    /** Callbacks for events related to peers connecting */
<span class="fc" id="L124">    protected final CopyOnWriteArrayList&lt;ListenerRegistration&lt;PeerConnectedEventListener&gt;&gt; peerConnectedEventListeners</span>
        = new CopyOnWriteArrayList&lt;&gt;();
    /** Callbacks for events related to peer connection/disconnection */
<span class="fc" id="L127">    protected final CopyOnWriteArrayList&lt;ListenerRegistration&lt;PeerDiscoveredEventListener&gt;&gt; peerDiscoveredEventListeners</span>
        = new CopyOnWriteArrayList&lt;&gt;();
    /** Callbacks for events related to peers disconnecting */
<span class="fc" id="L130">    protected final CopyOnWriteArrayList&lt;ListenerRegistration&lt;PeerDisconnectedEventListener&gt;&gt; peerDisconnectedEventListeners</span>
        = new CopyOnWriteArrayList&lt;&gt;();
    /** Callbacks for events related to peer data being received */
<span class="fc" id="L133">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;GetDataEventListener&gt;&gt; peerGetDataEventListeners</span>
        = new CopyOnWriteArrayList&lt;&gt;();
<span class="fc" id="L135">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;PreMessageReceivedEventListener&gt;&gt; peersPreMessageReceivedEventListeners</span>
        = new CopyOnWriteArrayList&lt;&gt;();
<span class="fc" id="L137">    protected final CopyOnWriteArrayList&lt;ListenerRegistration&lt;OnTransactionBroadcastListener&gt;&gt; peersTransactionBroadastEventListeners</span>
        = new CopyOnWriteArrayList&lt;&gt;();
    // Peer discovery sources, will be polled occasionally if there aren't enough inactives.
    private final CopyOnWriteArraySet&lt;PeerDiscovery&gt; peerDiscoverers;
    // The version message to use for new connections.
    @GuardedBy(&quot;lock&quot;) private VersionMessage versionMessage;
    // Maximum depth up to which pending transaction dependencies are downloaded, or 0 for disabled.
    @GuardedBy(&quot;lock&quot;) private int downloadTxDependencyDepth;
    // How many connections we want to have open at the current time. If we lose connections, we'll try opening more
    // until we reach this count.
    @GuardedBy(&quot;lock&quot;) private int maxConnections;
    // Minimum protocol version we will allow ourselves to connect to: require Bloom filtering.
    private volatile int vMinRequiredProtocolVersion;

    /** How many milliseconds to wait after receiving a pong before sending another ping. */
    public static final long DEFAULT_PING_INTERVAL_MSEC = 2000;
<span class="fc" id="L153">    @GuardedBy(&quot;lock&quot;) private long pingIntervalMsec = DEFAULT_PING_INTERVAL_MSEC;</span>

<span class="fc" id="L155">    @GuardedBy(&quot;lock&quot;) private boolean useLocalhostPeerWhenPossible = true;</span>
<span class="fc" id="L156">    @GuardedBy(&quot;lock&quot;) private boolean ipv6Unreachable = false;</span>

    @GuardedBy(&quot;lock&quot;) private long fastCatchupTimeSecs;
    private final CopyOnWriteArrayList&lt;Wallet&gt; wallets;
    private final CopyOnWriteArrayList&lt;PeerFilterProvider&gt; peerFilterProviders;

    // This event listener is added to every peer. It's here so when we announce transactions via an &quot;inv&quot;, every
    // peer can fetch them.
<span class="fc" id="L164">    private final PeerListener peerListener = new PeerListener();</span>

<span class="fc" id="L166">    private int minBroadcastConnections = 0;</span>
<span class="fc" id="L167">    private final ScriptsChangeEventListener walletScriptEventListener = new ScriptsChangeEventListener() {</span>
        @Override public void onScriptsChanged(Wallet wallet, List&lt;Script&gt; scripts, boolean isAddingScripts) {
<span class="nc" id="L169">            recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);</span>
<span class="nc" id="L170">        }</span>
    };

<span class="fc" id="L173">    private final KeyChainEventListener walletKeyEventListener = new KeyChainEventListener() {</span>
        @Override public void onKeysAdded(List&lt;ECKey&gt; keys) {
<span class="fc" id="L175">            recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);</span>
<span class="fc" id="L176">        }</span>
    };

<span class="fc" id="L179">    private final WalletCoinsReceivedEventListener walletCoinsReceivedEventListener = new WalletCoinsReceivedEventListener() {</span>
        @Override
        public void onCoinsReceived(Wallet wallet, Transaction tx, Coin prevBalance, Coin newBalance) {
            // We received a relevant transaction. We MAY need to recalculate and resend the Bloom filter, but only
            // if we have received a transaction that includes a relevant pay-to-pubkey output.
            //
            // The reason is that pay-to-pubkey outputs, when spent, will not repeat any data we can predict in their
            // inputs. So a remote peer will update the Bloom filter for us when such an output is seen matching the
            // existing filter, so that it includes the tx hash in which the pay-to-pubkey output was observed. Thus
            // the spending transaction will always match (due to the outpoint structure).
            //
            // Unfortunately, whilst this is required for correct sync of the chain in blocks, there are two edge cases.
            //
            // (1) If a wallet receives a relevant, confirmed p2pubkey output that was not broadcast across the network,
            // for example in a coinbase transaction, then the node that's serving us the chain will update its filter
            // but the rest will not. If another transaction then spends it, the other nodes won't match/relay it.
            //
            // (2) If we receive a p2pubkey output broadcast across the network, all currently connected nodes will see
            // it and update their filter themselves, but any newly connected nodes will receive the last filter we
            // calculated, which would not include this transaction.
            //
            // For this reason we check if the transaction contained any relevant pay to pubkeys and force a recalc
            // and possibly retransmit if so. The recalculation process will end up including the tx hash into the
            // filter. In case (1), we need to retransmit the filter to the connected peers. In case (2), we don't
            // and shouldn't, we should just recalculate and cache the new filter for next time.
<span class="fc bfc" id="L204" title="All 2 branches covered.">            for (TransactionOutput output : tx.getOutputs()) {</span>
<span class="pc bpc" id="L205" title="1 of 4 branches missed.">                if (output.getScriptPubKey().isSentToRawPubKey() &amp;&amp; output.isMine(wallet)) {</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">                    if (tx.getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.BUILDING)</span>
<span class="nc" id="L207">                        recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);</span>
                    else
<span class="fc" id="L209">                        recalculateFastCatchupAndFilter(FilterRecalculateMode.DONT_SEND);</span>
<span class="fc" id="L210">                    return;</span>
                }
<span class="fc" id="L212">            }</span>
<span class="fc" id="L213">        }</span>
    };

    // Exponential backoff for peers starts at 1 second and maxes at 10 minutes.
<span class="fc" id="L217">    private final ExponentialBackoff.Params peerBackoffParams = new ExponentialBackoff.Params(1000, 1.5f, 10 * 60 * 1000);</span>
    // Tracks failures globally in case of a network failure.
<span class="fc" id="L219">    @GuardedBy(&quot;lock&quot;) private ExponentialBackoff groupBackoff = new ExponentialBackoff(new ExponentialBackoff.Params(1000, 1.5f, 10 * 1000));</span>

    // This is a synchronized set, so it locks on itself. We use it to prevent TransactionBroadcast objects from
    // being garbage collected if nothing in the apps code holds on to them transitively. See the discussion
    // in broadcastTransaction.
    private final Set&lt;TransactionBroadcast&gt; runningBroadcasts;

    private class PeerListener implements GetDataEventListener, BlocksDownloadedEventListener {

<span class="fc" id="L228">        public PeerListener() {</span>
<span class="fc" id="L229">        }</span>

        @Override
        public List&lt;Message&gt; getData(Peer peer, GetDataMessage m) {
<span class="nc" id="L233">            return handleGetData(m);</span>
        }

        @Override
        public void onBlocksDownloaded(Peer peer, Block block, @Nullable FilteredBlock filteredBlock, int blocksLeft) {
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">            if (chain == null) return;</span>
<span class="fc" id="L239">            final double rate = chain.getFalsePositiveRate();</span>
<span class="fc" id="L240">            final double target = bloomFilterMerger.getBloomFilterFPRate() * MAX_FP_RATE_INCREASE;</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">            if (rate &gt; target) {</span>
                // TODO: Avoid hitting this path if the remote peer didn't acknowledge applying a new filter yet.
<span class="nc bnc" id="L243" title="All 2 branches missed.">                if (log.isDebugEnabled())</span>
<span class="nc" id="L244">                    log.debug(&quot;Force update Bloom filter due to high false positive rate ({} vs {})&quot;, rate, target);</span>
<span class="nc" id="L245">                recalculateFastCatchupAndFilter(FilterRecalculateMode.FORCE_SEND_FOR_REFRESH);</span>
            }
<span class="fc" id="L247">        }</span>
    }

<span class="fc" id="L250">    private class PeerStartupListener implements PeerConnectedEventListener, PeerDisconnectedEventListener {</span>
        @Override
        public void onPeerConnected(Peer peer, int peerCount) {
<span class="fc" id="L253">            handleNewPeer(peer);</span>
<span class="fc" id="L254">        }</span>

        @Override
        public void onPeerDisconnected(Peer peer, int peerCount) {
            // The channel will be automatically removed from channels.
<span class="fc" id="L259">            handlePeerDeath(peer, null);</span>
<span class="fc" id="L260">        }</span>
    }

<span class="fc" id="L263">    private final PeerStartupListener startupListener = new PeerStartupListener();</span>

    /**
     * The default Bloom filter false positive rate, which is selected to be extremely low such that you hardly ever
     * download false positives. This provides maximum performance. Although this default can be overridden to push
     * the FP rate higher, due to &lt;a href=&quot;https://groups.google.com/forum/#!msg/bitcoinj/Ys13qkTwcNg/9qxnhwnkeoIJ&quot;&gt;
     * various complexities&lt;/a&gt; there are still ways a remote peer can deanonymize the users wallet. This is why the
     * FP rate is chosen for performance rather than privacy. If a future version of bitcoinj fixes the known
     * de-anonymization attacks this FP rate may rise again (or more likely, become expressed as a bandwidth allowance).
     */
    public static final double DEFAULT_BLOOM_FILTER_FP_RATE = 0.00001;
    /** Maximum increase in FP rate before forced refresh of the bloom filter */
    public static final double MAX_FP_RATE_INCREASE = 10.0f;
    // An object that calculates bloom filters given a list of filter providers, whilst tracking some state useful
    // for privacy purposes.
    private final FilterMerger bloomFilterMerger;

    /** The default timeout between when a connection attempt begins and version message exchange completes */
    public static final int DEFAULT_CONNECT_TIMEOUT_MILLIS = 5000;
<span class="fc" id="L282">    private volatile int vConnectTimeoutMillis = DEFAULT_CONNECT_TIMEOUT_MILLIS;</span>
    
    /** Whether bloom filter support is enabled when using a non FullPrunedBlockchain*/
<span class="fc" id="L285">    private volatile boolean vBloomFilteringEnabled = true;</span>

    /** See {@link #PeerGroup(Context)} */
    public PeerGroup(NetworkParameters params) {
<span class="nc" id="L289">        this(params, null);</span>
<span class="nc" id="L290">    }</span>

    /**
     * Creates a PeerGroup with the given context. No chain is provided so this node will report its chain height
     * as zero to other peers. This constructor is useful if you just want to explore the network but aren't interested
     * in downloading block data.
     */
    public PeerGroup(Context context) {
<span class="nc" id="L298">        this(context, null);</span>
<span class="nc" id="L299">    }</span>

    /** See {@link #PeerGroup(Context, AbstractBlockChain)} */
    public PeerGroup(NetworkParameters params, @Nullable AbstractBlockChain chain) {
<span class="nc" id="L303">        this(Context.getOrCreate(params), chain, new NioClientManager());</span>
<span class="nc" id="L304">    }</span>

    /**
     * Creates a PeerGroup for the given context and chain. Blocks will be passed to the chain as they are broadcast
     * and downloaded. This is probably the constructor you want to use.
     */
    public PeerGroup(Context context, @Nullable AbstractBlockChain chain) {
<span class="nc" id="L311">        this(context, chain, new NioClientManager());</span>
<span class="nc" id="L312">    }</span>

    /** See {@link #PeerGroup(Context, AbstractBlockChain, ClientConnectionManager)} */
    public PeerGroup(NetworkParameters params, @Nullable AbstractBlockChain chain, ClientConnectionManager connectionManager) {
<span class="fc" id="L316">        this(Context.getOrCreate(params), chain, connectionManager);</span>
<span class="fc" id="L317">    }</span>

    /**
     * Creates a new PeerGroup allowing you to specify the {@link ClientConnectionManager} which is used to create new
     * connections and keep track of existing ones.
     */
<span class="fc" id="L323">    private PeerGroup(Context context, @Nullable AbstractBlockChain chain, ClientConnectionManager connectionManager) {</span>
<span class="fc" id="L324">        checkNotNull(context);</span>
<span class="fc" id="L325">        this.params = context.getParams();</span>
<span class="fc" id="L326">        this.chain = chain;</span>
<span class="fc" id="L327">        fastCatchupTimeSecs = params.getGenesisBlock().getTimeSeconds();</span>
<span class="fc" id="L328">        wallets = new CopyOnWriteArrayList&lt;&gt;();</span>
<span class="fc" id="L329">        peerFilterProviders = new CopyOnWriteArrayList&lt;&gt;();</span>

<span class="fc" id="L331">        executor = createPrivateExecutor();</span>

        // This default sentinel value will be overridden by one of two actions:
        //   - adding a peer discovery source sets it to the default
        //   - using connectTo() will increment it by one
<span class="fc" id="L336">        maxConnections = 0;</span>

<span class="pc bpc" id="L338" title="1 of 2 branches missed.">        int height = chain == null ? 0 : chain.getBestChainHeight();</span>
<span class="fc" id="L339">        versionMessage = new VersionMessage(params, height);</span>
        // We never request that the remote node wait for a bloom filter yet, as we have no wallets
<span class="fc" id="L341">        versionMessage.relayTxesBeforeFilter = true;</span>

<span class="fc" id="L343">        downloadTxDependencyDepth = Integer.MAX_VALUE;</span>

<span class="fc" id="L345">        inactives = new PriorityQueue&lt;&gt;(1, new Comparator&lt;PeerAddress&gt;() {</span>
            @SuppressWarnings(&quot;FieldAccessNotGuarded&quot;)   // only called when inactives is accessed, and lock is held then.
            @Override
            public int compare(PeerAddress a, PeerAddress b) {
<span class="fc" id="L349">                checkState(lock.isHeldByCurrentThread());</span>
<span class="fc" id="L350">                int result = backoffMap.get(a).compareTo(backoffMap.get(b));</span>
                // Sort by port if otherwise equals - for testing
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">                if (result == 0)</span>
<span class="fc" id="L353">                    result = Ints.compare(a.getPort(), b.getPort());</span>
<span class="fc" id="L354">                return result;</span>
            }
        });
<span class="fc" id="L357">        backoffMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L358">        peers = new CopyOnWriteArrayList&lt;&gt;();</span>
<span class="fc" id="L359">        pendingPeers = new CopyOnWriteArrayList&lt;&gt;();</span>
<span class="fc" id="L360">        channels = connectionManager;</span>
<span class="fc" id="L361">        peerDiscoverers = new CopyOnWriteArraySet&lt;&gt;();</span>
<span class="fc" id="L362">        runningBroadcasts = Collections.synchronizedSet(new HashSet&lt;TransactionBroadcast&gt;());</span>
<span class="fc" id="L363">        bloomFilterMerger = new FilterMerger(DEFAULT_BLOOM_FILTER_FP_RATE);</span>
<span class="fc" id="L364">        vMinRequiredProtocolVersion = params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.BLOOM_FILTER);</span>
<span class="fc" id="L365">    }</span>

<span class="fc" id="L367">    private CountDownLatch executorStartupLatch = new CountDownLatch(1);</span>

    protected ListeningScheduledExecutorService createPrivateExecutor() {
<span class="nc" id="L370">        ListeningScheduledExecutorService result = MoreExecutors.listeningDecorator(</span>
                new ScheduledThreadPoolExecutor(1, new ContextPropagatingThreadFactory(&quot;PeerGroup Thread&quot;))
        );
        // Hack: jam the executor so jobs just queue up until the user calls start() on us. For example, adding a wallet
        // results in a bloom filter recalc being queued, but we don't want to do that until we're actually started.
<span class="nc" id="L375">        result.execute(new Runnable() {</span>
            @Override
            public void run() {
<span class="nc" id="L378">                Uninterruptibles.awaitUninterruptibly(executorStartupLatch);</span>
<span class="nc" id="L379">            }</span>
        });
<span class="nc" id="L381">        return result;</span>
    }

    /**
     * This is how many milliseconds we wait for peer discoveries to return their results.
     */
    public void setPeerDiscoveryTimeoutMillis(long peerDiscoveryTimeoutMillis) {
<span class="nc" id="L388">        this.vPeerDiscoveryTimeoutMillis = peerDiscoveryTimeoutMillis;</span>
<span class="nc" id="L389">    }</span>

    /**
     * Adjusts the desired number of connections that we will create to peers. Note that if there are already peers
     * open and the new value is lower than the current number of peers, those connections will be terminated. Likewise
     * if there aren't enough current connections to meet the new requested max size, some will be added.
     */
    public void setMaxConnections(int maxConnections) {
        int adjustment;
<span class="fc" id="L398">        lock.lock();</span>
        try {
<span class="fc" id="L400">            this.maxConnections = maxConnections;</span>
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">            if (!isRunning()) return;</span>
        } finally {
<span class="pc" id="L403">            lock.unlock();</span>
<span class="nc" id="L404">        }</span>
        // We may now have too many or too few open connections. Add more or drop some to get to the right amount.
<span class="nc" id="L406">        adjustment = maxConnections - channels.getConnectedClientCount();</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (adjustment &gt; 0)</span>
<span class="nc" id="L408">            triggerConnections();</span>

<span class="nc bnc" id="L410" title="All 2 branches missed.">        if (adjustment &lt; 0)</span>
<span class="nc" id="L411">            channels.closeConnections(-adjustment);</span>
<span class="nc" id="L412">    }</span>

    /**
     * Configure download of pending transaction dependencies. A change of values only takes effect for newly connected
     * peers.
     */
    public void setDownloadTxDependencies(int depth) {
<span class="nc" id="L419">        lock.lock();</span>
        try {
<span class="nc" id="L421">            this.downloadTxDependencyDepth = depth;</span>
        } finally {
<span class="nc" id="L423">            lock.unlock();</span>
<span class="nc" id="L424">        }</span>
<span class="nc" id="L425">    }</span>

<span class="fc" id="L427">    private Runnable triggerConnectionsJob = new Runnable() {</span>
<span class="fc" id="L428">        private boolean firstRun = true;</span>
        private final static long MIN_PEER_DISCOVERY_INTERVAL = 1000L;

        @Override
        public void run() {
            try {
<span class="fc" id="L434">                go();</span>
<span class="fc" id="L435">            } catch (Throwable e) {</span>
<span class="fc" id="L436">                log.error(&quot;Exception when trying to build connections&quot;, e);  // The executor swallows exceptions :(</span>
<span class="fc" id="L437">            }</span>
<span class="fc" id="L438">        }</span>

        public void go() {
<span class="fc bfc" id="L441" title="All 2 branches covered.">            if (!vRunning) return;</span>

<span class="fc" id="L443">            boolean doDiscovery = false;</span>
<span class="fc" id="L444">            long now = Utils.currentTimeMillis();</span>
<span class="fc" id="L445">            lock.lock();</span>
            try {
                // First run: try and use a local node if there is one, for the additional security it can provide.
                // But, not on Android as there are none for this platform: it could only be a malicious app trying
                // to hijack our traffic.
<span class="pc bpc" id="L450" title="3 of 8 branches missed.">                if (!Utils.isAndroidRuntime() &amp;&amp; useLocalhostPeerWhenPossible &amp;&amp; maybeCheckForLocalhostPeer() &amp;&amp; firstRun) {</span>
<span class="fc" id="L451">                    log.info(&quot;Localhost peer detected, trying to use it instead of P2P discovery&quot;);</span>
<span class="fc" id="L452">                    maxConnections = 0;</span>
<span class="fc" id="L453">                    connectToLocalHost();</span>
<span class="fc" id="L454">                    return;</span>
                }

<span class="pc bpc" id="L457" title="1 of 4 branches missed.">                boolean havePeerWeCanTry = !inactives.isEmpty() &amp;&amp; backoffMap.get(inactives.peek()).getRetryTime() &lt;= now;</span>
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">                doDiscovery = !havePeerWeCanTry;</span>
            } finally {
<span class="pc" id="L460">                firstRun = false;</span>
<span class="pc" id="L461">                lock.unlock();</span>
<span class="fc" id="L462">            }</span>

            // Don't hold the lock across discovery as this process can be very slow.
<span class="fc" id="L465">            boolean discoverySuccess = false;</span>
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">            if (doDiscovery) {</span>
                try {
<span class="fc bfc" id="L468" title="All 2 branches covered.">                    discoverySuccess = discoverPeers() &gt; 0;</span>
<span class="fc" id="L469">                } catch (PeerDiscoveryException e) {</span>
<span class="fc" id="L470">                    log.error(&quot;Peer discovery failure&quot;, e);</span>
<span class="fc" id="L471">                }</span>
            }

            long retryTime;
            PeerAddress addrToTry;
<span class="fc" id="L476">            lock.lock();</span>
            try {
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">                if (doDiscovery) {</span>
                    // Require that we have enough connections, to consider this
                    // a success, or we just constantly test for new peers
<span class="pc bpc" id="L481" title="1 of 4 branches missed.">                    if (discoverySuccess &amp;&amp; countConnectedAndPendingPeers() &gt;= getMaxConnections()) {</span>
<span class="nc" id="L482">                        groupBackoff.trackSuccess();</span>
                    } else {
<span class="fc" id="L484">                        groupBackoff.trackFailure();</span>
                    }
                }
                // Inactives is sorted by backoffMap time.
<span class="fc bfc" id="L488" title="All 2 branches covered.">                if (inactives.isEmpty()) {</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">                    if (countConnectedAndPendingPeers() &lt; getMaxConnections()) {</span>
<span class="fc" id="L490">                        long interval = Math.max(groupBackoff.getRetryTime() - now, MIN_PEER_DISCOVERY_INTERVAL);</span>
<span class="fc" id="L491">                        log.info(&quot;Peer discovery didn't provide us any more peers, will try again in &quot;</span>
                            + interval + &quot;ms.&quot;);
<span class="fc" id="L493">                        executor.schedule(this, interval, TimeUnit.MILLISECONDS);</span>
                    } else {
                        // We have enough peers and discovery provided no more, so just settle down. Most likely we
                        // were given a fixed set of addresses in some test scenario.
                    }
<span class="fc" id="L498">                    return;</span>
                } else {
                    do {
<span class="fc" id="L501">                        addrToTry = inactives.poll();</span>
<span class="pc bpc" id="L502" title="3 of 4 branches missed.">                    } while (ipv6Unreachable &amp;&amp; addrToTry.getAddr() instanceof Inet6Address);</span>
<span class="fc" id="L503">                    retryTime = backoffMap.get(addrToTry).getRetryTime();</span>
                }
<span class="fc" id="L505">                retryTime = Math.max(retryTime, groupBackoff.getRetryTime());</span>
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">                if (retryTime &gt; now) {</span>
<span class="fc" id="L507">                    long delay = retryTime - now;</span>
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">                    log.info(&quot;Waiting {} msec before next connect attempt {}&quot;, delay, addrToTry == null ? &quot;&quot; : &quot;to &quot; + addrToTry);</span>
<span class="fc" id="L509">                    inactives.add(addrToTry);</span>
<span class="fc" id="L510">                    executor.schedule(this, delay, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L511">                    return;</span>
                }
<span class="nc" id="L513">                connectTo(addrToTry, false, vConnectTimeoutMillis);</span>
            } finally {
<span class="pc" id="L515">                lock.unlock();</span>
<span class="nc" id="L516">            }</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">            if (countConnectedAndPendingPeers() &lt; getMaxConnections()) {</span>
<span class="nc" id="L518">                executor.execute(this);   // Try next peer immediately.</span>
            }
<span class="nc" id="L520">        }</span>
    };

    private void triggerConnections() {
        // Run on a background thread due to the need to potentially retry and back off in the background.
<span class="fc bfc" id="L525" title="All 2 branches covered.">        if (!executor.isShutdown())</span>
<span class="fc" id="L526">            executor.execute(triggerConnectionsJob);</span>
<span class="fc" id="L527">    }</span>

    /** The maximum number of connections that we will create to peers. */
    public int getMaxConnections() {
<span class="fc" id="L531">        lock.lock();</span>
        try {
<span class="fc" id="L533">            return maxConnections;</span>
        } finally {
<span class="pc" id="L535">            lock.unlock();</span>
        }
    }

    private List&lt;Message&gt; handleGetData(GetDataMessage m) {
        // Scans the wallets and memory pool for transactions in the getdata message and returns them.
        // Runs on peer threads.
<span class="nc" id="L542">        lock.lock();</span>
        try {
<span class="nc" id="L544">            LinkedList&lt;Message&gt; transactions = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L545">            LinkedList&lt;InventoryItem&gt; items = new LinkedList&lt;&gt;(m.getItems());</span>
<span class="nc" id="L546">            Iterator&lt;InventoryItem&gt; it = items.iterator();</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">            while (it.hasNext()) {</span>
<span class="nc" id="L548">                InventoryItem item = it.next();</span>
                // Check the wallets.
<span class="nc bnc" id="L550" title="All 2 branches missed.">                for (Wallet w : wallets) {</span>
<span class="nc" id="L551">                    Transaction tx = w.getTransaction(item.hash);</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">                    if (tx == null) continue;</span>
<span class="nc" id="L553">                    transactions.add(tx);</span>
<span class="nc" id="L554">                    it.remove();</span>
<span class="nc" id="L555">                    break;</span>
                }
<span class="nc" id="L557">            }</span>
<span class="nc" id="L558">            return transactions;</span>
        } finally {
<span class="nc" id="L560">            lock.unlock();</span>
        }
    }

    /**
     * Sets the {@link VersionMessage} that will be announced on newly created connections. A version message is
     * primarily interesting because it lets you customize the &quot;subVer&quot; field which is used a bit like the User-Agent
     * field from HTTP. It means your client tells the other side what it is, see
     * &lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki&quot;&gt;BIP 14&lt;/a&gt;.
     *
     * The VersionMessage you provide is copied and the best chain height/time filled in for each new connection,
     * therefore you don't have to worry about setting that. The provided object is really more of a template.
     */
    public void setVersionMessage(VersionMessage ver) {
<span class="nc" id="L574">        lock.lock();</span>
        try {
<span class="nc" id="L576">            versionMessage = ver;</span>
        } finally {
<span class="nc" id="L578">            lock.unlock();</span>
<span class="nc" id="L579">        }</span>
<span class="nc" id="L580">    }</span>

    /**
     * Returns the version message provided by setVersionMessage or a default if none was given.
     */
    public VersionMessage getVersionMessage() {
<span class="fc" id="L586">        lock.lock();</span>
        try {
<span class="fc" id="L588">            return versionMessage;</span>
        } finally {
<span class="pc" id="L590">            lock.unlock();</span>
        }
    }

    /**
     * Sets information that identifies this software to remote nodes. This is a convenience wrapper for creating 
     * a new {@link VersionMessage}, calling {@link VersionMessage#appendToSubVer(String, String, String)} on it,
     * and then calling {@link PeerGroup#setVersionMessage(VersionMessage)} on the result of that. See the docs for
     * {@link VersionMessage#appendToSubVer(String, String, String)} for information on what the fields should contain.
     */
    public void setUserAgent(String name, String version, @Nullable String comments) {
        //TODO Check that height is needed here (it wasnt, but it should be, no?)
<span class="nc bnc" id="L602" title="All 2 branches missed.">        int height = chain == null ? 0 : chain.getBestChainHeight();</span>
<span class="nc" id="L603">        VersionMessage ver = new VersionMessage(params, height);</span>
<span class="nc" id="L604">        ver.relayTxesBeforeFilter = false;</span>
<span class="nc" id="L605">        updateVersionMessageRelayTxesBeforeFilter(ver);</span>
<span class="nc" id="L606">        ver.appendToSubVer(name, version, comments);</span>
<span class="nc" id="L607">        setVersionMessage(ver);</span>
<span class="nc" id="L608">    }</span>
    
    // Updates the relayTxesBeforeFilter flag of ver
    private void updateVersionMessageRelayTxesBeforeFilter(VersionMessage ver) {
        // We will provide the remote node with a bloom filter (ie they shouldn't relay yet)
        // if chain == null || !chain.shouldVerifyTransactions() and a wallet is added and bloom filters are enabled
        // Note that the default here means that no tx invs will be received if no wallet is ever added
<span class="fc" id="L615">        lock.lock();</span>
        try {
<span class="pc bpc" id="L617" title="2 of 4 branches missed.">            boolean spvMode = chain != null &amp;&amp; !chain.shouldVerifyTransactions();</span>
<span class="pc bpc" id="L618" title="3 of 6 branches missed.">            boolean willSendFilter = spvMode &amp;&amp; peerFilterProviders.size() &gt; 0 &amp;&amp; vBloomFilteringEnabled;</span>
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">            ver.relayTxesBeforeFilter = !willSendFilter;</span>
        } finally {
<span class="pc" id="L621">            lock.unlock();</span>
<span class="fc" id="L622">        }</span>
<span class="fc" id="L623">    }</span>

    /**
     * Sets information that identifies this software to remote nodes. This is a convenience wrapper for creating
     * a new {@link VersionMessage}, calling {@link VersionMessage#appendToSubVer(String, String, String)} on it,
     * and then calling {@link PeerGroup#setVersionMessage(VersionMessage)} on the result of that. See the docs for
     * {@link VersionMessage#appendToSubVer(String, String, String)} for information on what the fields should contain.
     */
    public void setUserAgent(String name, String version) {
<span class="nc" id="L632">        setUserAgent(name, version, null);</span>
<span class="nc" id="L633">    }</span>

    /** Use the more specific listener methods instead */
    @Deprecated @SuppressWarnings(&quot;deprecation&quot;)
    public void addEventListener(AbstractPeerEventListener listener, Executor executor) {
<span class="nc" id="L638">        addBlocksDownloadedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L639">        addChainDownloadStartedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L640">        addConnectedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L641">        addDisconnectedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L642">        addDiscoveredEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L643">        addGetDataEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L644">        addOnTransactionBroadcastListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L645">        addPreMessageReceivedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L646">    }</span>

    /** Use the more specific listener methods instead */
    @Deprecated @SuppressWarnings(&quot;deprecation&quot;)
    public void addEventListener(AbstractPeerEventListener listener) {
<span class="nc" id="L651">        addBlocksDownloadedEventListener(executor, listener);</span>
<span class="nc" id="L652">        addChainDownloadStartedEventListener(executor, listener);</span>
<span class="nc" id="L653">        addConnectedEventListener(executor, listener);</span>
<span class="nc" id="L654">        addDisconnectedEventListener(executor, listener);</span>
<span class="nc" id="L655">        addDiscoveredEventListener(executor, listener);</span>
<span class="nc" id="L656">        addGetDataEventListener(executor, listener);</span>
<span class="nc" id="L657">        addOnTransactionBroadcastListener(executor, listener);</span>
<span class="nc" id="L658">        addPreMessageReceivedEventListener(executor, listener);</span>
<span class="nc" id="L659">    }</span>

    /** See {@link Peer#addBlocksDownloadedEventListener(BlocksDownloadedEventListener)} */
    public void addBlocksDownloadedEventListener(BlocksDownloadedEventListener listener) {
<span class="nc" id="L663">        addBlocksDownloadedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L664">    }</span>

    /**
     * &lt;p&gt;Adds a listener that will be notified on the given executor when
     * blocks are downloaded by the download peer.&lt;/p&gt;
     * @see Peer#addBlocksDownloadedEventListener(Executor, BlocksDownloadedEventListener)
     */
    public void addBlocksDownloadedEventListener(Executor executor, BlocksDownloadedEventListener listener) {
<span class="nc" id="L672">        peersBlocksDownloadedEventListeners.add(new ListenerRegistration&lt;&gt;(checkNotNull(listener), executor));</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L674">            peer.addBlocksDownloadedEventListener(executor, listener);</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L676">            peer.addBlocksDownloadedEventListener(executor, listener);</span>
<span class="nc" id="L677">    }</span>

    /** See {@link Peer#addBlocksDownloadedEventListener(BlocksDownloadedEventListener)} */
    public void addChainDownloadStartedEventListener(ChainDownloadStartedEventListener listener) {
<span class="nc" id="L681">        addChainDownloadStartedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L682">    }</span>

    /**
     * &lt;p&gt;Adds a listener that will be notified on the given executor when
     * chain download starts.&lt;/p&gt;
     */
    public void addChainDownloadStartedEventListener(Executor executor, ChainDownloadStartedEventListener listener) {
<span class="nc" id="L689">        peersChainDownloadStartedEventListeners.add(new ListenerRegistration&lt;&gt;(checkNotNull(listener), executor));</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L691">            peer.addChainDownloadStartedEventListener(executor, listener);</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L693">            peer.addChainDownloadStartedEventListener(executor, listener);</span>
<span class="nc" id="L694">    }</span>

    /** See {@link Peer#addConnectedEventListener(PeerConnectedEventListener)} */
    public void addConnectedEventListener(PeerConnectedEventListener listener) {
<span class="fc" id="L698">        addConnectedEventListener(Threading.USER_THREAD, listener);</span>
<span class="fc" id="L699">    }</span>

    /**
     * &lt;p&gt;Adds a listener that will be notified on the given executor when
     * new peers are connected to.&lt;/p&gt;
     */
    public void addConnectedEventListener(Executor executor, PeerConnectedEventListener listener) {
<span class="fc" id="L706">        peerConnectedEventListeners.add(new ListenerRegistration&lt;&gt;(checkNotNull(listener), executor));</span>
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L708">            peer.addConnectedEventListener(executor, listener);</span>
<span class="pc bpc" id="L709" title="1 of 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L710">            peer.addConnectedEventListener(executor, listener);</span>
<span class="fc" id="L711">    }</span>

    /** See {@link Peer#addDisconnectedEventListener(PeerDisconnectedEventListener)} */
    public void addDisconnectedEventListener(PeerDisconnectedEventListener listener) {
<span class="fc" id="L715">        addDisconnectedEventListener(Threading.USER_THREAD, listener);</span>
<span class="fc" id="L716">    }</span>

    /**
     * &lt;p&gt;Adds a listener that will be notified on the given executor when
     * peers are disconnected from.&lt;/p&gt;
     */
    public void addDisconnectedEventListener(Executor executor, PeerDisconnectedEventListener listener) {
<span class="fc" id="L723">        peerDisconnectedEventListeners.add(new ListenerRegistration&lt;&gt;(checkNotNull(listener), executor));</span>
<span class="pc bpc" id="L724" title="1 of 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L725">            peer.addDisconnectedEventListener(executor, listener);</span>
<span class="pc bpc" id="L726" title="1 of 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L727">            peer.addDisconnectedEventListener(executor, listener);</span>
<span class="fc" id="L728">    }</span>

    /** See {@link PeerGroup#addDiscoveredEventListener(Executor, PeerDiscoveredEventListener)} */
    public void addDiscoveredEventListener(PeerDiscoveredEventListener listener) {
<span class="fc" id="L732">        addDiscoveredEventListener(Threading.USER_THREAD, listener);</span>
<span class="fc" id="L733">    }</span>

    /**
     * &lt;p&gt;Adds a listener that will be notified on the given executor when new
     * peers are discovered.&lt;/p&gt;
     */
    public void addDiscoveredEventListener(Executor executor, PeerDiscoveredEventListener listener) {
<span class="fc" id="L740">        peerDiscoveredEventListeners.add(new ListenerRegistration&lt;&gt;(checkNotNull(listener), executor));</span>
<span class="fc" id="L741">    }</span>

    /** See {@link Peer#addGetDataEventListener(GetDataEventListener)} */
    public void addGetDataEventListener(GetDataEventListener listener) {
<span class="nc" id="L745">        addGetDataEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L746">    }</span>

    /** See {@link Peer#addGetDataEventListener(Executor, GetDataEventListener)} */
    public void addGetDataEventListener(final Executor executor, final GetDataEventListener listener) {
<span class="nc" id="L750">        peerGetDataEventListeners.add(new ListenerRegistration&lt;&gt;(checkNotNull(listener), executor));</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L752">            peer.addGetDataEventListener(executor, listener);</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L754">            peer.addGetDataEventListener(executor, listener);</span>
<span class="nc" id="L755">    }</span>

    /** See {@link Peer#addOnTransactionBroadcastListener(OnTransactionBroadcastListener)} */
    public void addOnTransactionBroadcastListener(OnTransactionBroadcastListener listener) {
<span class="nc" id="L759">        addOnTransactionBroadcastListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L760">    }</span>

    /** See {@link Peer#addOnTransactionBroadcastListener(OnTransactionBroadcastListener)} */
    public void addOnTransactionBroadcastListener(Executor executor, OnTransactionBroadcastListener listener) {
<span class="fc" id="L764">        peersTransactionBroadastEventListeners.add(new ListenerRegistration&lt;&gt;(checkNotNull(listener), executor));</span>
<span class="pc bpc" id="L765" title="1 of 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L766">            peer.addOnTransactionBroadcastListener(executor, listener);</span>
<span class="pc bpc" id="L767" title="1 of 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L768">            peer.addOnTransactionBroadcastListener(executor, listener);</span>
<span class="fc" id="L769">    }</span>

    /** See {@link Peer#addPreMessageReceivedEventListener(PreMessageReceivedEventListener)} */
    public void addPreMessageReceivedEventListener(PreMessageReceivedEventListener listener) {
<span class="fc" id="L773">        addPreMessageReceivedEventListener(Threading.USER_THREAD, listener);</span>
<span class="fc" id="L774">    }</span>

    /** See {@link Peer#addPreMessageReceivedEventListener(Executor, PreMessageReceivedEventListener)} */
    public void addPreMessageReceivedEventListener(Executor executor, PreMessageReceivedEventListener listener) {
<span class="fc" id="L778">        peersPreMessageReceivedEventListeners.add(new ListenerRegistration&lt;&gt;(checkNotNull(listener), executor));</span>
<span class="fc bfc" id="L779" title="All 2 branches covered.">        for (Peer peer : getConnectedPeers())</span>
<span class="fc" id="L780">            peer.addPreMessageReceivedEventListener(executor, listener);</span>
<span class="pc bpc" id="L781" title="1 of 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L782">            peer.addPreMessageReceivedEventListener(executor, listener);</span>
<span class="fc" id="L783">    }</span>

    /** Use the more specific listener methods instead */
    @Deprecated @SuppressWarnings(&quot;deprecation&quot;)
    public void removeEventListener(AbstractPeerEventListener listener) {
<span class="nc" id="L788">        removeBlocksDownloadedEventListener(listener);</span>
<span class="nc" id="L789">        removeChainDownloadStartedEventListener(listener);</span>
<span class="nc" id="L790">        removeConnectedEventListener(listener);</span>
<span class="nc" id="L791">        removeDisconnectedEventListener(listener);</span>
<span class="nc" id="L792">        removeDiscoveredEventListener(listener);</span>
<span class="nc" id="L793">        removeGetDataEventListener(listener);</span>
<span class="nc" id="L794">        removeOnTransactionBroadcastListener(listener);</span>
<span class="nc" id="L795">        removePreMessageReceivedEventListener(listener);</span>
<span class="nc" id="L796">    }</span>

    public boolean removeBlocksDownloadedEventListener(BlocksDownloadedEventListener listener) {
<span class="nc" id="L799">        boolean result = ListenerRegistration.removeFromList(listener, peersBlocksDownloadedEventListeners);</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L801">            peer.removeBlocksDownloadedEventListener(listener);</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L803">            peer.removeBlocksDownloadedEventListener(listener);</span>
<span class="nc" id="L804">        return result;</span>
    }

    public boolean removeChainDownloadStartedEventListener(ChainDownloadStartedEventListener listener) {
<span class="nc" id="L808">        boolean result = ListenerRegistration.removeFromList(listener, peersChainDownloadStartedEventListeners);</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L810">            peer.removeChainDownloadStartedEventListener(listener);</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L812">            peer.removeChainDownloadStartedEventListener(listener);</span>
<span class="nc" id="L813">        return result;</span>
    }

    /** The given event listener will no longer be called with events. */
    public boolean removeConnectedEventListener(PeerConnectedEventListener listener) {
<span class="fc" id="L818">        boolean result = ListenerRegistration.removeFromList(listener, peerConnectedEventListeners);</span>
<span class="fc bfc" id="L819" title="All 2 branches covered.">        for (Peer peer : getConnectedPeers())</span>
<span class="fc" id="L820">            peer.removeConnectedEventListener(listener);</span>
<span class="pc bpc" id="L821" title="1 of 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L822">            peer.removeConnectedEventListener(listener);</span>
<span class="fc" id="L823">        return result;</span>
    }

    /** The given event listener will no longer be called with events. */
    public boolean removeDisconnectedEventListener(PeerDisconnectedEventListener listener) {
<span class="fc" id="L828">        boolean result = ListenerRegistration.removeFromList(listener, peerDisconnectedEventListeners);</span>
<span class="pc bpc" id="L829" title="1 of 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L830">            peer.removeDisconnectedEventListener(listener);</span>
<span class="pc bpc" id="L831" title="1 of 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L832">            peer.removeDisconnectedEventListener(listener);</span>
<span class="fc" id="L833">        return result;</span>
    }

    /** The given event listener will no longer be called with events. */
    public boolean removeDiscoveredEventListener(PeerDiscoveredEventListener listener) {
<span class="nc" id="L838">        boolean result = ListenerRegistration.removeFromList(listener, peerDiscoveredEventListeners);</span>
<span class="nc" id="L839">        return result;</span>
    }

    /** The given event listener will no longer be called with events. */
    public boolean removeGetDataEventListener(GetDataEventListener listener) {
<span class="nc" id="L844">        boolean result = ListenerRegistration.removeFromList(listener, peerGetDataEventListeners);</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L846">            peer.removeGetDataEventListener(listener);</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L848">            peer.removeGetDataEventListener(listener);</span>
<span class="nc" id="L849">        return result;</span>
    }

    /** The given event listener will no longer be called with events. */
    public boolean removeOnTransactionBroadcastListener(OnTransactionBroadcastListener listener) {
<span class="nc" id="L854">        boolean result = ListenerRegistration.removeFromList(listener, peersTransactionBroadastEventListeners);</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L856">            peer.removeOnTransactionBroadcastListener(listener);</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L858">            peer.removeOnTransactionBroadcastListener(listener);</span>
<span class="nc" id="L859">        return result;</span>
    }

    public boolean removePreMessageReceivedEventListener(PreMessageReceivedEventListener listener) {
<span class="fc" id="L863">        boolean result = ListenerRegistration.removeFromList(listener, peersPreMessageReceivedEventListeners);</span>
<span class="fc bfc" id="L864" title="All 2 branches covered.">        for (Peer peer : getConnectedPeers())</span>
<span class="fc" id="L865">            peer.removePreMessageReceivedEventListener(listener);</span>
<span class="pc bpc" id="L866" title="1 of 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L867">            peer.removePreMessageReceivedEventListener(listener);</span>
<span class="fc" id="L868">        return result;</span>
    }

    /**
     * Returns a newly allocated list containing the currently connected peers. If all you care about is the count,
     * use numConnectedPeers().
     */
    public List&lt;Peer&gt; getConnectedPeers() {
<span class="fc" id="L876">        lock.lock();</span>
        try {
<span class="fc" id="L878">            return new ArrayList&lt;&gt;(peers);</span>
        } finally {
<span class="pc" id="L880">            lock.unlock();</span>
        }
    }

    /**
     * Returns a list containing Peers that did not complete connection yet.
     */
    public List&lt;Peer&gt; getPendingPeers() {
<span class="fc" id="L888">        lock.lock();</span>
        try {
<span class="fc" id="L890">            return new ArrayList&lt;&gt;(pendingPeers);</span>
        } finally {
<span class="pc" id="L892">            lock.unlock();</span>
        }
    }

    /**
     * Add an address to the list of potential peers to connect to. It won't necessarily be used unless there's a need
     * to build new connections to reach the max connection count.
     *
     * @param peerAddress IP/port to use.
     */
    public void addAddress(PeerAddress peerAddress) {
        int newMax;
<span class="nc" id="L904">        lock.lock();</span>
        try {
<span class="nc" id="L906">            addInactive(peerAddress);</span>
<span class="nc" id="L907">            newMax = getMaxConnections() + 1;</span>
        } finally {
<span class="nc" id="L909">            lock.unlock();</span>
<span class="nc" id="L910">        }</span>
<span class="nc" id="L911">        setMaxConnections(newMax);</span>
<span class="nc" id="L912">    }</span>

    private void addInactive(PeerAddress peerAddress) {
<span class="fc" id="L915">        lock.lock();</span>
        try {
            // Deduplicate
<span class="pc bpc" id="L918" title="1 of 2 branches missed.">            if (backoffMap.containsKey(peerAddress))</span>
<span class="nc" id="L919">                return;</span>
<span class="fc" id="L920">            backoffMap.put(peerAddress, new ExponentialBackoff(peerBackoffParams));</span>
<span class="fc" id="L921">            inactives.offer(peerAddress);</span>
        } finally {
<span class="pc" id="L923">            lock.unlock();</span>
<span class="fc" id="L924">        }</span>
<span class="fc" id="L925">    }</span>

    /**
     * Convenience for connecting only to peers that can serve specific services. It will configure suitable peer
     * discoveries.
     * @param requiredServices Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
     */
    public void setRequiredServices(long requiredServices) {
<span class="nc" id="L933">        lock.lock();</span>
        try {
<span class="nc" id="L935">            this.requiredServices = requiredServices;</span>
<span class="nc" id="L936">            peerDiscoverers.clear();</span>
<span class="nc" id="L937">            addPeerDiscovery(MultiplexingDiscovery.forServices(params, requiredServices));</span>
        } finally {
<span class="nc" id="L939">            lock.unlock();</span>
<span class="nc" id="L940">        }</span>
<span class="nc" id="L941">    }</span>

    /** Convenience method for addAddress(new PeerAddress(address, params.port)); */
    public void addAddress(InetAddress address) {
<span class="nc" id="L945">        addAddress(new PeerAddress(params, address, params.getPort()));</span>
<span class="nc" id="L946">    }</span>

    /**
     * Add addresses from a discovery source to the list of potential peers to connect to. If max connections has not
     * been configured, or set to zero, then it's set to the default at this point.
     */
    public void addPeerDiscovery(PeerDiscovery peerDiscovery) {
<span class="fc" id="L953">        lock.lock();</span>
        try {
<span class="fc bfc" id="L955" title="All 2 branches covered.">            if (getMaxConnections() == 0)</span>
<span class="fc" id="L956">                setMaxConnections(DEFAULT_CONNECTIONS);</span>
<span class="fc" id="L957">            peerDiscoverers.add(peerDiscovery);</span>
        } finally {
<span class="pc" id="L959">            lock.unlock();</span>
<span class="fc" id="L960">        }</span>
<span class="fc" id="L961">    }</span>

    /** Returns number of discovered peers. */
    protected int discoverPeers() throws PeerDiscoveryException {
        // Don't hold the lock whilst doing peer discovery: it can take a long time and cause high API latency.
<span class="pc bpc" id="L966" title="1 of 2 branches missed.">        checkState(!lock.isHeldByCurrentThread());</span>
<span class="fc" id="L967">        int maxPeersToDiscoverCount = this.vMaxPeersToDiscoverCount;</span>
<span class="fc" id="L968">        long peerDiscoveryTimeoutMillis = this.vPeerDiscoveryTimeoutMillis;</span>
<span class="fc" id="L969">        final Stopwatch watch = Stopwatch.createStarted();</span>
<span class="fc" id="L970">        final List&lt;PeerAddress&gt; addressList = Lists.newLinkedList();</span>
<span class="fc bfc" id="L971" title="All 2 branches covered.">        for (PeerDiscovery peerDiscovery : peerDiscoverers /* COW */) {</span>
            InetSocketAddress[] addresses;
<span class="fc" id="L973">            addresses = peerDiscovery.getPeers(requiredServices, peerDiscoveryTimeoutMillis, TimeUnit.MILLISECONDS);</span>
<span class="fc bfc" id="L974" title="All 2 branches covered.">            for (InetSocketAddress address : addresses) addressList.add(new PeerAddress(params, address));</span>
<span class="fc bfc" id="L975" title="All 2 branches covered.">            if (addressList.size() &gt;= maxPeersToDiscoverCount) break;</span>
<span class="fc" id="L976">        }</span>
<span class="fc bfc" id="L977" title="All 2 branches covered.">        if (!addressList.isEmpty()) {</span>
<span class="fc bfc" id="L978" title="All 2 branches covered.">            for (PeerAddress address : addressList) {</span>
<span class="fc" id="L979">                addInactive(address);</span>
<span class="fc" id="L980">            }</span>
<span class="fc" id="L981">            final ImmutableSet&lt;PeerAddress&gt; peersDiscoveredSet = ImmutableSet.copyOf(addressList);</span>
<span class="fc bfc" id="L982" title="All 2 branches covered.">            for (final ListenerRegistration&lt;PeerDiscoveredEventListener&gt; registration : peerDiscoveredEventListeners /* COW */) {</span>
<span class="fc" id="L983">                registration.executor.execute(new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L986">                        registration.listener.onPeersDiscovered(peersDiscoveredSet);</span>
<span class="fc" id="L987">                    }</span>
                });
<span class="fc" id="L989">            }</span>
        }
<span class="fc" id="L991">        watch.stop();</span>
<span class="fc" id="L992">        log.info(&quot;Peer discovery took {} and returned {} items&quot;, watch, addressList.size());</span>
<span class="fc" id="L993">        return addressList.size();</span>
    }

    @VisibleForTesting
    void waitForJobQueue() {
<span class="fc" id="L998">        Futures.getUnchecked(executor.submit(Runnables.doNothing()));</span>
<span class="fc" id="L999">    }</span>

    private int countConnectedAndPendingPeers() {
<span class="fc" id="L1002">        lock.lock();</span>
        try {
<span class="fc" id="L1004">            return peers.size() + pendingPeers.size();</span>
        } finally {
<span class="pc" id="L1006">            lock.unlock();</span>
        }
    }

<span class="pc" id="L1010">    private enum LocalhostCheckState {</span>
<span class="fc" id="L1011">        NOT_TRIED,</span>
<span class="fc" id="L1012">        FOUND,</span>
<span class="fc" id="L1013">        FOUND_AND_CONNECTED,</span>
<span class="fc" id="L1014">        NOT_THERE</span>
    }
<span class="fc" id="L1016">    private LocalhostCheckState localhostCheckState = LocalhostCheckState.NOT_TRIED;</span>

    private boolean maybeCheckForLocalhostPeer() {
<span class="fc" id="L1019">        checkState(lock.isHeldByCurrentThread());</span>
<span class="pc bpc" id="L1020" title="1 of 2 branches missed.">        if (localhostCheckState == LocalhostCheckState.NOT_TRIED) {</span>
            // Do a fast blocking connect to see if anything is listening.
<span class="fc" id="L1022">            Socket socket = null;</span>
            try {
<span class="fc" id="L1024">                socket = new Socket();</span>
<span class="fc" id="L1025">                socket.connect(new InetSocketAddress(InetAddresses.forString(&quot;127.0.0.1&quot;), params.getPort()), vConnectTimeoutMillis);</span>
<span class="fc" id="L1026">                localhostCheckState = LocalhostCheckState.FOUND;</span>
<span class="fc" id="L1027">                return true;</span>
<span class="nc" id="L1028">            } catch (IOException e) {</span>
<span class="nc" id="L1029">                log.info(&quot;Localhost peer not detected.&quot;);</span>
<span class="nc" id="L1030">                localhostCheckState = LocalhostCheckState.NOT_THERE;</span>
            } finally {
<span class="pc bpc" id="L1032" title="5 of 6 branches missed.">                if (socket != null) {</span>
                    try {
<span class="pc" id="L1034">                        socket.close();</span>
<span class="nc" id="L1035">                    } catch (IOException e) {</span>
                        // Ignore.
<span class="pc" id="L1037">                    }</span>
                }
            }
        }
<span class="nc" id="L1041">        return false;</span>
    }

    /**
     * Starts the PeerGroup and begins network activity.
     * @return A future that completes when first connection activity has been triggered (note: not first connection made).
     */
    public ListenableFuture startAsync() {
        // This is run in a background thread by the Service implementation.
<span class="pc bpc" id="L1050" title="1 of 2 branches missed.">        if (chain == null) {</span>
            // Just try to help catch what might be a programming error.
<span class="nc" id="L1052">            log.warn(&quot;Starting up with no attached block chain. Did you forget to pass one to the constructor?&quot;);</span>
        }
<span class="pc bpc" id="L1054" title="1 of 2 branches missed.">        checkState(!vUsedUp, &quot;Cannot start a peer group twice&quot;);</span>
<span class="fc" id="L1055">        vRunning = true;</span>
<span class="fc" id="L1056">        vUsedUp = true;</span>
<span class="fc" id="L1057">        executorStartupLatch.countDown();</span>
        // We do blocking waits during startup, so run on the executor thread.
<span class="fc" id="L1059">        return executor.submit(new Runnable() {</span>
            @Override
            public void run() {
                try {
<span class="fc" id="L1063">                    log.info(&quot;Starting ...&quot;);</span>
<span class="fc" id="L1064">                    channels.startAsync();</span>
<span class="fc" id="L1065">                    channels.awaitRunning();</span>
<span class="fc" id="L1066">                    triggerConnections();</span>
<span class="fc" id="L1067">                    setupPinging();</span>
<span class="nc" id="L1068">                } catch (Throwable e) {</span>
<span class="nc" id="L1069">                    log.error(&quot;Exception when starting up&quot;, e);  // The executor swallows exceptions :(</span>
<span class="fc" id="L1070">                }</span>
<span class="fc" id="L1071">            }</span>
        });
    }

    /** Does a blocking startup. */
    public void start() {
<span class="fc" id="L1077">        Futures.getUnchecked(startAsync());</span>
<span class="fc" id="L1078">    }</span>

    /** Can just use start() for a blocking start here instead of startAsync/awaitRunning: PeerGroup is no longer a Guava service. */
    @Deprecated
    public void awaitRunning() {
<span class="nc" id="L1083">        waitForJobQueue();</span>
<span class="nc" id="L1084">    }</span>

    public ListenableFuture stopAsync() {
<span class="fc" id="L1087">        checkState(vRunning);</span>
<span class="fc" id="L1088">        vRunning = false;</span>
<span class="fc" id="L1089">        ListenableFuture future = executor.submit(new Runnable() {</span>
            @Override
            public void run() {
                try {
<span class="fc" id="L1093">                    log.info(&quot;Stopping ...&quot;);</span>
                    // Blocking close of all sockets.
<span class="fc" id="L1095">                    channels.stopAsync();</span>
<span class="fc" id="L1096">                    channels.awaitTerminated();</span>
<span class="fc bfc" id="L1097" title="All 2 branches covered.">                    for (PeerDiscovery peerDiscovery : peerDiscoverers) {</span>
<span class="fc" id="L1098">                        peerDiscovery.shutdown();</span>
<span class="fc" id="L1099">                    }</span>
<span class="fc" id="L1100">                    vRunning = false;</span>
<span class="fc" id="L1101">                    log.info(&quot;Stopped.&quot;);</span>
<span class="nc" id="L1102">                } catch (Throwable e) {</span>
<span class="nc" id="L1103">                    log.error(&quot;Exception when shutting down&quot;, e);  // The executor swallows exceptions :(</span>
<span class="fc" id="L1104">                }</span>
<span class="fc" id="L1105">            }</span>
        });
<span class="fc" id="L1107">        executor.shutdown();</span>
<span class="fc" id="L1108">        return future;</span>
    }

    /** Does a blocking stop */
    public void stop() {
        try {
<span class="fc" id="L1114">            stopAsync();</span>
<span class="fc" id="L1115">            log.info(&quot;Awaiting PeerGroup shutdown ...&quot;);</span>
<span class="fc" id="L1116">            executor.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);</span>
<span class="nc" id="L1117">        } catch (InterruptedException e) {</span>
<span class="nc" id="L1118">            throw new RuntimeException(e);</span>
<span class="fc" id="L1119">        }</span>
<span class="fc" id="L1120">    }</span>

    /** Can just use stop() here instead of stopAsync/awaitTerminated: PeerGroup is no longer a Guava service. */
    @Deprecated
    public void awaitTerminated() {
        try {
<span class="nc" id="L1126">            executor.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);</span>
<span class="nc" id="L1127">        } catch (InterruptedException e) {</span>
<span class="nc" id="L1128">            throw new RuntimeException(e);</span>
<span class="nc" id="L1129">        }</span>
<span class="nc" id="L1130">    }</span>

    /**
     * &lt;p&gt;Link the given wallet to this PeerGroup. This is used for three purposes:&lt;/p&gt;
     *
     * &lt;ol&gt;
     *   &lt;li&gt;So the wallet receives broadcast transactions.&lt;/li&gt;
     *   &lt;li&gt;Announcing pending transactions that didn't get into the chain yet to our peers.&lt;/li&gt;
     *   &lt;li&gt;Set the fast catchup time using {@link PeerGroup#setFastCatchupTimeSecs(long)}, to optimize chain
     *       download.&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * &lt;p&gt;Note that this should be done before chain download commences because if you add a wallet with keys earlier
     * than the current chain head, the relevant parts of the chain won't be redownloaded for you.&lt;/p&gt;
     *
     * &lt;p&gt;The Wallet will have an event listener registered on it, so to avoid leaks remember to use
     * {@link PeerGroup#removeWallet(Wallet)} on it if you wish to keep the Wallet but lose the PeerGroup.&lt;/p&gt;
     */
    public void addWallet(Wallet wallet) {
<span class="fc" id="L1149">        lock.lock();</span>
        try {
<span class="fc" id="L1151">            checkNotNull(wallet);</span>
<span class="pc bpc" id="L1152" title="1 of 2 branches missed.">            checkState(!wallets.contains(wallet));</span>
<span class="fc" id="L1153">            wallets.add(wallet);</span>
<span class="fc" id="L1154">            wallet.setTransactionBroadcaster(this);</span>
<span class="fc" id="L1155">            wallet.addCoinsReceivedEventListener(Threading.SAME_THREAD, walletCoinsReceivedEventListener);</span>
<span class="fc" id="L1156">            wallet.addKeyChainEventListener(Threading.SAME_THREAD, walletKeyEventListener);</span>
<span class="fc" id="L1157">            wallet.addScriptChangeEventListener(Threading.SAME_THREAD, walletScriptEventListener);</span>
<span class="fc" id="L1158">            addPeerFilterProvider(wallet);</span>
<span class="fc bfc" id="L1159" title="All 2 branches covered.">            for (Peer peer : peers) {</span>
<span class="fc" id="L1160">                peer.addWallet(wallet);</span>
<span class="fc" id="L1161">            }</span>
        } finally {
<span class="pc" id="L1163">            lock.unlock();</span>
<span class="fc" id="L1164">        }</span>
<span class="fc" id="L1165">    }</span>

    /**
     * &lt;p&gt;Link the given PeerFilterProvider to this PeerGroup. DO NOT use this for Wallets, use
     * {@link PeerGroup#addWallet(Wallet)} instead.&lt;/p&gt;
     *
     * &lt;p&gt;Note that this should be done before chain download commences because if you add a listener with keys earlier
     * than the current chain head, the relevant parts of the chain won't be redownloaded for you.&lt;/p&gt;
     *
     * &lt;p&gt;This method invokes {@link PeerGroup#recalculateFastCatchupAndFilter(FilterRecalculateMode)}.
     * The return value of this method is the &lt;code&gt;ListenableFuture&lt;/code&gt; returned by that invocation.&lt;/p&gt;
     *
     * @return a future that completes once each &lt;code&gt;Peer&lt;/code&gt; in this group has had its
     *         &lt;code&gt;BloomFilter&lt;/code&gt; (re)set.
     */
    public ListenableFuture&lt;BloomFilter&gt; addPeerFilterProvider(PeerFilterProvider provider) {
<span class="fc" id="L1181">        lock.lock();</span>
        try {
<span class="fc" id="L1183">            checkNotNull(provider);</span>
<span class="pc bpc" id="L1184" title="1 of 2 branches missed.">            checkState(!peerFilterProviders.contains(provider));</span>
            // Insert provider at the start. This avoids various concurrency problems that could occur because we need
            // all providers to be in a consistent, unchanging state whilst the filter is built. Providers can give
            // this guarantee by taking a lock in their begin method, but if we add to the end of the list here, it
            // means we establish a lock ordering a &gt; b &gt; c if that's the order the providers were added in. Given that
            // the main wallet will usually be first, this establishes an ordering wallet &gt; other-provider, which means
            // other-provider can then not call into the wallet itself. Other providers installed by the API user should
            // come first so the expected ordering is preserved. This can also manifest itself in providers that use
            // synchronous RPCs into an actor instead of locking, but the same issue applies.
<span class="fc" id="L1193">            peerFilterProviders.add(0, provider);</span>

            // Don't bother downloading block bodies before the oldest keys in all our wallets. Make sure we recalculate
            // if a key is added. Of course, by then we may have downloaded the chain already. Ideally adding keys would
            // automatically rewind the block chain and redownload the blocks to find transactions relevant to those keys,
            // all transparently and in the background. But we are a long way from that yet.
<span class="fc" id="L1199">            ListenableFuture&lt;BloomFilter&gt; future = recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);</span>
<span class="fc" id="L1200">            updateVersionMessageRelayTxesBeforeFilter(getVersionMessage());</span>
<span class="fc" id="L1201">            return future;</span>
        } finally {
<span class="pc" id="L1203">            lock.unlock();</span>
        }
    }

    /**
     * Opposite of {@link #addPeerFilterProvider(PeerFilterProvider)}. Again, don't use this for wallets. Does not
     * trigger recalculation of the filter.
     */
    public void removePeerFilterProvider(PeerFilterProvider provider) {
<span class="nc" id="L1212">        lock.lock();</span>
        try {
<span class="nc" id="L1214">            checkNotNull(provider);</span>
<span class="nc" id="L1215">            checkArgument(peerFilterProviders.remove(provider));</span>
        } finally {
<span class="nc" id="L1217">            lock.unlock();</span>
<span class="nc" id="L1218">        }</span>
<span class="nc" id="L1219">    }</span>

    /**
     * Unlinks the given wallet so it no longer receives broadcast transactions or has its transactions announced.
     */
    public void removeWallet(Wallet wallet) {
<span class="fc" id="L1225">        wallets.remove(checkNotNull(wallet));</span>
<span class="fc" id="L1226">        peerFilterProviders.remove(wallet);</span>
<span class="fc" id="L1227">        wallet.removeCoinsReceivedEventListener(walletCoinsReceivedEventListener);</span>
<span class="fc" id="L1228">        wallet.removeKeyChainEventListener(walletKeyEventListener);</span>
<span class="fc" id="L1229">        wallet.removeScriptChangeEventListener(walletScriptEventListener);</span>
<span class="fc" id="L1230">        wallet.setTransactionBroadcaster(null);</span>
<span class="fc bfc" id="L1231" title="All 2 branches covered.">        for (Peer peer : peers) {</span>
<span class="fc" id="L1232">            peer.removeWallet(wallet);</span>
<span class="fc" id="L1233">        }        </span>
<span class="fc" id="L1234">    }</span>

<span class="pc" id="L1236">    public enum FilterRecalculateMode {</span>
<span class="fc" id="L1237">        SEND_IF_CHANGED,</span>
<span class="fc" id="L1238">        FORCE_SEND_FOR_REFRESH,</span>
<span class="fc" id="L1239">        DONT_SEND,</span>
    }

<span class="fc" id="L1242">    private final Map&lt;FilterRecalculateMode, SettableFuture&lt;BloomFilter&gt;&gt; inFlightRecalculations = Maps.newHashMap();</span>

    /**
     * Recalculates the bloom filter given to peers as well as the timestamp after which full blocks are downloaded
     * (instead of only headers). Note that calls made one after another may return the same future, if the request
     * wasn't processed yet (i.e. calls are deduplicated).
     *
     * @param mode In what situations to send the filter to connected peers.
     * @return a future that completes once the filter has been calculated (note: this does not mean acknowledged by remote peers).
     */
    public ListenableFuture&lt;BloomFilter&gt; recalculateFastCatchupAndFilter(final FilterRecalculateMode mode) {
<span class="fc" id="L1253">        final SettableFuture&lt;BloomFilter&gt; future = SettableFuture.create();</span>
<span class="fc" id="L1254">        synchronized (inFlightRecalculations) {</span>
<span class="fc bfc" id="L1255" title="All 2 branches covered.">            if (inFlightRecalculations.get(mode) != null)</span>
<span class="fc" id="L1256">                return inFlightRecalculations.get(mode);</span>
<span class="fc" id="L1257">            inFlightRecalculations.put(mode, future);</span>
<span class="pc" id="L1258">        }</span>
<span class="fc" id="L1259">        Runnable command = new Runnable() {</span>
            @Override
            public void run() {
                try {
<span class="fc" id="L1263">                    go();</span>
<span class="nc" id="L1264">                } catch (Throwable e) {</span>
<span class="nc" id="L1265">                    log.error(&quot;Exception when trying to recalculate Bloom filter&quot;, e);  // The executor swallows exceptions :(</span>
<span class="fc" id="L1266">                }</span>
<span class="fc" id="L1267">            }</span>

            public void go() {
<span class="pc bpc" id="L1270" title="1 of 2 branches missed.">                checkState(!lock.isHeldByCurrentThread());</span>
                // Fully verifying mode doesn't use this optimization (it can't as it needs to see all transactions).
<span class="pc bpc" id="L1272" title="3 of 6 branches missed.">                if ((chain != null &amp;&amp; chain.shouldVerifyTransactions()) || !vBloomFilteringEnabled)</span>
<span class="nc" id="L1273">                    return;</span>
                // We only ever call bloomFilterMerger.calculate on jobQueue, so we cannot be calculating two filters at once.
<span class="fc" id="L1275">                FilterMerger.Result result = bloomFilterMerger.calculate(ImmutableList.copyOf(peerFilterProviders /* COW */));</span>
                boolean send;
<span class="pc bpc" id="L1277" title="2 of 4 branches missed.">                switch (mode) {</span>
                    case SEND_IF_CHANGED:
<span class="fc" id="L1279">                        send = result.changed;</span>
<span class="fc" id="L1280">                        break;</span>
                    case DONT_SEND:
<span class="fc" id="L1282">                        send = false;</span>
<span class="fc" id="L1283">                        break;</span>
                    case FORCE_SEND_FOR_REFRESH:
<span class="nc" id="L1285">                        send = true;</span>
<span class="nc" id="L1286">                        break;</span>
                    default:
<span class="nc" id="L1288">                        throw new UnsupportedOperationException();</span>
                }
<span class="fc bfc" id="L1290" title="All 2 branches covered.">                if (send) {</span>
<span class="fc bfc" id="L1291" title="All 2 branches covered.">                    for (Peer peer : peers /* COW */) {</span>
                        // Only query the mempool if this recalculation request is not in order to lower the observed FP
                        // rate. There's no point querying the mempool when doing this because the FP rate can only go
                        // down, and we will have seen all the relevant txns before: it's pointless to ask for them again.
<span class="pc bpc" id="L1295" title="1 of 2 branches missed.">                        peer.setBloomFilter(result.filter, mode != FilterRecalculateMode.FORCE_SEND_FOR_REFRESH);</span>
<span class="fc" id="L1296">                    }</span>
                    // Reset the false positive estimate so that we don't send a flood of filter updates
                    // if the estimate temporarily overshoots our threshold.
<span class="pc bpc" id="L1299" title="1 of 2 branches missed.">                    if (chain != null)</span>
<span class="fc" id="L1300">                        chain.resetFalsePositiveEstimate();</span>
                }
                // Do this last so that bloomFilter is already set when it gets called.
<span class="fc" id="L1303">                setFastCatchupTimeSecs(result.earliestKeyTimeSecs);</span>
<span class="fc" id="L1304">                synchronized (inFlightRecalculations) {</span>
<span class="fc" id="L1305">                    inFlightRecalculations.put(mode, null);</span>
<span class="pc" id="L1306">                }</span>
<span class="fc" id="L1307">                future.set(result.filter);</span>
<span class="fc" id="L1308">            }</span>
        };
        try {
<span class="fc" id="L1311">            executor.execute(command);</span>
<span class="nc" id="L1312">        } catch (RejectedExecutionException e) {</span>
            // Can happen during shutdown.
<span class="fc" id="L1314">        }</span>
<span class="fc" id="L1315">        return future;</span>
    }
    
    /**
     * &lt;p&gt;Sets the false positive rate of bloom filters given to peers. The default is {@link #DEFAULT_BLOOM_FILTER_FP_RATE}.&lt;/p&gt;
     *
     * &lt;p&gt;Be careful regenerating the bloom filter too often, as it decreases anonymity because remote nodes can
     * compare transactions against both the new and old filters to significantly decrease the false positive rate.&lt;/p&gt;
     * 
     * &lt;p&gt;See the docs for {@link BloomFilter#BloomFilter(int, double, long, BloomFilter.BloomUpdate)} for a brief
     * explanation of anonymity when using bloom filters.&lt;/p&gt;
     */
    public void setBloomFilterFalsePositiveRate(double bloomFilterFPRate) {
<span class="nc" id="L1328">        lock.lock();</span>
        try {
<span class="nc" id="L1330">            bloomFilterMerger.setBloomFilterFPRate(bloomFilterFPRate);</span>
<span class="nc" id="L1331">            recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);</span>
        } finally {
<span class="nc" id="L1333">            lock.unlock();</span>
<span class="nc" id="L1334">        }</span>
<span class="nc" id="L1335">    }</span>

    /**
     * Returns the number of currently connected peers. To be informed when this count changes, register a 
     * {@link org.bitcoinj.core.listeners.PeerConnectionEventListener} and use the onPeerConnected/onPeerDisconnected methods.
     */
    public int numConnectedPeers() {
<span class="fc" id="L1342">        return peers.size();</span>
    }

    /**
     * Connect to a peer by creating a channel to the destination address.  This should not be
     * used normally - let the PeerGroup manage connections through {@link #start()}
     * 
     * @param address destination IP and port.
     * @return The newly created Peer object or null if the peer could not be connected.
     *         Use {@link org.bitcoinj.core.Peer#getConnectionOpenFuture()} if you
     *         want a future which completes when the connection is open.
     */
    @Nullable
    public Peer connectTo(InetSocketAddress address) {
<span class="fc" id="L1356">        lock.lock();</span>
        try {
<span class="fc" id="L1358">            PeerAddress peerAddress = new PeerAddress(params, address);</span>
<span class="fc" id="L1359">            backoffMap.put(peerAddress, new ExponentialBackoff(peerBackoffParams));</span>
<span class="fc" id="L1360">            return connectTo(peerAddress, true, vConnectTimeoutMillis);</span>
        } finally {
<span class="pc" id="L1362">            lock.unlock();</span>
        }
    }

    /**
     * Helper for forcing a connection to localhost. Useful when using regtest mode. Returns the peer object.
     */
    @Nullable
    public Peer connectToLocalHost() {
<span class="fc" id="L1371">        lock.lock();</span>
        try {
<span class="fc" id="L1373">            final PeerAddress localhost = PeerAddress.localhost(params);</span>
<span class="fc" id="L1374">            backoffMap.put(localhost, new ExponentialBackoff(peerBackoffParams));</span>
<span class="fc" id="L1375">            return connectTo(localhost, true, vConnectTimeoutMillis);</span>
        } finally {
<span class="pc" id="L1377">            lock.unlock();</span>
        }
    }

    /**
     * Creates a version message to send, constructs a Peer object and attempts to connect it. Returns the peer on
     * success or null on failure.
     * @param address Remote network address
     * @param incrementMaxConnections Whether to consider this connection an attempt to fill our quota, or something
     *                                explicitly requested.
     * @return Peer or null.
     */
    @Nullable @GuardedBy(&quot;lock&quot;)
    protected Peer connectTo(PeerAddress address, boolean incrementMaxConnections, int connectTimeoutMillis) {
<span class="fc" id="L1391">        checkState(lock.isHeldByCurrentThread());</span>
<span class="fc" id="L1392">        VersionMessage ver = getVersionMessage().duplicate();</span>
<span class="pc bpc" id="L1393" title="1 of 2 branches missed.">        ver.bestHeight = chain == null ? 0 : chain.getBestChainHeight();</span>
<span class="fc" id="L1394">        ver.time = Utils.currentTimeSeconds();</span>

<span class="fc" id="L1396">        Peer peer = createPeer(address, ver);</span>
<span class="fc" id="L1397">        peer.addConnectedEventListener(Threading.SAME_THREAD, startupListener);</span>
<span class="fc" id="L1398">        peer.addDisconnectedEventListener(Threading.SAME_THREAD, startupListener);</span>
<span class="fc" id="L1399">        peer.setMinProtocolVersion(vMinRequiredProtocolVersion);</span>
<span class="fc" id="L1400">        pendingPeers.add(peer);</span>

        try {
<span class="fc" id="L1403">            log.info(&quot;Attempting connection to {}     ({} connected, {} pending, {} max)&quot;, address,</span>
<span class="fc" id="L1404">                    peers.size(), pendingPeers.size(), maxConnections);</span>
<span class="fc" id="L1405">            ListenableFuture&lt;SocketAddress&gt; future = channels.openConnection(address.toSocketAddress(), peer);</span>
<span class="pc bpc" id="L1406" title="1 of 2 branches missed.">            if (future.isDone())</span>
<span class="nc" id="L1407">                Uninterruptibles.getUninterruptibly(future);</span>
<span class="nc" id="L1408">        } catch (ExecutionException e) {</span>
<span class="nc" id="L1409">            Throwable cause = Throwables.getRootCause(e);</span>
<span class="nc" id="L1410">            log.warn(&quot;Failed to connect to &quot; + address + &quot;: &quot; + cause.getMessage());</span>
<span class="nc" id="L1411">            handlePeerDeath(peer, cause);</span>
<span class="nc" id="L1412">            return null;</span>
<span class="fc" id="L1413">        }</span>
<span class="fc" id="L1414">        peer.setSocketTimeout(connectTimeoutMillis);</span>
        // When the channel has connected and version negotiated successfully, handleNewPeer will end up being called on
        // a worker thread.
<span class="pc bpc" id="L1417" title="1 of 2 branches missed.">        if (incrementMaxConnections) {</span>
            // We don't use setMaxConnections here as that would trigger a recursive attempt to establish a new
            // outbound connection.
<span class="fc" id="L1420">            maxConnections++;</span>
        }
<span class="fc" id="L1422">        return peer;</span>
    }

    /** You can override this to customise the creation of {@link Peer} objects. */
    @GuardedBy(&quot;lock&quot;)
    protected Peer createPeer(PeerAddress address, VersionMessage ver) {
<span class="fc" id="L1428">        return new Peer(params, ver, address, chain, downloadTxDependencyDepth);</span>
    }

    /**
     * Sets the timeout between when a connection attempt to a peer begins and when the version message exchange
     * completes. This does not apply to currently pending peers.
     */
    public void setConnectTimeoutMillis(int connectTimeoutMillis) {
<span class="fc" id="L1436">        this.vConnectTimeoutMillis = connectTimeoutMillis;</span>
<span class="fc" id="L1437">    }</span>

    /**
     * &lt;p&gt;Start downloading the blockchain from the first available peer.&lt;/p&gt;
     *
     * &lt;p&gt;If no peers are currently connected, the download will be started once a peer starts.  If the peer dies,
     * the download will resume with another peer.&lt;/p&gt;
     *
     * @param listener a listener for chain download events, may not be null
     */
    public void startBlockChainDownload(PeerDataEventListener listener) {
<span class="fc" id="L1448">        lock.lock();</span>
        try {
<span class="pc bpc" id="L1450" title="1 of 2 branches missed.">            if (downloadPeer != null) {</span>
<span class="pc bpc" id="L1451" title="1 of 2 branches missed.">                if (this.downloadListener != null) {</span>
<span class="nc" id="L1452">                    removeDataEventListenerFromPeer(downloadPeer, this.downloadListener);</span>
                }
<span class="fc bfc" id="L1454" title="All 2 branches covered.">                if (listener != null) {</span>
<span class="fc" id="L1455">                    addDataEventListenerToPeer(Threading.USER_THREAD, downloadPeer, listener);</span>
                }
            }
<span class="fc" id="L1458">            this.downloadListener = listener;</span>
            // TODO: be more nuanced about which peer to download from.  We can also try
            // downloading from multiple peers and handle the case when a new peer comes along
            // with a longer chain after we thought we were done.
<span class="pc bpc" id="L1462" title="1 of 2 branches missed.">            if (!peers.isEmpty()) {</span>
<span class="fc" id="L1463">                startBlockChainDownloadFromPeer(peers.iterator().next()); // Will add the new download listener</span>
            }
        } finally {
<span class="pc" id="L1466">            lock.unlock();</span>
<span class="fc" id="L1467">        }</span>
<span class="fc" id="L1468">    }</span>

    /**
     * Register a data event listener against a single peer (i.e. for blockchain
     * download). Handling registration/deregistration on peer death/add is
     * outside the scope of these methods.
     */
    private static void addDataEventListenerToPeer(Executor executor, Peer peer, PeerDataEventListener downloadListener) {
<span class="fc" id="L1476">        peer.addBlocksDownloadedEventListener(executor, downloadListener);</span>
<span class="fc" id="L1477">        peer.addChainDownloadStartedEventListener(executor, downloadListener);</span>
<span class="fc" id="L1478">        peer.addGetDataEventListener(executor, downloadListener);</span>
<span class="fc" id="L1479">        peer.addPreMessageReceivedEventListener(executor, downloadListener);</span>
<span class="fc" id="L1480">    }</span>

    /**
     * Remove a registered data event listener against a single peer (i.e. for
     * blockchain download). Handling registration/deregistration on peer death/add is
     * outside the scope of these methods.
     */
    private static void removeDataEventListenerFromPeer(Peer peer, PeerDataEventListener listener) {
<span class="fc" id="L1488">        peer.removeBlocksDownloadedEventListener(listener);</span>
<span class="fc" id="L1489">        peer.removeChainDownloadStartedEventListener(listener);</span>
<span class="fc" id="L1490">        peer.removeGetDataEventListener(listener);</span>
<span class="fc" id="L1491">        peer.removePreMessageReceivedEventListener(listener);</span>
<span class="fc" id="L1492">    }</span>

    /**
     * Download the blockchain from peers. Convenience that uses a {@link DownloadProgressTracker} for you.&lt;p&gt;
     * 
     * This method waits until the download is complete.  &quot;Complete&quot; is defined as downloading
     * from at least one peer all the blocks that are in that peer's inventory.
     */
    public void downloadBlockChain() {
<span class="nc" id="L1501">        DownloadProgressTracker listener = new DownloadProgressTracker();</span>
<span class="nc" id="L1502">        startBlockChainDownload(listener);</span>
        try {
<span class="nc" id="L1504">            listener.await();</span>
<span class="nc" id="L1505">        } catch (InterruptedException e) {</span>
<span class="nc" id="L1506">            throw new RuntimeException(e);</span>
<span class="nc" id="L1507">        }</span>
<span class="nc" id="L1508">    }</span>

    protected void handleNewPeer(final Peer peer) {
<span class="fc" id="L1511">        int newSize = -1;</span>
<span class="fc" id="L1512">        lock.lock();</span>
        try {
<span class="fc" id="L1514">            groupBackoff.trackSuccess();</span>
<span class="fc" id="L1515">            backoffMap.get(peer.getAddress()).trackSuccess();</span>

            // Sets up the newly connected peer so it can do everything it needs to.
<span class="fc" id="L1518">            pendingPeers.remove(peer);</span>
<span class="fc" id="L1519">            peers.add(peer);</span>
<span class="fc" id="L1520">            newSize = peers.size();</span>
<span class="fc" id="L1521">            log.info(&quot;{}: New peer      ({} connected, {} pending, {} max)&quot;, peer, newSize, pendingPeers.size(), maxConnections);</span>
            // Give the peer a filter that can be used to probabilistically drop transactions that
            // aren't relevant to our wallet. We may still receive some false positives, which is
            // OK because it helps improve wallet privacy. Old nodes will just ignore the message.
<span class="pc bpc" id="L1525" title="1 of 2 branches missed.">            if (bloomFilterMerger.getLastFilter() != null) peer.setBloomFilter(bloomFilterMerger.getLastFilter());</span>
<span class="fc" id="L1526">            peer.setDownloadData(false);</span>
            // TODO: The peer should calculate the fast catchup time from the added wallets here.
<span class="fc bfc" id="L1528" title="All 2 branches covered.">            for (Wallet wallet : wallets)</span>
<span class="fc" id="L1529">                peer.addWallet(wallet);</span>
<span class="fc bfc" id="L1530" title="All 2 branches covered.">            if (downloadPeer == null) {</span>
                // Kick off chain download if we aren't already doing it.
<span class="fc" id="L1532">                setDownloadPeer(selectDownloadPeer(peers));</span>
<span class="pc bpc" id="L1533" title="3 of 4 branches missed.">                boolean shouldDownloadChain = downloadListener != null &amp;&amp; chain != null;</span>
<span class="pc bpc" id="L1534" title="1 of 2 branches missed.">                if (shouldDownloadChain) {</span>
<span class="nc" id="L1535">                    startBlockChainDownloadFromPeer(downloadPeer);</span>
                }
            }
            // Make sure the peer knows how to upload transactions that are requested from us.
<span class="fc" id="L1539">            peer.addBlocksDownloadedEventListener(Threading.SAME_THREAD, peerListener);</span>
<span class="fc" id="L1540">            peer.addGetDataEventListener(Threading.SAME_THREAD, peerListener);</span>

            // And set up event listeners for clients. This will allow them to find out about new transactions and blocks.
<span class="pc bpc" id="L1543" title="1 of 2 branches missed.">            for (ListenerRegistration&lt;BlocksDownloadedEventListener&gt; registration : peersBlocksDownloadedEventListeners)</span>
<span class="nc" id="L1544">                peer.addBlocksDownloadedEventListener(registration.executor, registration.listener);</span>
<span class="pc bpc" id="L1545" title="1 of 2 branches missed.">            for (ListenerRegistration&lt;ChainDownloadStartedEventListener&gt; registration : peersChainDownloadStartedEventListeners)</span>
<span class="nc" id="L1546">                peer.addChainDownloadStartedEventListener(registration.executor, registration.listener);</span>
<span class="fc bfc" id="L1547" title="All 2 branches covered.">            for (ListenerRegistration&lt;PeerConnectedEventListener&gt; registration : peerConnectedEventListeners)</span>
<span class="fc" id="L1548">                peer.addConnectedEventListener(registration.executor, registration.listener);</span>
            // We intentionally do not add disconnect listeners to peers
<span class="pc bpc" id="L1550" title="1 of 2 branches missed.">            for (ListenerRegistration&lt;GetDataEventListener&gt; registration : peerGetDataEventListeners)</span>
<span class="nc" id="L1551">                peer.addGetDataEventListener(registration.executor, registration.listener);</span>
<span class="fc bfc" id="L1552" title="All 2 branches covered.">            for (ListenerRegistration&lt;OnTransactionBroadcastListener&gt; registration : peersTransactionBroadastEventListeners)</span>
<span class="fc" id="L1553">                peer.addOnTransactionBroadcastListener(registration.executor, registration.listener);</span>
<span class="fc bfc" id="L1554" title="All 2 branches covered.">            for (ListenerRegistration&lt;PreMessageReceivedEventListener&gt; registration : peersPreMessageReceivedEventListeners)</span>
<span class="fc" id="L1555">                peer.addPreMessageReceivedEventListener(registration.executor, registration.listener);</span>
        } finally {
<span class="pc" id="L1557">            lock.unlock();</span>
<span class="fc" id="L1558">        }</span>

<span class="fc" id="L1560">        final int fNewSize = newSize;</span>
<span class="fc bfc" id="L1561" title="All 2 branches covered.">        for (final ListenerRegistration&lt;PeerConnectedEventListener&gt; registration : peerConnectedEventListeners) {</span>
<span class="fc" id="L1562">            registration.executor.execute(new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1565">                    registration.listener.onPeerConnected(peer, fNewSize);</span>
<span class="fc" id="L1566">                }</span>
            });
<span class="fc" id="L1568">        }</span>
<span class="fc" id="L1569">    }</span>

    @Nullable private volatile ListenableScheduledFuture&lt;?&gt; vPingTask;

    @SuppressWarnings(&quot;NonAtomicOperationOnVolatileField&quot;)
    private void setupPinging() {
<span class="fc bfc" id="L1575" title="All 2 branches covered.">        if (getPingIntervalMsec() &lt;= 0)</span>
<span class="fc" id="L1576">            return;  // Disabled.</span>

<span class="fc" id="L1578">        vPingTask = executor.scheduleAtFixedRate(new Runnable() {</span>
            @Override
            public void run() {
                try {
<span class="pc bpc" id="L1582" title="1 of 2 branches missed.">                    if (getPingIntervalMsec() &lt;= 0) {</span>
<span class="nc" id="L1583">                        ListenableScheduledFuture&lt;?&gt; task = vPingTask;</span>
<span class="nc bnc" id="L1584" title="All 2 branches missed.">                        if (task != null) {</span>
<span class="nc" id="L1585">                            task.cancel(false);</span>
<span class="nc" id="L1586">                            vPingTask = null;</span>
                        }
<span class="nc" id="L1588">                        return;  // Disabled.</span>
                    }
<span class="fc bfc" id="L1590" title="All 2 branches covered.">                    for (Peer peer : getConnectedPeers()) {</span>
<span class="pc bpc" id="L1591" title="1 of 2 branches missed.">                        if (peer.getPeerVersionMessage().clientVersion &lt; params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.PONG))</span>
<span class="nc" id="L1592">                            continue;</span>
<span class="fc" id="L1593">                        peer.ping();</span>
<span class="fc" id="L1594">                    }</span>
<span class="nc" id="L1595">                } catch (Throwable e) {</span>
<span class="nc" id="L1596">                    log.error(&quot;Exception in ping loop&quot;, e);  // The executor swallows exceptions :(</span>
<span class="fc" id="L1597">                }</span>
<span class="fc" id="L1598">            }</span>
<span class="fc" id="L1599">        }, getPingIntervalMsec(), getPingIntervalMsec(), TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L1600">    }</span>

    private void setDownloadPeer(@Nullable Peer peer) {
<span class="fc" id="L1603">        lock.lock();</span>
        try {
<span class="fc bfc" id="L1605" title="All 2 branches covered.">            if (downloadPeer == peer)</span>
<span class="fc" id="L1606">                return;</span>
<span class="fc bfc" id="L1607" title="All 2 branches covered.">            if (downloadPeer != null) {</span>
<span class="fc" id="L1608">                log.info(&quot;Unsetting download peer: {}&quot;, downloadPeer);</span>
<span class="fc bfc" id="L1609" title="All 2 branches covered.">                if (downloadListener != null) {</span>
<span class="fc" id="L1610">                    removeDataEventListenerFromPeer(downloadPeer, downloadListener);</span>
                }
<span class="fc" id="L1612">                downloadPeer.setDownloadData(false);</span>
            }
<span class="fc" id="L1614">            downloadPeer = peer;</span>
<span class="fc bfc" id="L1615" title="All 2 branches covered.">            if (downloadPeer != null) {</span>
<span class="fc" id="L1616">                log.info(&quot;Setting download peer: {}&quot;, downloadPeer);</span>
<span class="fc bfc" id="L1617" title="All 2 branches covered.">                if (downloadListener != null) {</span>
<span class="fc" id="L1618">                    addDataEventListenerToPeer(Threading.SAME_THREAD, peer, downloadListener);</span>
                }
<span class="fc" id="L1620">                downloadPeer.setDownloadData(true);</span>
<span class="pc bpc" id="L1621" title="1 of 2 branches missed.">                if (chain != null)</span>
<span class="pc bpc" id="L1622" title="1 of 2 branches missed.">                    downloadPeer.setDownloadParameters(fastCatchupTimeSecs, bloomFilterMerger.getLastFilter() != null);</span>
            }
        } finally {
<span class="pc" id="L1625">            lock.unlock();</span>
<span class="fc" id="L1626">        }</span>
<span class="fc" id="L1627">    }</span>

    /** Use &quot;Context.get().getConfidenceTable()&quot; instead */
    @Deprecated @Nullable
    public TxConfidenceTable getMemoryPool() {
<span class="nc" id="L1632">        return Context.get().getConfidenceTable();</span>
    }

    /**
     * Tells the PeerGroup to download only block headers before a certain time and bodies after that. Call this
     * before starting block chain download.
     * Do not use a time &gt; NOW - 1 block, as it will break some block download logic.
     */
    public void setFastCatchupTimeSecs(long secondsSinceEpoch) {
<span class="fc" id="L1641">        lock.lock();</span>
        try {
<span class="pc bpc" id="L1643" title="2 of 4 branches missed.">            checkState(chain == null || !chain.shouldVerifyTransactions(), &quot;Fast catchup is incompatible with fully verifying&quot;);</span>
<span class="fc" id="L1644">            fastCatchupTimeSecs = secondsSinceEpoch;</span>
<span class="fc bfc" id="L1645" title="All 2 branches covered.">            if (downloadPeer != null) {</span>
<span class="pc bpc" id="L1646" title="1 of 2 branches missed.">                downloadPeer.setDownloadParameters(secondsSinceEpoch, bloomFilterMerger.getLastFilter() != null);</span>
            }
        } finally {
<span class="pc" id="L1649">            lock.unlock();</span>
<span class="fc" id="L1650">        }</span>
<span class="fc" id="L1651">    }</span>

    /**
     * Returns the current fast catchup time. The contents of blocks before this time won't be downloaded as they
     * cannot contain any interesting transactions. If you use {@link PeerGroup#addWallet(Wallet)} this just returns
     * the min of the wallets earliest key times.
     * @return a time in seconds since the epoch
     */
    public long getFastCatchupTimeSecs() {
<span class="fc" id="L1660">        lock.lock();</span>
        try {
<span class="fc" id="L1662">            return fastCatchupTimeSecs;</span>
        } finally {
<span class="pc" id="L1664">            lock.unlock();</span>
        }
    }

    protected void handlePeerDeath(final Peer peer, @Nullable Throwable exception) {
        // Peer deaths can occur during startup if a connect attempt after peer discovery aborts immediately.
<span class="fc bfc" id="L1670" title="All 2 branches covered.">        if (!isRunning()) return;</span>

        int numPeers;
<span class="fc" id="L1673">        int numConnectedPeers = 0;</span>
<span class="fc" id="L1674">        lock.lock();</span>
        try {
<span class="fc" id="L1676">            pendingPeers.remove(peer);</span>
<span class="fc" id="L1677">            peers.remove(peer);</span>

<span class="fc" id="L1679">            PeerAddress address = peer.getAddress();</span>

<span class="fc" id="L1681">            log.info(&quot;{}: Peer died      ({} connected, {} pending, {} max)&quot;, address, peers.size(), pendingPeers.size(), maxConnections);</span>
<span class="fc bfc" id="L1682" title="All 2 branches covered.">            if (peer == downloadPeer) {</span>
<span class="fc" id="L1683">                log.info(&quot;Download peer died. Picking a new one.&quot;);</span>
<span class="fc" id="L1684">                setDownloadPeer(null);</span>
                // Pick a new one and possibly tell it to download the chain.
<span class="fc" id="L1686">                final Peer newDownloadPeer = selectDownloadPeer(peers);</span>
<span class="fc bfc" id="L1687" title="All 2 branches covered.">                if (newDownloadPeer != null) {</span>
<span class="fc" id="L1688">                    setDownloadPeer(newDownloadPeer);</span>
<span class="fc bfc" id="L1689" title="All 2 branches covered.">                    if (downloadListener != null) {</span>
<span class="fc" id="L1690">                        startBlockChainDownloadFromPeer(newDownloadPeer);</span>
                    }
                }
            }
<span class="fc" id="L1694">            numPeers = peers.size() + pendingPeers.size();</span>
<span class="fc" id="L1695">            numConnectedPeers = peers.size();</span>

<span class="fc" id="L1697">            groupBackoff.trackFailure();</span>

<span class="pc bpc" id="L1699" title="1 of 2 branches missed.">            if (exception instanceof NoRouteToHostException) {</span>
<span class="nc bnc" id="L1700" title="All 4 branches missed.">                if (address.getAddr() instanceof Inet6Address &amp;&amp; !ipv6Unreachable) {</span>
<span class="nc" id="L1701">                    ipv6Unreachable = true;</span>
<span class="nc" id="L1702">                    log.warn(&quot;IPv6 peer connect failed due to routing failure, ignoring IPv6 addresses from now on&quot;);</span>
                }
            } else {
<span class="fc" id="L1705">                backoffMap.get(address).trackFailure();</span>
                // Put back on inactive list
<span class="fc" id="L1707">                inactives.offer(address);</span>
            }

<span class="pc bpc" id="L1710" title="1 of 2 branches missed.">            if (numPeers &lt; getMaxConnections()) {</span>
<span class="fc" id="L1711">                triggerConnections();</span>
            }
        } finally {
<span class="fc" id="L1714">            lock.unlock();</span>
<span class="fc" id="L1715">        }</span>

<span class="fc" id="L1717">        peer.removeBlocksDownloadedEventListener(peerListener);</span>
<span class="fc" id="L1718">        peer.removeGetDataEventListener(peerListener);</span>
<span class="fc bfc" id="L1719" title="All 2 branches covered.">        for (Wallet wallet : wallets) {</span>
<span class="fc" id="L1720">            peer.removeWallet(wallet);</span>
<span class="fc" id="L1721">        }</span>

<span class="fc" id="L1723">        final int fNumConnectedPeers = numConnectedPeers;</span>

<span class="pc bpc" id="L1725" title="1 of 2 branches missed.">        for (ListenerRegistration&lt;BlocksDownloadedEventListener&gt; registration: peersBlocksDownloadedEventListeners)</span>
<span class="nc" id="L1726">            peer.removeBlocksDownloadedEventListener(registration.listener);</span>
<span class="pc bpc" id="L1727" title="1 of 2 branches missed.">        for (ListenerRegistration&lt;ChainDownloadStartedEventListener&gt; registration: peersChainDownloadStartedEventListeners)</span>
<span class="nc" id="L1728">            peer.removeChainDownloadStartedEventListener(registration.listener);</span>
<span class="pc bpc" id="L1729" title="1 of 2 branches missed.">        for (ListenerRegistration&lt;GetDataEventListener&gt; registration: peerGetDataEventListeners)</span>
<span class="nc" id="L1730">            peer.removeGetDataEventListener(registration.listener);</span>
<span class="fc bfc" id="L1731" title="All 2 branches covered.">        for (ListenerRegistration&lt;PreMessageReceivedEventListener&gt; registration: peersPreMessageReceivedEventListeners)</span>
<span class="fc" id="L1732">            peer.removePreMessageReceivedEventListener(registration.listener);</span>
<span class="fc bfc" id="L1733" title="All 2 branches covered.">        for (ListenerRegistration&lt;OnTransactionBroadcastListener&gt; registration : peersTransactionBroadastEventListeners)</span>
<span class="fc" id="L1734">            peer.removeOnTransactionBroadcastListener(registration.listener);</span>
<span class="fc bfc" id="L1735" title="All 2 branches covered.">        for (final ListenerRegistration&lt;PeerDisconnectedEventListener&gt; registration : peerDisconnectedEventListeners) {</span>
<span class="fc" id="L1736">            registration.executor.execute(new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1739">                    registration.listener.onPeerDisconnected(peer, fNumConnectedPeers);</span>
<span class="fc" id="L1740">                }</span>
            });
<span class="fc" id="L1742">            peer.removeDisconnectedEventListener(registration.listener);</span>
<span class="fc" id="L1743">        }</span>
<span class="fc" id="L1744">    }</span>

<span class="fc" id="L1746">    @GuardedBy(&quot;lock&quot;) private int stallPeriodSeconds = 10;</span>
<span class="fc" id="L1747">    @GuardedBy(&quot;lock&quot;) private int stallMinSpeedBytesSec = Block.HEADER_SIZE * 20;</span>

    /**
     * Configures the stall speed: the speed at which a peer is considered to be serving us the block chain
     * unacceptably slowly. Once a peer has served us data slower than the given data rate for the given
     * number of seconds, it is considered stalled and will be disconnected, forcing the chain download to continue
     * from a different peer. The defaults are chosen conservatively, but if you are running on a platform that is
     * CPU constrained or on a very slow network e.g. EDGE, the default settings may need adjustment to
     * avoid false stalls.
     *
     * @param periodSecs How many seconds the download speed must be below blocksPerSec, defaults to 10.
     * @param bytesPerSecond Download speed (only blocks/txns count) must be consistently below this for a stall, defaults to the bandwidth required for 20 block headers per second.
     */
    public void setStallThreshold(int periodSecs, int bytesPerSecond) {
<span class="nc" id="L1761">        lock.lock();</span>
        try {
<span class="nc" id="L1763">            stallPeriodSeconds = periodSecs;</span>
<span class="nc" id="L1764">            stallMinSpeedBytesSec = bytesPerSecond;</span>
        } finally {
<span class="nc" id="L1766">            lock.unlock();</span>
<span class="nc" id="L1767">        }</span>
<span class="nc" id="L1768">    }</span>

<span class="fc" id="L1770">    private class ChainDownloadSpeedCalculator implements BlocksDownloadedEventListener, Runnable {</span>
        private int blocksInLastSecond, txnsInLastSecond, origTxnsInLastSecond;
        private long bytesInLastSecond;

        // If we take more stalls than this, we assume we're on some kind of terminally slow network and the
        // stall threshold just isn't set properly. We give up on stall disconnects after that.
<span class="fc" id="L1776">        private int maxStalls = 3;</span>

        // How many seconds the peer has until we start measuring its speed.
<span class="fc" id="L1779">        private int warmupSeconds = -1;</span>

        // Used to calculate a moving average.
        private long[] samples;
        private int cursor;

        private boolean syncDone;

        @Override
        public synchronized void onBlocksDownloaded(Peer peer, Block block, @Nullable FilteredBlock filteredBlock, int blocksLeft) {
<span class="fc" id="L1789">            blocksInLastSecond++;</span>
<span class="fc" id="L1790">            bytesInLastSecond += Block.HEADER_SIZE;</span>
<span class="fc" id="L1791">            List&lt;Transaction&gt; blockTransactions = block.getTransactions();</span>
            // This whole area of the type hierarchy is a mess.
<span class="fc bfc" id="L1793" title="All 4 branches covered.">            int txCount = (blockTransactions != null ? countAndMeasureSize(blockTransactions) : 0) +</span>
<span class="fc" id="L1794">                          (filteredBlock != null ? countAndMeasureSize(filteredBlock.getAssociatedTransactions().values()) : 0);</span>
<span class="fc" id="L1795">            txnsInLastSecond = txnsInLastSecond + txCount;</span>
<span class="fc bfc" id="L1796" title="All 2 branches covered.">            if (filteredBlock != null)</span>
<span class="fc" id="L1797">                origTxnsInLastSecond += filteredBlock.getTransactionCount();</span>
<span class="fc" id="L1798">        }</span>

        private int countAndMeasureSize(Collection&lt;Transaction&gt; transactions) {
<span class="fc bfc" id="L1801" title="All 2 branches covered.">            for (Transaction transaction : transactions)</span>
<span class="fc" id="L1802">                bytesInLastSecond += transaction.getMessageSize();</span>
<span class="fc" id="L1803">            return transactions.size();</span>
        }

        @Override
        public void run() {
            try {
<span class="nc" id="L1809">                calculate();</span>
<span class="nc" id="L1810">            } catch (Throwable e) {</span>
<span class="nc" id="L1811">                log.error(&quot;Error in speed calculator&quot;, e);</span>
<span class="nc" id="L1812">            }</span>
<span class="nc" id="L1813">        }</span>

        private void calculate() {
            int minSpeedBytesPerSec;
            int period;

<span class="nc" id="L1819">            lock.lock();</span>
            try {
<span class="nc" id="L1821">                minSpeedBytesPerSec = stallMinSpeedBytesSec;</span>
<span class="nc" id="L1822">                period = stallPeriodSeconds;</span>
            } finally {
<span class="nc" id="L1824">                lock.unlock();</span>
<span class="nc" id="L1825">            }</span>

<span class="nc" id="L1827">            synchronized (this) {</span>
<span class="nc bnc" id="L1828" title="All 4 branches missed.">                if (samples == null || samples.length != period) {</span>
<span class="nc" id="L1829">                    samples = new long[period];</span>
                    // *2 because otherwise a single low sample could cause an immediate disconnect which is too harsh.
<span class="nc" id="L1831">                    Arrays.fill(samples, minSpeedBytesPerSec * 2);</span>
<span class="nc" id="L1832">                    warmupSeconds = 15;</span>
                }

<span class="nc bnc" id="L1835" title="All 4 branches missed.">                boolean behindPeers = chain != null &amp;&amp; chain.getBestChainHeight() &lt; getMostCommonChainHeight();</span>
<span class="nc bnc" id="L1836" title="All 2 branches missed.">                if (!behindPeers)</span>
<span class="nc" id="L1837">                    syncDone = true;</span>
<span class="nc bnc" id="L1838" title="All 2 branches missed.">                if (!syncDone) {</span>
<span class="nc bnc" id="L1839" title="All 2 branches missed.">                    if (warmupSeconds &lt; 0) {</span>
                        // Calculate the moving average.
<span class="nc" id="L1841">                        samples[cursor++] = bytesInLastSecond;</span>
<span class="nc bnc" id="L1842" title="All 2 branches missed.">                        if (cursor == samples.length) cursor = 0;</span>
<span class="nc" id="L1843">                        long average = 0;</span>
<span class="nc bnc" id="L1844" title="All 2 branches missed.">                        for (long sample : samples) average += sample;</span>
<span class="nc" id="L1845">                        average /= samples.length;</span>

<span class="nc" id="L1847">                        log.info(String.format(Locale.US, &quot;%d blocks/sec, %d tx/sec, %d pre-filtered tx/sec, avg/last %.2f/%.2f kilobytes per sec (stall threshold &lt;%.2f KB/sec for %d seconds)&quot;,</span>
<span class="nc" id="L1848">                                blocksInLastSecond, txnsInLastSecond, origTxnsInLastSecond, average / 1024.0, bytesInLastSecond / 1024.0,</span>
<span class="nc" id="L1849">                                minSpeedBytesPerSec / 1024.0, samples.length));</span>

<span class="nc bnc" id="L1851" title="All 4 branches missed.">                        if (average &lt; minSpeedBytesPerSec &amp;&amp; maxStalls &gt; 0) {</span>
<span class="nc" id="L1852">                            maxStalls--;</span>
<span class="nc bnc" id="L1853" title="All 2 branches missed.">                            if (maxStalls == 0) {</span>
                                // We could consider starting to drop the Bloom filtering FP rate at this point, because
                                // we tried a bunch of peers and no matter what we don't seem to be able to go any faster.
                                // This implies we're bandwidth bottlenecked and might want to start using bandwidth
                                // more effectively. Of course if there's a MITM that is deliberately throttling us,
                                // this is a good way to make us take away all the FPs from our Bloom filters ... but
                                // as they don't give us a whole lot of privacy either way that's not inherently a big
                                // deal.
<span class="nc" id="L1861">                                log.warn(&quot;This network seems to be slower than the requested stall threshold - won't do stall disconnects any more.&quot;);</span>
                            } else {
<span class="nc" id="L1863">                                Peer peer = getDownloadPeer();</span>
<span class="nc" id="L1864">                                log.warn(String.format(Locale.US, &quot;Chain download stalled: received %.2f KB/sec for %d seconds, require average of %.2f KB/sec, disconnecting %s&quot;, average / 1024.0, samples.length, minSpeedBytesPerSec / 1024.0, peer));</span>
<span class="nc" id="L1865">                                peer.close();</span>
                                // Reset the sample buffer and give the next peer time to get going.
<span class="nc" id="L1867">                                samples = null;</span>
<span class="nc" id="L1868">                                warmupSeconds = period;</span>
                            }
                        }
<span class="nc" id="L1871">                    } else {</span>
<span class="nc" id="L1872">                        warmupSeconds--;</span>
<span class="nc bnc" id="L1873" title="All 2 branches missed.">                        if (bytesInLastSecond &gt; 0)</span>
<span class="nc" id="L1874">                            log.info(String.format(Locale.US, &quot;%d blocks/sec, %d tx/sec, %d pre-filtered tx/sec, last %.2f kilobytes per sec&quot;,</span>
<span class="nc" id="L1875">                                    blocksInLastSecond, txnsInLastSecond, origTxnsInLastSecond, bytesInLastSecond / 1024.0));</span>
                    }
                }
<span class="nc" id="L1878">                blocksInLastSecond = 0;</span>
<span class="nc" id="L1879">                txnsInLastSecond = 0;</span>
<span class="nc" id="L1880">                origTxnsInLastSecond = 0;</span>
<span class="nc" id="L1881">                bytesInLastSecond = 0;</span>
<span class="nc" id="L1882">            }</span>
<span class="nc" id="L1883">        }</span>
    }
    @Nullable private ChainDownloadSpeedCalculator chainDownloadSpeedCalculator;

    private void startBlockChainDownloadFromPeer(Peer peer) {
<span class="fc" id="L1888">        lock.lock();</span>
        try {
<span class="fc" id="L1890">            setDownloadPeer(peer);</span>

<span class="fc bfc" id="L1892" title="All 2 branches covered.">            if (chainDownloadSpeedCalculator == null) {</span>
                // Every second, run the calculator which will log how fast we are downloading the chain.
<span class="fc" id="L1894">                chainDownloadSpeedCalculator = new ChainDownloadSpeedCalculator();</span>
<span class="fc" id="L1895">                executor.scheduleAtFixedRate(chainDownloadSpeedCalculator, 1, 1, TimeUnit.SECONDS);</span>
            }
<span class="fc" id="L1897">            peer.addBlocksDownloadedEventListener(Threading.SAME_THREAD, chainDownloadSpeedCalculator);</span>

            // startBlockChainDownload will setDownloadData(true) on itself automatically.
<span class="fc" id="L1900">            peer.startBlockChainDownload();</span>
        } finally {
<span class="pc" id="L1902">            lock.unlock();</span>
<span class="fc" id="L1903">        }</span>
<span class="fc" id="L1904">    }</span>

    /**
     * Returns a future that is triggered when the number of connected peers is equal to the given number of
     * peers. By using this with {@link org.bitcoinj.core.PeerGroup#getMaxConnections()} you can wait until the
     * network is fully online. To block immediately, just call get() on the result. Just calls
     * {@link #waitForPeersOfVersion(int, long)} with zero as the protocol version.
     *
     * @param numPeers How many peers to wait for.
     * @return a future that will be triggered when the number of connected peers &gt;= numPeers
     */
    public ListenableFuture&lt;List&lt;Peer&gt;&gt; waitForPeers(final int numPeers) {
<span class="fc" id="L1916">        return waitForPeersOfVersion(numPeers, 0);</span>
    }

    /**
     * Returns a future that is triggered when there are at least the requested number of connected peers that support
     * the given protocol version or higher. To block immediately, just call get() on the result.
     *
     * @param numPeers How many peers to wait for.
     * @param protocolVersion The protocol version the awaited peers must implement (or better).
     * @return a future that will be triggered when the number of connected peers implementing protocolVersion or higher &gt;= numPeers
     */
    public ListenableFuture&lt;List&lt;Peer&gt;&gt; waitForPeersOfVersion(final int numPeers, final long protocolVersion) {
<span class="fc" id="L1928">        List&lt;Peer&gt; foundPeers = findPeersOfAtLeastVersion(protocolVersion);</span>
<span class="fc bfc" id="L1929" title="All 2 branches covered.">        if (foundPeers.size() &gt;= numPeers) {</span>
<span class="fc" id="L1930">            return Futures.immediateFuture(foundPeers);</span>
        }
<span class="fc" id="L1932">        final SettableFuture&lt;List&lt;Peer&gt;&gt; future = SettableFuture.create();</span>
<span class="fc" id="L1933">        addConnectedEventListener(new PeerConnectedEventListener() {</span>
            @Override
            public void onPeerConnected(Peer peer, int peerCount) {
<span class="fc" id="L1936">                final List&lt;Peer&gt; peers = findPeersOfAtLeastVersion(protocolVersion);</span>
<span class="fc bfc" id="L1937" title="All 2 branches covered.">                if (peers.size() &gt;= numPeers) {</span>
<span class="fc" id="L1938">                    future.set(peers);</span>
<span class="fc" id="L1939">                    removeConnectedEventListener(this);</span>
                }
<span class="fc" id="L1941">            }</span>
        });
<span class="fc" id="L1943">        return future;</span>
    }

    /**
     * Returns an array list of peers that implement the given protocol version or better.
     */
    public List&lt;Peer&gt; findPeersOfAtLeastVersion(long protocolVersion) {
<span class="fc" id="L1950">        lock.lock();</span>
        try {
<span class="fc" id="L1952">            ArrayList&lt;Peer&gt; results = new ArrayList&lt;Peer&gt;(peers.size());</span>
<span class="fc bfc" id="L1953" title="All 2 branches covered.">            for (Peer peer : peers)</span>
<span class="fc bfc" id="L1954" title="All 2 branches covered.">                if (peer.getPeerVersionMessage().clientVersion &gt;= protocolVersion)</span>
<span class="fc" id="L1955">                    results.add(peer);</span>
<span class="fc" id="L1956">            return results;</span>
        } finally {
<span class="pc" id="L1958">            lock.unlock();</span>
        }
    }

    /**
     * Returns a future that is triggered when there are at least the requested number of connected peers that support
     * the given protocol version or higher. To block immediately, just call get() on the result.
     *
     * @param numPeers How many peers to wait for.
     * @param mask An integer representing a bit mask that will be ANDed with the peers advertised service masks.
     * @return a future that will be triggered when the number of connected peers implementing protocolVersion or higher &gt;= numPeers
     */
    public ListenableFuture&lt;List&lt;Peer&gt;&gt; waitForPeersWithServiceMask(final int numPeers, final int mask) {
<span class="fc" id="L1971">        lock.lock();</span>
        try {
<span class="fc" id="L1973">            List&lt;Peer&gt; foundPeers = findPeersWithServiceMask(mask);</span>
<span class="fc bfc" id="L1974" title="All 2 branches covered.">            if (foundPeers.size() &gt;= numPeers)</span>
<span class="fc" id="L1975">                return Futures.immediateFuture(foundPeers);</span>
<span class="fc" id="L1976">            final SettableFuture&lt;List&lt;Peer&gt;&gt; future = SettableFuture.create();</span>
<span class="fc" id="L1977">            addConnectedEventListener(new PeerConnectedEventListener() {</span>
                @Override
                public void onPeerConnected(Peer peer, int peerCount) {
<span class="fc" id="L1980">                    final List&lt;Peer&gt; peers = findPeersWithServiceMask(mask);</span>
<span class="fc bfc" id="L1981" title="All 2 branches covered.">                    if (peers.size() &gt;= numPeers) {</span>
<span class="fc" id="L1982">                        future.set(peers);</span>
<span class="fc" id="L1983">                        removeConnectedEventListener(this);</span>
                    }
<span class="fc" id="L1985">                }</span>
            });
<span class="fc" id="L1987">            return future;</span>
        } finally {
<span class="pc" id="L1989">            lock.unlock();</span>
        }
    }

    /**
     * Returns an array list of peers that match the requested service bit mask.
     */
    public List&lt;Peer&gt; findPeersWithServiceMask(int mask) {
<span class="fc" id="L1997">        lock.lock();</span>
        try {
<span class="fc" id="L1999">            ArrayList&lt;Peer&gt; results = new ArrayList&lt;Peer&gt;(peers.size());</span>
<span class="fc bfc" id="L2000" title="All 2 branches covered.">            for (Peer peer : peers)</span>
<span class="fc bfc" id="L2001" title="All 2 branches covered.">                if ((peer.getPeerVersionMessage().localServices &amp; mask) == mask)</span>
<span class="fc" id="L2002">                    results.add(peer);</span>
<span class="fc" id="L2003">            return results;</span>
        } finally {
<span class="pc" id="L2005">            lock.unlock();</span>
        }
    }

    /**
     * Returns the number of connections that are required before transactions will be broadcast. If there aren't
     * enough, {@link PeerGroup#broadcastTransaction(Transaction)} will wait until the minimum number is reached so
     * propagation across the network can be observed. If no value has been set using
     * {@link PeerGroup#setMinBroadcastConnections(int)} a default of 80% of whatever
     * {@link org.bitcoinj.core.PeerGroup#getMaxConnections()} returns is used.
     */
    public int getMinBroadcastConnections() {
<span class="fc" id="L2017">        lock.lock();</span>
        try {
<span class="pc bpc" id="L2019" title="1 of 2 branches missed.">            if (minBroadcastConnections == 0) {</span>
<span class="nc" id="L2020">                int max = getMaxConnections();</span>
<span class="nc bnc" id="L2021" title="All 2 branches missed.">                if (max &lt;= 1)</span>
<span class="nc" id="L2022">                    return max;</span>
                else
<span class="nc" id="L2024">                    return (int) Math.round(getMaxConnections() * 0.8);</span>
            }
<span class="fc" id="L2026">            return minBroadcastConnections;</span>
        } finally {
<span class="pc" id="L2028">            lock.unlock();</span>
        }
    }

    /**
     * See {@link org.bitcoinj.core.PeerGroup#getMinBroadcastConnections()}.
     */
    public void setMinBroadcastConnections(int value) {
<span class="fc" id="L2036">        lock.lock();</span>
        try {
<span class="fc" id="L2038">            minBroadcastConnections = value;</span>
        } finally {
<span class="pc" id="L2040">            lock.unlock();</span>
<span class="fc" id="L2041">        }</span>
<span class="fc" id="L2042">    }</span>

    /**
     * Calls {@link PeerGroup#broadcastTransaction(Transaction,int)} with getMinBroadcastConnections() as the number
     * of connections to wait for before commencing broadcast.
     */
    @Override
    public TransactionBroadcast broadcastTransaction(final Transaction tx) {
<span class="fc" id="L2050">        return broadcastTransaction(tx, Math.max(1, getMinBroadcastConnections()));</span>
    }

    /**
     * &lt;p&gt;Given a transaction, sends it un-announced to one peer and then waits for it to be received back from other
     * peers. Once all connected peers have announced the transaction, the future available via the
     * {@link org.bitcoinj.core.TransactionBroadcast#future()} method will be completed. If anything goes
     * wrong the exception will be thrown when get() is called, or you can receive it via a callback on the
     * {@link ListenableFuture}. This method returns immediately, so if you want it to block just call get() on the
     * result.&lt;/p&gt;
     *
     * &lt;p&gt;Note that if the PeerGroup is limited to only one connection (discovery is not activated) then the future
     * will complete as soon as the transaction was successfully written to that peer.&lt;/p&gt;
     *
     * &lt;p&gt;The transaction won't be sent until there are at least minConnections active connections available.
     * A good choice for proportion would be between 0.5 and 0.8 but if you want faster transmission during initial
     * bringup of the peer group you can lower it.&lt;/p&gt;
     *
     * &lt;p&gt;The returned {@link org.bitcoinj.core.TransactionBroadcast} object can be used to get progress feedback,
     * which is calculated by watching the transaction propagate across the network and be announced by peers.&lt;/p&gt;
     */
    public TransactionBroadcast broadcastTransaction(final Transaction tx, final int minConnections) {
        // If we don't have a record of where this tx came from already, set it to be ourselves so Peer doesn't end up
        // redownloading it from the network redundantly.
<span class="pc bpc" id="L2074" title="1 of 2 branches missed.">        if (tx.getConfidence().getSource().equals(TransactionConfidence.Source.UNKNOWN)) {</span>
<span class="nc" id="L2075">            log.info(&quot;Transaction source unknown, setting to SELF: {}&quot;, tx.getHashAsString());</span>
<span class="nc" id="L2076">            tx.getConfidence().setSource(TransactionConfidence.Source.SELF);</span>
        }
<span class="fc" id="L2078">        final TransactionBroadcast broadcast = new TransactionBroadcast(this, tx);</span>
<span class="fc" id="L2079">        broadcast.setMinConnections(minConnections);</span>
        // Send the TX to the wallet once we have a successful broadcast.
<span class="fc" id="L2081">        Futures.addCallback(broadcast.future(), new FutureCallback&lt;Transaction&gt;() {</span>
            @Override
            public void onSuccess(Transaction transaction) {
<span class="fc" id="L2084">                runningBroadcasts.remove(broadcast);</span>
                // OK, now tell the wallet about the transaction. If the wallet created the transaction then
                // it already knows and will ignore this. If it's a transaction we received from
                // somebody else via a side channel and are now broadcasting, this will put it into the
                // wallet now we know it's valid.
<span class="fc bfc" id="L2089" title="All 2 branches covered.">                for (Wallet wallet : wallets) {</span>
                    // Assumption here is there are no dependencies of the created transaction.
                    //
                    // We may end up with two threads trying to do this in parallel - the wallet will
                    // ignore whichever one loses the race.
                    try {
<span class="fc" id="L2095">                        wallet.receivePending(transaction, null);</span>
<span class="nc" id="L2096">                    } catch (VerificationException e) {</span>
<span class="nc" id="L2097">                        throw new RuntimeException(e);   // Cannot fail to verify a tx we created ourselves.</span>
<span class="fc" id="L2098">                    }</span>
<span class="fc" id="L2099">                }</span>
<span class="fc" id="L2100">            }</span>

            @Override
            public void onFailure(Throwable throwable) {
                // This can happen if we get a reject message from a peer.
<span class="nc" id="L2105">                runningBroadcasts.remove(broadcast);</span>
<span class="nc" id="L2106">            }</span>
        });
        // Keep a reference to the TransactionBroadcast object. This is important because otherwise, the entire tree
        // of objects we just created would become garbage if the user doesn't hold on to the returned future, and
        // eventually be collected. This in turn could result in the transaction not being committed to the wallet
        // at all.
<span class="fc" id="L2112">        runningBroadcasts.add(broadcast);</span>
<span class="fc" id="L2113">        broadcast.broadcast();</span>
<span class="fc" id="L2114">        return broadcast;</span>
    }

    /**
     * Returns the period between pings for an individual peer. Setting this lower means more accurate and timely ping
     * times are available via {@link org.bitcoinj.core.Peer#getLastPingTime()} but it increases load on the
     * remote node. It defaults to {@link PeerGroup#DEFAULT_PING_INTERVAL_MSEC}.
     */
    public long getPingIntervalMsec() {
<span class="fc" id="L2123">        lock.lock();</span>
        try {
<span class="fc" id="L2125">            return pingIntervalMsec;</span>
        } finally {
<span class="pc" id="L2127">            lock.unlock();</span>
        }
    }

    /**
     * Sets the period between pings for an individual peer. Setting this lower means more accurate and timely ping
     * times are available via {@link org.bitcoinj.core.Peer#getLastPingTime()} but it increases load on the
     * remote node. It defaults to {@link PeerGroup#DEFAULT_PING_INTERVAL_MSEC}.
     * Setting the value to be &lt;= 0 disables pinging entirely, although you can still request one yourself
     * using {@link org.bitcoinj.core.Peer#ping()}.
     */
    public void setPingIntervalMsec(long pingIntervalMsec) {
<span class="fc" id="L2139">        lock.lock();</span>
        try {
<span class="fc" id="L2141">            this.pingIntervalMsec = pingIntervalMsec;</span>
<span class="fc" id="L2142">            ListenableScheduledFuture&lt;?&gt; task = vPingTask;</span>
<span class="pc bpc" id="L2143" title="1 of 2 branches missed.">            if (task != null)</span>
<span class="nc" id="L2144">                task.cancel(false);</span>
<span class="fc" id="L2145">            setupPinging();</span>
        } finally {
<span class="pc" id="L2147">            lock.unlock();</span>
<span class="fc" id="L2148">        }</span>
<span class="fc" id="L2149">    }</span>

    /**
     * If a peer is connected to that claims to speak a protocol version lower than the given version, it will
     * be disconnected and another one will be tried instead.
     */
    public void setMinRequiredProtocolVersion(int minRequiredProtocolVersion) {
<span class="nc" id="L2156">        this.vMinRequiredProtocolVersion = minRequiredProtocolVersion;</span>
<span class="nc" id="L2157">    }</span>

    /** The minimum protocol version required: defaults to the version required for Bloom filtering. */
    public int getMinRequiredProtocolVersion() {
<span class="fc" id="L2161">        return vMinRequiredProtocolVersion;</span>
    }

    /**
     * Returns our peers most commonly reported chain height. If multiple heights are tied, the highest is returned.
     * If no peers are connected, returns zero.
     */
    public int getMostCommonChainHeight() {
<span class="fc" id="L2169">        lock.lock();</span>
        try {
<span class="fc" id="L2171">            return getMostCommonChainHeight(this.peers);</span>
        } finally {
<span class="pc" id="L2173">            lock.unlock();</span>
        }
    }

    /**
     * Returns most commonly reported chain height from the given list of {@link Peer}s.
     * If multiple heights are tied, the highest is returned. If no peers are connected, returns zero.
     */
    public static int getMostCommonChainHeight(final List&lt;Peer&gt; peers) {
<span class="pc bpc" id="L2182" title="1 of 2 branches missed.">        if (peers.isEmpty())</span>
<span class="nc" id="L2183">            return 0;</span>
<span class="fc" id="L2184">        List&lt;Integer&gt; heights = new ArrayList&lt;&gt;(peers.size());</span>
<span class="fc bfc" id="L2185" title="All 2 branches covered.">        for (Peer peer : peers) heights.add((int) peer.getBestHeight());</span>
<span class="fc" id="L2186">        return Utils.maxOfMostFreq(heights);</span>
    }

    /**
     * Given a list of Peers, return a Peer to be used as the download peer. If you don't want PeerGroup to manage
     * download peer statuses for you, just override this and always return null.
     */
    @Nullable
    protected Peer selectDownloadPeer(List&lt;Peer&gt; peers) {
        // Characteristics to select for in order of importance:
        //  - Chain height is reasonable (majority of nodes)
        //  - High enough protocol version for the features we want (but we'll settle for less)
        //  - Randomly, to try and spread the load.
<span class="fc bfc" id="L2199" title="All 2 branches covered.">        if (peers.isEmpty())</span>
<span class="fc" id="L2200">            return null;</span>
        // Make sure we don't select a peer that is behind/synchronizing itself.
<span class="fc" id="L2202">        int mostCommonChainHeight = getMostCommonChainHeight(peers);</span>
<span class="fc" id="L2203">        List&lt;Peer&gt; candidates = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2204" title="All 2 branches covered.">        for (Peer peer : peers) {</span>
<span class="fc bfc" id="L2205" title="All 2 branches covered.">            if (peer.getBestHeight() == mostCommonChainHeight) candidates.add(peer);</span>
<span class="fc" id="L2206">        }</span>
        // Of the candidates, find the peers that meet the minimum protocol version we want to target. We could select
        // the highest version we've seen on the assumption that newer versions are always better but we don't want to
        // zap peers if they upgrade early. If we can't find any peers that have our preferred protocol version or
        // better then we'll settle for the highest we found instead.
<span class="fc" id="L2211">        int highestVersion = 0, preferredVersion = 0;</span>
        // If/when PREFERRED_VERSION is not equal to vMinRequiredProtocolVersion, reenable the last test in PeerGroupTest.downloadPeerSelection
<span class="fc" id="L2213">        final int PREFERRED_VERSION = params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.BLOOM_FILTER);</span>
<span class="fc bfc" id="L2214" title="All 2 branches covered.">        for (Peer peer : candidates) {</span>
<span class="fc" id="L2215">            highestVersion = Math.max(peer.getPeerVersionMessage().clientVersion, highestVersion);</span>
<span class="fc" id="L2216">            preferredVersion = Math.min(highestVersion, PREFERRED_VERSION);</span>
<span class="fc" id="L2217">        }</span>
<span class="fc" id="L2218">        ArrayList&lt;Peer&gt; candidates2 = new ArrayList&lt;&gt;(candidates.size());</span>
<span class="fc bfc" id="L2219" title="All 2 branches covered.">        for (Peer peer : candidates) {</span>
<span class="pc bpc" id="L2220" title="1 of 2 branches missed.">            if (peer.getPeerVersionMessage().clientVersion &gt;= preferredVersion) {</span>
<span class="fc" id="L2221">                candidates2.add(peer);</span>
            }
<span class="fc" id="L2223">        }</span>
<span class="fc" id="L2224">        int index = (int) (Math.random() * candidates2.size());</span>
<span class="fc" id="L2225">        return candidates2.get(index);</span>
    }

    /**
     * Returns the currently selected download peer. Bear in mind that it may have changed as soon as this method
     * returns. Can return null if no peer was selected.
     */
    public Peer getDownloadPeer() {
<span class="fc" id="L2233">        lock.lock();</span>
        try {
<span class="fc" id="L2235">            return downloadPeer;</span>
        } finally {
<span class="pc" id="L2237">            lock.unlock();</span>
        }
    }

    /**
     * Returns the maximum number of {@link Peer}s to discover. This maximum is checked after
     * each {@link PeerDiscovery} so this max number can be surpassed.
     * @return the maximum number of peers to discover
     */
    public int getMaxPeersToDiscoverCount() {
<span class="nc" id="L2247">        return vMaxPeersToDiscoverCount;</span>
    }

    /**
     * Sets the maximum number of {@link Peer}s to discover. This maximum is checked after
     * each {@link PeerDiscovery} so this max number can be surpassed.
     * @param maxPeersToDiscoverCount the maximum number of peers to discover
     */
    public void setMaxPeersToDiscoverCount(int maxPeersToDiscoverCount) {
<span class="fc" id="L2256">        this.vMaxPeersToDiscoverCount = maxPeersToDiscoverCount;</span>
<span class="fc" id="L2257">    }</span>

    /** See {@link #setUseLocalhostPeerWhenPossible(boolean)} */
    public boolean getUseLocalhostPeerWhenPossible() {
<span class="nc" id="L2261">        lock.lock();</span>
        try {
<span class="nc" id="L2263">            return useLocalhostPeerWhenPossible;</span>
        } finally {
<span class="nc" id="L2265">            lock.unlock();</span>
        }
    }

    /**
     * When true (the default), PeerGroup will attempt to connect to a Bitcoin node running on localhost before
     * attempting to use the P2P network. If successful, only localhost will be used. This makes for a simple
     * and easy way for a user to upgrade a bitcoinj based app running in SPV mode to fully validating security.
     */
    public void setUseLocalhostPeerWhenPossible(boolean useLocalhostPeerWhenPossible) {
<span class="fc" id="L2275">        lock.lock();</span>
        try {
<span class="fc" id="L2277">            this.useLocalhostPeerWhenPossible = useLocalhostPeerWhenPossible;</span>
        } finally {
<span class="pc" id="L2279">            lock.unlock();</span>
<span class="fc" id="L2280">        }</span>
<span class="fc" id="L2281">    }</span>

    public boolean isRunning() {
<span class="fc" id="L2284">        return vRunning;</span>
    }

    /**
     * Can be used to disable Bloom filtering entirely, even in SPV mode. You are very unlikely to need this, it is
     * an optimisation for rare cases when full validation is not required but it's still more efficient to download
     * full blocks than filtered blocks.
     */
    public void setBloomFilteringEnabled(boolean bloomFilteringEnabled) {
<span class="nc" id="L2293">        this.vBloomFilteringEnabled = bloomFilteringEnabled;</span>
<span class="nc" id="L2294">    }</span>

    /** Returns whether the Bloom filtering protocol optimisation is in use: defaults to true. */
    public boolean isBloomFilteringEnabled() {
<span class="nc" id="L2298">        return vBloomFilteringEnabled;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>