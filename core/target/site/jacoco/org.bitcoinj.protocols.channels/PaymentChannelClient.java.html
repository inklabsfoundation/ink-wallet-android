<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PaymentChannelClient.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bitcoinj</a> &gt; <a href="index.source.html" class="el_package">org.bitcoinj.protocols.channels</a> &gt; <span class="el_source">PaymentChannelClient.java</span></div><h1>PaymentChannelClient.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013 Google Inc.
 * Copyright 2014 Andreas Schildbach
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bitcoinj.protocols.channels;

import org.bitcoinj.core.*;
import org.bitcoinj.protocols.channels.PaymentChannelCloseException.CloseReason;
import org.bitcoinj.utils.Threading;
import org.bitcoinj.wallet.SendRequest;
import org.bitcoinj.wallet.Wallet;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.MoreExecutors;
import com.google.common.util.concurrent.SettableFuture;
import com.google.protobuf.ByteString;
import net.jcip.annotations.GuardedBy;
import org.bitcoin.paymentchannel.Protos;
import org.slf4j.LoggerFactory;
import org.spongycastle.crypto.params.KeyParameter;

import javax.annotation.Nullable;
import java.util.concurrent.locks.ReentrantLock;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;

/**
 * &lt;p&gt;A class which handles most of the complexity of creating a payment channel connection by providing a
 * simple in/out interface which is provided with protobufs from the server and which generates protobufs which should
 * be sent to the server.&lt;/p&gt;
 *
 * &lt;p&gt;Does all required verification of server messages and properly stores state objects in the wallet-attached
 * {@link StoredPaymentChannelClientStates} so that they are automatically closed when necessary and refund
 * transactions are not lost if the application crashes before it unlocks.&lt;/p&gt;
 *
 * &lt;p&gt;Though this interface is largely designed with stateful protocols (eg simple TCP connections) in mind, it is also
 * possible to use it with stateless protocols (eg sending protobufs when required over HTTP headers). In this case, the
 * &quot;connection&quot; translates roughly into the server-client relationship. See the javadocs for specific functions for more
 * details.&lt;/p&gt;
 */
public class PaymentChannelClient implements IPaymentChannelClient {
<span class="fc" id="L57">    private static final org.slf4j.Logger log = LoggerFactory.getLogger(PaymentChannelClient.class);</span>

<span class="fc" id="L59">    protected final ReentrantLock lock = Threading.lock(&quot;channelclient&quot;);</span>
    protected final ClientChannelProperties clientChannelProperties;

    // Used to track the negotiated version number
    @GuardedBy(&quot;lock&quot;) private int majorVersion;

    @GuardedBy(&quot;lock&quot;) private final ClientConnection conn;

    // Used to keep track of whether or not the &quot;socket&quot; ie connection is open and we can generate messages
<span class="fc" id="L68">    @VisibleForTesting @GuardedBy(&quot;lock&quot;) boolean connectionOpen = false;</span>

    // The state object used to step through initialization and pay the server
    @GuardedBy(&quot;lock&quot;) private PaymentChannelClientState state;

    // The step we are at in initialization, this is partially duplicated in the state object
<span class="pc" id="L74">    private enum InitStep {</span>
<span class="fc" id="L75">        WAITING_FOR_CONNECTION_OPEN,</span>
<span class="fc" id="L76">        WAITING_FOR_VERSION_NEGOTIATION,</span>
<span class="fc" id="L77">        WAITING_FOR_INITIATE,</span>
<span class="fc" id="L78">        WAITING_FOR_REFUND_RETURN,</span>
<span class="fc" id="L79">        WAITING_FOR_CHANNEL_OPEN,</span>
<span class="fc" id="L80">        CHANNEL_OPEN,</span>
<span class="fc" id="L81">        WAITING_FOR_CHANNEL_CLOSE,</span>
<span class="fc" id="L82">        CHANNEL_CLOSED,</span>
    }
<span class="fc" id="L84">    @GuardedBy(&quot;lock&quot;) private InitStep step = InitStep.WAITING_FOR_CONNECTION_OPEN;</span>

<span class="pc" id="L86">    public enum VersionSelector {</span>
<span class="fc" id="L87">        VERSION_1,</span>
<span class="fc" id="L88">        VERSION_2_ALLOW_1,</span>
<span class="fc" id="L89">        VERSION_2;</span>

        public int getRequestedMajorVersion() {
<span class="pc bfc" id="L92" title="All 2 branches covered.">            switch (this) {</span>
                case VERSION_1:
<span class="fc" id="L94">                    return 1;</span>
                case VERSION_2_ALLOW_1:
                case VERSION_2:
                default:
<span class="fc" id="L98">                    return 2;</span>
            }
        }

        public int getRequestedMinorVersion() {
<span class="fc" id="L103">            return 0;</span>
        }

        public boolean isServerVersionAccepted(int major, int minor) {
<span class="pc bpc" id="L107" title="2 of 4 branches missed.">            switch (this) {</span>
                case VERSION_1:
<span class="fc bfc" id="L109" title="All 2 branches covered.">                    return major == 1;</span>
                case VERSION_2_ALLOW_1:
<span class="pc bpc" id="L111" title="1 of 4 branches missed.">                    return major == 1 || major == 2;</span>
                case VERSION_2:
<span class="nc bnc" id="L113" title="All 2 branches missed.">                    return major == 2;</span>
                default:
<span class="nc" id="L115">                    return false;</span>
            }
        }
    }

    private final VersionSelector versionSelector;

    // Will either hold the StoredClientChannel of this channel or null after connectionOpen
    private StoredClientChannel storedChannel;
    // An arbitrary hash which identifies this channel (specified by the API user)
    private final Sha256Hash serverId;

    // The wallet associated with this channel
    private final Wallet wallet;

    // Information used during channel initialization to send to the server or check what the server sends to us
    private final ECKey myKey;
    private final Coin maxValue;

    private Coin missing;

    // key to decrypt myKey, if it is encrypted, during setup.
    private KeyParameter userKeySetup;

    private final long timeWindow;

    @GuardedBy(&quot;lock&quot;) private long minPayment;

    @GuardedBy(&quot;lock&quot;) SettableFuture&lt;PaymentIncrementAck&gt; increasePaymentFuture;
    @GuardedBy(&quot;lock&quot;) Coin lastPaymentActualAmount;

    /**
     * &lt;p&gt;The default maximum amount of time for which we will accept the server locking up our funds for the multisig
     * contract.&lt;/p&gt;
     *
     * &lt;p&gt;24 hours less a minute  is the default as it is expected that clients limit risk exposure by limiting channel size instead of
     * limiting lock time when dealing with potentially malicious servers.&lt;/p&gt;
     */
    public static final long DEFAULT_TIME_WINDOW = 24*60*60-60;

    /**
     * Constructs a new channel manager which waits for {@link PaymentChannelClient#connectionOpen()} before acting.
     * A default time window of {@link #DEFAULT_TIME_WINDOW} will be used.
     *
     * @param wallet The wallet which will be paid from, and where completed transactions will be committed.
     *               Must already have a {@link StoredPaymentChannelClientStates} object in its extensions set.
     * @param myKey A freshly generated keypair used for the multisig contract and refund output.
     * @param maxValue The maximum value the server is allowed to request that we lock into this channel until the
     *                 refund transaction unlocks. Note that if there is a previously open channel, the refund
     *                 transaction used in this channel may be larger than maxValue. Thus, maxValue is not a method for
     *                 limiting the amount payable through this channel.
     * @param serverId An arbitrary hash representing this channel. This must uniquely identify the server. If an
     *                 existing stored channel exists in the wallet's {@link StoredPaymentChannelClientStates}, then an
     *                 attempt will be made to resume that channel.
     * @param conn A callback listener which represents the connection to the server (forwards messages we generate to
     *             the server)
     */
    public PaymentChannelClient(Wallet wallet, ECKey myKey, Coin maxValue, Sha256Hash serverId, ClientConnection conn) {
<span class="nc" id="L173">        this(wallet,myKey,maxValue,serverId, null, conn);</span>
<span class="nc" id="L174">    }</span>

    /**
     * Constructs a new channel manager which waits for {@link PaymentChannelClient#connectionOpen()} before acting.
     *
     * @param wallet The wallet which will be paid from, and where completed transactions will be committed.
     *               Must already have a {@link StoredPaymentChannelClientStates} object in its extensions set.
     * @param myKey A freshly generated keypair used for the multisig contract and refund output.
     * @param maxValue The maximum value the server is allowed to request that we lock into this channel until the
     *                 refund transaction unlocks. Note that if there is a previously open channel, the refund
     *                 transaction used in this channel may be larger than maxValue. Thus, maxValue is not a method for
     *                 limiting the amount payable through this channel.
     * @param serverId An arbitrary hash representing this channel. This must uniquely identify the server. If an
     *                 existing stored channel exists in the wallet's {@link StoredPaymentChannelClientStates}, then an
     *                 attempt will be made to resume that channel.
     * @param userKeySetup Key derived from a user password, used to decrypt myKey, if it is encrypted, during setup.
     * @param conn A callback listener which represents the connection to the server (forwards messages we generate to
     *             the server)
     */
    public PaymentChannelClient(Wallet wallet, ECKey myKey, Coin maxValue, Sha256Hash serverId,
                                @Nullable KeyParameter userKeySetup, ClientConnection conn) {
<span class="nc" id="L195">        this(wallet, myKey, maxValue, serverId, userKeySetup, defaultChannelProperties, conn);</span>
<span class="nc" id="L196">    }</span>

    /**
     * Constructs a new channel manager which waits for {@link PaymentChannelClient#connectionOpen()} before acting.
     *
     * @param wallet The wallet which will be paid from, and where completed transactions will be committed.
     *               Must already have a {@link StoredPaymentChannelClientStates} object in its extensions set.
     * @param myKey A freshly generated keypair used for the multisig contract and refund output.
     * @param maxValue The maximum value the server is allowed to request that we lock into this channel until the
     *                 refund transaction unlocks. Note that if there is a previously open channel, the refund
     *                 transaction used in this channel may be larger than maxValue. Thus, maxValue is not a method for
     *                 limiting the amount payable through this channel.
     * @param serverId An arbitrary hash representing this channel. This must uniquely identify the server. If an
     *                 existing stored channel exists in the wallet's {@link StoredPaymentChannelClientStates}, then an
     *                 attempt will be made to resume that channel.
     * @param userKeySetup Key derived from a user password, used to decrypt myKey, if it is encrypted, during setup.
     * @param clientChannelProperties Modify the channel's properties. You may extend {@link DefaultClientChannelProperties}
     * @param conn A callback listener which represents the connection to the server (forwards messages we generate to
     *             the server)
     */
    public PaymentChannelClient(Wallet wallet, ECKey myKey, Coin maxValue, Sha256Hash serverId,
                                @Nullable KeyParameter userKeySetup, @Nullable ClientChannelProperties clientChannelProperties,
<span class="fc" id="L218">                                ClientConnection conn) {</span>
<span class="fc" id="L219">        this.wallet = checkNotNull(wallet);</span>
<span class="fc" id="L220">        this.myKey = checkNotNull(myKey);</span>
<span class="fc" id="L221">        this.maxValue = checkNotNull(maxValue);</span>
<span class="fc" id="L222">        this.serverId = checkNotNull(serverId);</span>
<span class="fc" id="L223">        this.conn = checkNotNull(conn);</span>
<span class="fc" id="L224">        this.userKeySetup = userKeySetup;</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">        if (clientChannelProperties == null) {</span>
<span class="nc" id="L226">            this.clientChannelProperties = defaultChannelProperties;</span>
        } else {
<span class="fc" id="L228">            this.clientChannelProperties = clientChannelProperties;</span>
        }
<span class="fc" id="L230">        this.timeWindow = clientChannelProperties.timeWindow();</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">        checkState(timeWindow &gt;= 0);</span>
<span class="fc" id="L232">        this.versionSelector = clientChannelProperties.versionSelector();</span>
<span class="fc" id="L233">    }</span>

    /** 
     * &lt;p&gt;Returns the amount of satoshis missing when a server requests too much value.&lt;/p&gt;
     *
     * &lt;p&gt;When InsufficientMoneyException is thrown due to the server requesting too much value, an instance of 
     * PaymentChannelClient needs access to how many satoshis are missing.&lt;/p&gt;
     */
    public Coin getMissing() {
<span class="nc" id="L242">        return missing;</span>
    }

    @Nullable
    @GuardedBy(&quot;lock&quot;)
    private CloseReason receiveInitiate(Protos.Initiate initiate, Coin contractValue, Protos.Error.Builder errorBuilder)
            throws VerificationException, InsufficientMoneyException, ECKey.KeyIsEncryptedException {
<span class="fc" id="L249">        log.info(&quot;Got INITIATE message:\n{}&quot;, initiate.toString());</span>

<span class="pc bpc" id="L251" title="1 of 4 branches missed.">        if (wallet.isEncrypted() &amp;&amp; this.userKeySetup == null)</span>
<span class="nc" id="L252">            throw new ECKey.KeyIsEncryptedException();</span>

<span class="fc" id="L254">        final long expireTime = initiate.getExpireTimeSecs();</span>
<span class="pc bpc" id="L255" title="2 of 4 branches missed.">        checkState( expireTime &gt;= 0 &amp;&amp; initiate.getMinAcceptedChannelSize() &gt;= 0);</span>

<span class="fc bfc" id="L257" title="All 2 branches covered.">        if (! conn.acceptExpireTime(expireTime)) {</span>
<span class="fc" id="L258">            log.error(&quot;Server suggested expire time was out of our allowed bounds: {} ({} s)&quot;, Utils.dateTimeFormat(expireTime * 1000), expireTime);</span>
<span class="fc" id="L259">            errorBuilder.setCode(Protos.Error.ErrorCode.TIME_WINDOW_UNACCEPTABLE);</span>
<span class="fc" id="L260">            return CloseReason.TIME_WINDOW_UNACCEPTABLE;</span>
        }

<span class="fc" id="L263">        Coin minChannelSize = Coin.valueOf(initiate.getMinAcceptedChannelSize());</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">        if (contractValue.compareTo(minChannelSize) &lt; 0) {</span>
<span class="fc" id="L265">            log.error(&quot;Server requested too much value&quot;);</span>
<span class="fc" id="L266">            errorBuilder.setCode(Protos.Error.ErrorCode.CHANNEL_VALUE_TOO_LARGE);</span>
<span class="fc" id="L267">            missing = minChannelSize.subtract(contractValue);</span>
<span class="fc" id="L268">            return CloseReason.SERVER_REQUESTED_TOO_MUCH_VALUE;</span>
        }

        // For now we require a hard-coded value. In future this will have to get more complex and dynamic as the fees
        // start to float.
<span class="fc" id="L273">        final long maxMin = clientChannelProperties.acceptableMinPayment().value;</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">        if (initiate.getMinPayment() &gt; maxMin) {</span>
<span class="nc" id="L275">            log.error(&quot;Server requested a min payment of {} but we only accept up to {}&quot;, initiate.getMinPayment(), maxMin);</span>
<span class="nc" id="L276">            errorBuilder.setCode(Protos.Error.ErrorCode.MIN_PAYMENT_TOO_LARGE);</span>
<span class="nc" id="L277">            errorBuilder.setExpectedValue(maxMin);</span>
<span class="nc" id="L278">            missing = Coin.valueOf(initiate.getMinPayment() - maxMin);</span>
<span class="nc" id="L279">            return CloseReason.SERVER_REQUESTED_TOO_MUCH_VALUE;</span>
        }

<span class="fc" id="L282">        final byte[] pubKeyBytes = initiate.getMultisigKey().toByteArray();</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">        if (!ECKey.isPubKeyCanonical(pubKeyBytes))</span>
<span class="fc" id="L284">            throw new VerificationException(&quot;Server gave us a non-canonical public key, protocol error.&quot;);</span>
<span class="pc bpc" id="L285" title="1 of 3 branches missed.">        switch (majorVersion) {</span>
            case 1:
<span class="fc" id="L287">                state = new PaymentChannelV1ClientState(wallet, myKey, ECKey.fromPublicOnly(pubKeyBytes), contractValue, expireTime);</span>
<span class="fc" id="L288">                break;</span>
            case 2:
<span class="fc" id="L290">                state = new PaymentChannelV2ClientState(wallet, myKey, ECKey.fromPublicOnly(pubKeyBytes), contractValue, expireTime);</span>
<span class="fc" id="L291">                break;</span>
            default:
<span class="nc" id="L293">                return CloseReason.NO_ACCEPTABLE_VERSION;</span>
        }
        try {
<span class="fc" id="L296">            state.initiate(userKeySetup, clientChannelProperties);</span>
<span class="nc" id="L297">        } catch (ValueOutOfRangeException e) {</span>
<span class="nc" id="L298">            log.error(&quot;Value out of range when trying to initiate&quot;, e);</span>
<span class="nc" id="L299">            errorBuilder.setCode(Protos.Error.ErrorCode.CHANNEL_VALUE_TOO_LARGE);</span>
<span class="nc" id="L300">            return CloseReason.SERVER_REQUESTED_TOO_MUCH_VALUE;</span>
<span class="fc" id="L301">        }</span>
<span class="fc" id="L302">        minPayment = initiate.getMinPayment();</span>
<span class="pc bpc" id="L303" title="1 of 3 branches missed.">        switch (majorVersion) {</span>
            case 1:
<span class="fc" id="L305">                step = InitStep.WAITING_FOR_REFUND_RETURN;</span>

<span class="fc" id="L307">                Protos.ProvideRefund.Builder provideRefundBuilder = Protos.ProvideRefund.newBuilder()</span>
<span class="fc" id="L308">                        .setMultisigKey(ByteString.copyFrom(myKey.getPubKey()))</span>
<span class="fc" id="L309">                        .setTx(ByteString.copyFrom(((PaymentChannelV1ClientState)state).getIncompleteRefundTransaction().unsafeBitcoinSerialize()));</span>

<span class="fc" id="L311">                conn.sendToServer(Protos.TwoWayChannelMessage.newBuilder()</span>
<span class="fc" id="L312">                        .setProvideRefund(provideRefundBuilder)</span>
<span class="fc" id="L313">                        .setType(Protos.TwoWayChannelMessage.MessageType.PROVIDE_REFUND)</span>
<span class="fc" id="L314">                        .build());</span>
<span class="fc" id="L315">                break;</span>
            case 2:
<span class="fc" id="L317">                step = InitStep.WAITING_FOR_CHANNEL_OPEN;</span>

                // Before we can send the server the contract (ie send it to the network), we must ensure that our refund
                // transaction is safely in the wallet - thus we store it (this also keeps it up-to-date when we pay)
<span class="fc" id="L321">                state.storeChannelInWallet(serverId);</span>

<span class="fc" id="L323">                Protos.ProvideContract.Builder provideContractBuilder = Protos.ProvideContract.newBuilder()</span>
<span class="fc" id="L324">                        .setTx(ByteString.copyFrom(state.getContract().unsafeBitcoinSerialize()))</span>
<span class="fc" id="L325">                        .setClientKey(ByteString.copyFrom(myKey.getPubKey()));</span>
                try {
                    // Make an initial payment of the dust limit, and put it into the message as well. The size of the
                    // server-requested dust limit was already sanity checked by this point.
<span class="fc" id="L329">                    PaymentChannelClientState.IncrementedPayment payment = state().incrementPaymentBy(Coin.valueOf(minPayment), userKeySetup);</span>
<span class="fc" id="L330">                    Protos.UpdatePayment.Builder initialMsg = provideContractBuilder.getInitialPaymentBuilder();</span>
<span class="fc" id="L331">                    initialMsg.setSignature(ByteString.copyFrom(payment.signature.encodeToBitcoin()));</span>
<span class="fc" id="L332">                    initialMsg.setClientChangeValue(state.getValueRefunded().value);</span>
<span class="nc" id="L333">                } catch (ValueOutOfRangeException e) {</span>
<span class="nc" id="L334">                    throw new IllegalStateException(e);  // This cannot happen.</span>
<span class="fc" id="L335">                }</span>

                // Not used any more
<span class="fc" id="L338">                userKeySetup = null;</span>

<span class="fc" id="L340">                final Protos.TwoWayChannelMessage.Builder msg = Protos.TwoWayChannelMessage.newBuilder();</span>
<span class="fc" id="L341">                msg.setProvideContract(provideContractBuilder);</span>
<span class="fc" id="L342">                msg.setType(Protos.TwoWayChannelMessage.MessageType.PROVIDE_CONTRACT);</span>
<span class="fc" id="L343">                conn.sendToServer(msg.build());</span>
<span class="fc" id="L344">                break;</span>
            default:
<span class="nc" id="L346">                return CloseReason.NO_ACCEPTABLE_VERSION;</span>
        }
<span class="fc" id="L348">        return null;</span>
    }

    @GuardedBy(&quot;lock&quot;)
    private void receiveRefund(Protos.TwoWayChannelMessage refundMsg, @Nullable KeyParameter userKey) throws VerificationException {
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">        checkState(majorVersion == 1);</span>
<span class="pc bpc" id="L354" title="2 of 4 branches missed.">        checkState(step == InitStep.WAITING_FOR_REFUND_RETURN &amp;&amp; refundMsg.hasReturnRefund());</span>
<span class="fc" id="L355">        log.info(&quot;Got RETURN_REFUND message, providing signed contract&quot;);</span>
<span class="fc" id="L356">        Protos.ReturnRefund returnedRefund = refundMsg.getReturnRefund();</span>
        // Cast is safe since we've checked the version number
<span class="fc" id="L358">        ((PaymentChannelV1ClientState)state).provideRefundSignature(returnedRefund.getSignature().toByteArray(), userKey);</span>
<span class="fc" id="L359">        step = InitStep.WAITING_FOR_CHANNEL_OPEN;</span>

        // Before we can send the server the contract (ie send it to the network), we must ensure that our refund
        // transaction is safely in the wallet - thus we store it (this also keeps it up-to-date when we pay)
<span class="fc" id="L363">        state.storeChannelInWallet(serverId);</span>

<span class="fc" id="L365">        Protos.ProvideContract.Builder contractMsg = Protos.ProvideContract.newBuilder()</span>
<span class="fc" id="L366">                .setTx(ByteString.copyFrom(state.getContract().unsafeBitcoinSerialize()));</span>
        try {
            // Make an initial payment of the dust limit, and put it into the message as well. The size of the
            // server-requested dust limit was already sanity checked by this point.
<span class="fc" id="L370">            PaymentChannelClientState.IncrementedPayment payment = state().incrementPaymentBy(Coin.valueOf(minPayment), userKey);</span>
<span class="fc" id="L371">            Protos.UpdatePayment.Builder initialMsg = contractMsg.getInitialPaymentBuilder();</span>
<span class="fc" id="L372">            initialMsg.setSignature(ByteString.copyFrom(payment.signature.encodeToBitcoin()));</span>
<span class="fc" id="L373">            initialMsg.setClientChangeValue(state.getValueRefunded().value);</span>
<span class="nc" id="L374">        } catch (ValueOutOfRangeException e) {</span>
<span class="nc" id="L375">            throw new IllegalStateException(e);  // This cannot happen.</span>
<span class="fc" id="L376">        }</span>

<span class="fc" id="L378">        final Protos.TwoWayChannelMessage.Builder msg = Protos.TwoWayChannelMessage.newBuilder();</span>
<span class="fc" id="L379">        msg.setProvideContract(contractMsg);</span>
<span class="fc" id="L380">        msg.setType(Protos.TwoWayChannelMessage.MessageType.PROVIDE_CONTRACT);</span>
<span class="fc" id="L381">        conn.sendToServer(msg.build());</span>
<span class="fc" id="L382">    }</span>

    @GuardedBy(&quot;lock&quot;)
    private void receiveChannelOpen() throws VerificationException {
<span class="pc bpc" id="L386" title="1 of 6 branches missed.">        checkState(step == InitStep.WAITING_FOR_CHANNEL_OPEN || (step == InitStep.WAITING_FOR_INITIATE &amp;&amp; storedChannel != null), step);</span>
<span class="fc" id="L387">        log.info(&quot;Got CHANNEL_OPEN message, ready to pay&quot;);</span>

<span class="fc" id="L389">        boolean wasInitiated = true;</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">        if (step == InitStep.WAITING_FOR_INITIATE) {</span>
            // We skipped the initiate step, because a previous channel that's still valid was resumed.
<span class="fc" id="L392">            wasInitiated  = false;</span>
<span class="pc bpc" id="L393" title="1 of 3 branches missed.">            switch (majorVersion) {</span>
                case 1:
<span class="fc" id="L395">                    state = new PaymentChannelV1ClientState(storedChannel, wallet);</span>
<span class="fc" id="L396">                    break;</span>
                case 2:
<span class="fc" id="L398">                    state = new PaymentChannelV2ClientState(storedChannel, wallet);</span>
<span class="fc" id="L399">                    break;</span>
                default:
<span class="nc" id="L401">                    throw new IllegalStateException(&quot;Invalid version number &quot; + majorVersion);</span>
            }
        }
<span class="fc" id="L404">        step = InitStep.CHANNEL_OPEN;</span>
        // channelOpen should disable timeouts, but
        // TODO accomodate high latency between PROVIDE_CONTRACT and here
<span class="fc" id="L407">        conn.channelOpen(wasInitiated);</span>
<span class="fc" id="L408">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void receiveMessage(Protos.TwoWayChannelMessage msg) throws InsufficientMoneyException {
<span class="fc" id="L415">        lock.lock();</span>
        try {
<span class="fc" id="L417">            checkState(connectionOpen);</span>
            // If we generate an error, we set errorBuilder and closeReason and break, otherwise we return
            Protos.Error.Builder errorBuilder;
            CloseReason closeReason;
            try {
<span class="pc bfc" id="L422" title="All 8 branches covered.">                switch (msg.getType()) {</span>
                    case SERVER_VERSION:
<span class="pc bpc" id="L424" title="2 of 4 branches missed.">                        checkState(step == InitStep.WAITING_FOR_VERSION_NEGOTIATION &amp;&amp; msg.hasServerVersion());</span>
                        // Server might send back a major version lower than our own if they want to fallback to a
                        // lower version. We can't handle that, so we just close the channel.
<span class="fc" id="L427">                        majorVersion = msg.getServerVersion().getMajor();</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">                        if (!versionSelector.isServerVersionAccepted(majorVersion, msg.getServerVersion().getMinor())) {</span>
<span class="fc" id="L429">                            errorBuilder = Protos.Error.newBuilder()</span>
<span class="fc" id="L430">                                    .setCode(Protos.Error.ErrorCode.NO_ACCEPTABLE_VERSION);</span>
<span class="fc" id="L431">                            closeReason = CloseReason.NO_ACCEPTABLE_VERSION;</span>
<span class="fc" id="L432">                            break;</span>
                        }
<span class="fc" id="L434">                        log.info(&quot;Got version handshake, awaiting INITIATE or resume CHANNEL_OPEN&quot;);</span>
<span class="fc" id="L435">                        step = InitStep.WAITING_FOR_INITIATE;</span>
<span class="fc" id="L436">                        return;</span>
                    case INITIATE:
<span class="pc bpc" id="L438" title="1 of 4 branches missed.">                        checkState(step == InitStep.WAITING_FOR_INITIATE &amp;&amp; msg.hasInitiate());</span>
<span class="fc" id="L439">                        Protos.Initiate initiate = msg.getInitiate();</span>
<span class="fc" id="L440">                        errorBuilder = Protos.Error.newBuilder();</span>
<span class="fc" id="L441">                        closeReason = receiveInitiate(initiate, maxValue, errorBuilder);</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">                        if (closeReason == null)</span>
<span class="fc" id="L443">                            return;</span>
<span class="fc" id="L444">                        log.error(&quot;Initiate failed with error: {}&quot;, errorBuilder.build().toString());</span>
<span class="fc" id="L445">                        break;</span>
                    case RETURN_REFUND:
<span class="fc" id="L447">                        receiveRefund(msg, userKeySetup);</span>
                        // Key not used anymore
<span class="fc" id="L449">                        userKeySetup = null;</span>
<span class="fc" id="L450">                        return;</span>
                    case CHANNEL_OPEN:
<span class="fc" id="L452">                        receiveChannelOpen();</span>
<span class="fc" id="L453">                        return;</span>
                    case PAYMENT_ACK:
<span class="fc" id="L455">                        receivePaymentAck(msg.getPaymentAck());</span>
<span class="fc" id="L456">                        return;</span>
                    case CLOSE:
<span class="fc" id="L458">                        receiveClose(msg);</span>
<span class="fc" id="L459">                        return;</span>
                    case ERROR:
<span class="fc" id="L461">                        checkState(msg.hasError());</span>
<span class="fc" id="L462">                        log.error(&quot;Server sent ERROR {} with explanation {}&quot;, msg.getError().getCode().name(),</span>
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">                                msg.getError().hasExplanation() ? msg.getError().getExplanation() : &quot;&quot;);</span>
<span class="fc" id="L464">                        setIncreasePaymentFutureIfNeeded(CloseReason.REMOTE_SENT_ERROR, msg.getError().getCode().name());</span>
<span class="fc" id="L465">                        conn.destroyConnection(CloseReason.REMOTE_SENT_ERROR);</span>
<span class="fc" id="L466">                        return;</span>
                    default:
<span class="fc" id="L468">                        log.error(&quot;Got unknown message type or type that doesn't apply to clients.&quot;);</span>
<span class="fc" id="L469">                        errorBuilder = Protos.Error.newBuilder()</span>
<span class="fc" id="L470">                                .setCode(Protos.Error.ErrorCode.SYNTAX_ERROR);</span>
<span class="fc" id="L471">                        setIncreasePaymentFutureIfNeeded(CloseReason.REMOTE_SENT_INVALID_MESSAGE, &quot;&quot;);</span>
<span class="fc" id="L472">                        closeReason = CloseReason.REMOTE_SENT_INVALID_MESSAGE;</span>
                        break;
                }
<span class="fc" id="L475">            } catch (VerificationException e) {</span>
<span class="fc" id="L476">                log.error(&quot;Caught verification exception handling message from server&quot;, e);</span>
<span class="fc" id="L477">                errorBuilder = Protos.Error.newBuilder()</span>
<span class="fc" id="L478">                        .setCode(Protos.Error.ErrorCode.BAD_TRANSACTION);</span>
<span class="fc" id="L479">                final String message = e.getMessage();</span>
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">                if (message != null)</span>
<span class="fc" id="L481">                    errorBuilder.setExplanation(message);</span>
<span class="fc" id="L482">                closeReason = CloseReason.REMOTE_SENT_INVALID_MESSAGE;</span>
<span class="fc" id="L483">            } catch (IllegalStateException e) {</span>
<span class="fc" id="L484">                log.error(&quot;Caught illegal state exception handling message from server&quot;, e);</span>
<span class="fc" id="L485">                errorBuilder = Protos.Error.newBuilder()</span>
<span class="fc" id="L486">                        .setCode(Protos.Error.ErrorCode.SYNTAX_ERROR);</span>
<span class="fc" id="L487">                closeReason = CloseReason.REMOTE_SENT_INVALID_MESSAGE;</span>
<span class="fc" id="L488">            }</span>
<span class="fc" id="L489">            conn.sendToServer(Protos.TwoWayChannelMessage.newBuilder()</span>
<span class="fc" id="L490">                    .setError(errorBuilder)</span>
<span class="fc" id="L491">                    .setType(Protos.TwoWayChannelMessage.MessageType.ERROR)</span>
<span class="fc" id="L492">                    .build());</span>
<span class="fc" id="L493">            conn.destroyConnection(closeReason);</span>
        } finally {
<span class="fc" id="L495">            lock.unlock();</span>
<span class="fc" id="L496">        }</span>
<span class="fc" id="L497">    }</span>

    /*
     * If this is an ongoing payment channel increase we need to call setException() on its future.
     *
     * @param reason is the reason for aborting
     * @param message is the detailed message
     */
    private void setIncreasePaymentFutureIfNeeded(PaymentChannelCloseException.CloseReason reason, String message) {
<span class="pc bpc" id="L506" title="1 of 4 branches missed.">        if (increasePaymentFuture != null &amp;&amp; !increasePaymentFuture.isDone()) {</span>
<span class="fc" id="L507">            increasePaymentFuture.setException(new PaymentChannelCloseException(message, reason));</span>
        }
<span class="fc" id="L509">    }</span>

    @GuardedBy(&quot;lock&quot;)
    private void receiveClose(Protos.TwoWayChannelMessage msg) throws VerificationException {
<span class="fc" id="L513">        checkState(lock.isHeldByCurrentThread());</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">        if (msg.hasSettlement()) {</span>
<span class="fc" id="L515">            Transaction settleTx = wallet.getParams().getDefaultSerializer().makeTransaction(msg.getSettlement().getTx().toByteArray());</span>
<span class="fc" id="L516">            log.info(&quot;CLOSE message received with settlement tx {}&quot;, settleTx.getHash());</span>
            // TODO: set source
<span class="pc bpc" id="L518" title="2 of 4 branches missed.">            if (state != null &amp;&amp; state().isSettlementTransaction(settleTx)) {</span>
                // The wallet has a listener on it that the state object will use to do the right thing at this
                // point (like watching it for confirmations). The tx has been checked by now for syntactical validity
                // and that it correctly spends the multisig contract.
<span class="fc" id="L522">                wallet.receivePending(settleTx, null);</span>
            }
<span class="fc" id="L524">        } else {</span>
<span class="fc" id="L525">            log.info(&quot;CLOSE message received without settlement tx&quot;);</span>
        }
<span class="fc bfc" id="L527" title="All 2 branches covered.">        if (step == InitStep.WAITING_FOR_CHANNEL_CLOSE)</span>
<span class="fc" id="L528">            conn.destroyConnection(CloseReason.CLIENT_REQUESTED_CLOSE);</span>
        else
<span class="fc" id="L530">            conn.destroyConnection(CloseReason.SERVER_REQUESTED_CLOSE);</span>
<span class="fc" id="L531">        step = InitStep.CHANNEL_CLOSED;</span>
<span class="fc" id="L532">    }</span>

    /**
     * &lt;p&gt;Called when the connection terminates. Notifies the {@link StoredClientChannel} object that we can attempt to
     * resume this channel in the future and stops generating messages for the server.&lt;/p&gt;
     *
     * &lt;p&gt;For stateless protocols, this translates to a client not using the channel for the immediate future, but
     * intending to reopen the channel later. There is likely little reason to use this in a stateless protocol.&lt;/p&gt;
     *
     * &lt;p&gt;Note that this &lt;b&gt;MUST&lt;/b&gt; still be called even after either
     * {@link org.bitcoinj.protocols.channels.IPaymentChannelClient.ClientConnection#destroyConnection(org.bitcoinj.protocols.channels.PaymentChannelCloseException.CloseReason)} or
     * {@link PaymentChannelClient#settle()} is called, to actually handle the connection close logic.&lt;/p&gt;
     */
    @Override
    public void connectionClosed() {
<span class="fc" id="L547">        lock.lock();</span>
        try {
<span class="fc" id="L549">            connectionOpen = false;</span>
<span class="pc bpc" id="L550" title="1 of 2 branches missed.">            if (state != null)</span>
<span class="fc" id="L551">                state.disconnectFromChannel();</span>
        } finally {
<span class="pc" id="L553">            lock.unlock();</span>
<span class="fc" id="L554">        }</span>
<span class="fc" id="L555">    }</span>

    /**
     * &lt;p&gt;Closes the connection, notifying the server it should settle the channel by broadcasting the most recent
     * payment transaction.&lt;/p&gt;
     *
     * &lt;p&gt;Note that this only generates a CLOSE message for the server and calls
     * {@link org.bitcoinj.protocols.channels.IPaymentChannelClient.ClientConnection#destroyConnection(org.bitcoinj.protocols.channels.PaymentChannelCloseException.CloseReason)} to settle the connection, it does not
     * actually handle connection close logic, and {@link PaymentChannelClient#connectionClosed()} must still be called
     * after the connection fully closes.&lt;/p&gt;
     *
     * @throws IllegalStateException If the connection is not currently open (ie the CLOSE message cannot be sent)
     */
    @Override
    public void settle() throws IllegalStateException {
<span class="fc" id="L570">        lock.lock();</span>
        try {
<span class="fc" id="L572">            checkState(connectionOpen);</span>
<span class="fc" id="L573">            step = InitStep.WAITING_FOR_CHANNEL_CLOSE;</span>
<span class="fc" id="L574">            log.info(&quot;Sending a CLOSE message to the server and waiting for response indicating successful settlement.&quot;);</span>
<span class="fc" id="L575">            conn.sendToServer(Protos.TwoWayChannelMessage.newBuilder()</span>
<span class="fc" id="L576">                    .setType(Protos.TwoWayChannelMessage.MessageType.CLOSE)</span>
<span class="fc" id="L577">                    .build());</span>
        } finally {
<span class="pc" id="L579">            lock.unlock();</span>
<span class="fc" id="L580">        }</span>
<span class="fc" id="L581">    }</span>

    /**
     * &lt;p&gt;Called to indicate the connection has been opened and messages can now be generated for the server.&lt;/p&gt;
     *
     * &lt;p&gt;Attempts to find a channel to resume and generates a CLIENT_VERSION message for the server based on the
     * result.&lt;/p&gt;
     */
    @Override
    public void connectionOpen() {
<span class="fc" id="L591">        lock.lock();</span>
        try {
<span class="fc" id="L593">            connectionOpen = true;</span>

<span class="fc" id="L595">            StoredPaymentChannelClientStates channels = (StoredPaymentChannelClientStates) wallet.getExtensions().get(StoredPaymentChannelClientStates.EXTENSION_ID);</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">            if (channels != null)</span>
<span class="fc" id="L597">                storedChannel = channels.getUsableChannelForServerID(serverId);</span>

<span class="fc" id="L599">            step = InitStep.WAITING_FOR_VERSION_NEGOTIATION;</span>

<span class="fc" id="L601">            Protos.ClientVersion.Builder versionNegotiationBuilder = Protos.ClientVersion.newBuilder()</span>
<span class="fc" id="L602">                    .setMajor(versionSelector.getRequestedMajorVersion())</span>
<span class="fc" id="L603">                    .setMinor(versionSelector.getRequestedMinorVersion())</span>
<span class="fc" id="L604">                    .setTimeWindowSecs(timeWindow);</span>

<span class="fc bfc" id="L606" title="All 2 branches covered.">            if (storedChannel != null) {</span>
<span class="fc" id="L607">                versionNegotiationBuilder.setPreviousChannelContractHash(ByteString.copyFrom(storedChannel.contract.getHash().getBytes()));</span>
<span class="fc" id="L608">                log.info(&quot;Begun version handshake, attempting to reopen channel with contract hash {}&quot;, storedChannel.contract.getHash());</span>
            } else
<span class="fc" id="L610">                log.info(&quot;Begun version handshake creating new channel&quot;);</span>

<span class="fc" id="L612">            conn.sendToServer(Protos.TwoWayChannelMessage.newBuilder()</span>
<span class="fc" id="L613">                    .setType(Protos.TwoWayChannelMessage.MessageType.CLIENT_VERSION)</span>
<span class="fc" id="L614">                    .setClientVersion(versionNegotiationBuilder)</span>
<span class="fc" id="L615">                    .build());</span>
        } finally {
<span class="pc" id="L617">            lock.unlock();</span>
<span class="fc" id="L618">        }</span>
<span class="fc" id="L619">    }</span>

    /**
     * &lt;p&gt;Gets the {@link PaymentChannelClientState} object which stores the current state of the connection with the
     * server.&lt;/p&gt;
     *
     * &lt;p&gt;Note that if you call any methods which update state directly the server will not be notified and channel
     * initialization logic in the connection may fail unexpectedly.&lt;/p&gt;
     */
    public PaymentChannelClientState state() {
<span class="fc" id="L629">        lock.lock();</span>
        try {
<span class="fc" id="L631">            return state;</span>
        } finally {
<span class="pc" id="L633">            lock.unlock();</span>
        }
    }

    /**
     * Increments the total value which we pay the server. Note that the amount of money sent may not be the same as the
     * amount of money actually requested. It can be larger if the amount left over in the channel would be too small to
     * be accepted by the Bitcoin network. ValueOutOfRangeException will be thrown, however, if there's not enough money
     * left in the channel to make the payment at all. Only one payment can be in-flight at once. You have to ensure
     * you wait for the previous increase payment future to complete before incrementing the payment again.
     *
     * @param size How many satoshis to increment the payment by (note: not the new total).
     * @return a future that completes when the server acknowledges receipt and acceptance of the payment.
     * @throws ValueOutOfRangeException If the size is negative or would pay more than this channel's total value
     *                                  ({@link PaymentChannelClientConnection#state()}.getTotalValue())
     * @throws IllegalStateException If the channel has been closed or is not yet open
     *                               (see {@link PaymentChannelClientConnection#getChannelOpenFuture()} for the second)
     */
    public ListenableFuture&lt;PaymentIncrementAck&gt; incrementPayment(Coin size) throws ValueOutOfRangeException, IllegalStateException {
<span class="fc" id="L652">        return incrementPayment(size, null, null);</span>
    }

    /**
     * Increments the total value which we pay the server. Note that the amount of money sent may not be the same as the
     * amount of money actually requested. It can be larger if the amount left over in the channel would be too small to
     * be accepted by the Bitcoin network. ValueOutOfRangeException will be thrown, however, if there's not enough money
     * left in the channel to make the payment at all. Only one payment can be in-flight at once. You have to ensure
     * you wait for the previous increase payment future to complete before incrementing the payment again.
     *
     * @param size How many satoshis to increment the payment by (note: not the new total).
     * @param info Information about this update, used to extend this protocol.
     * @param userKey Key derived from a user password, needed for any signing when the wallet is encrypted.
     *                The wallet KeyCrypter is assumed.
     * @return a future that completes when the server acknowledges receipt and acceptance of the payment.
     * @throws ValueOutOfRangeException If the size is negative or would pay more than this channel's total value
     *                                  ({@link PaymentChannelClientConnection#state()}.getTotalValue())
     * @throws IllegalStateException If the channel has been closed or is not yet open
     *                               (see {@link PaymentChannelClientConnection#getChannelOpenFuture()} for the second)
     * @throws ECKey.KeyIsEncryptedException If the keys are encrypted and no AES key has been provided,
     */
    @Override
    public ListenableFuture&lt;PaymentIncrementAck&gt; incrementPayment(Coin size, @Nullable ByteString info, @Nullable KeyParameter userKey)
            throws ValueOutOfRangeException, IllegalStateException, ECKey.KeyIsEncryptedException {
<span class="fc" id="L676">        lock.lock();</span>
        try {
<span class="pc bpc" id="L678" title="2 of 6 branches missed.">            if (state() == null || !connectionOpen || step != InitStep.CHANNEL_OPEN)</span>
<span class="fc" id="L679">                throw new IllegalStateException(&quot;Channel is not fully initialized/has already been closed&quot;);</span>
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">            if (increasePaymentFuture != null)</span>
<span class="nc" id="L681">                throw new IllegalStateException(&quot;Already incrementing paying, wait for previous payment to complete.&quot;);</span>
<span class="pc bpc" id="L682" title="1 of 4 branches missed.">            if (wallet.isEncrypted() &amp;&amp; userKey == null)</span>
<span class="nc" id="L683">                throw new ECKey.KeyIsEncryptedException();</span>

<span class="fc" id="L685">            PaymentChannelV1ClientState.IncrementedPayment payment = state().incrementPaymentBy(size, userKey);</span>
<span class="fc" id="L686">            Protos.UpdatePayment.Builder updatePaymentBuilder = Protos.UpdatePayment.newBuilder()</span>
<span class="fc" id="L687">                    .setSignature(ByteString.copyFrom(payment.signature.encodeToBitcoin()))</span>
<span class="fc" id="L688">                    .setClientChangeValue(state.getValueRefunded().value);</span>
<span class="fc bfc" id="L689" title="All 2 branches covered.">            if (info != null) updatePaymentBuilder.setInfo(info);</span>

<span class="fc" id="L691">            increasePaymentFuture = SettableFuture.create();</span>
<span class="fc" id="L692">            increasePaymentFuture.addListener(new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L695">                    lock.lock();</span>
<span class="fc" id="L696">                    increasePaymentFuture = null;</span>
<span class="fc" id="L697">                    lock.unlock();</span>
<span class="fc" id="L698">                }</span>
<span class="fc" id="L699">            }, MoreExecutors.directExecutor());</span>

<span class="fc" id="L701">            conn.sendToServer(Protos.TwoWayChannelMessage.newBuilder()</span>
<span class="fc" id="L702">                    .setUpdatePayment(updatePaymentBuilder)</span>
<span class="fc" id="L703">                    .setType(Protos.TwoWayChannelMessage.MessageType.UPDATE_PAYMENT)</span>
<span class="fc" id="L704">                    .build());</span>
<span class="fc" id="L705">            lastPaymentActualAmount = payment.amount;</span>
<span class="fc" id="L706">            return increasePaymentFuture;</span>
        } finally {
<span class="fc" id="L708">            lock.unlock();</span>
        }
    }

    private void receivePaymentAck(Protos.PaymentAck paymentAck) {
        SettableFuture&lt;PaymentIncrementAck&gt; future;
        Coin value;

<span class="fc" id="L716">        lock.lock();</span>
        try {
<span class="pc bpc" id="L718" title="1 of 2 branches missed.">            if (increasePaymentFuture == null) return;</span>
<span class="fc" id="L719">            checkNotNull(increasePaymentFuture, &quot;Server sent a PAYMENT_ACK with no outstanding payment&quot;);</span>
<span class="fc" id="L720">            log.info(&quot;Received a PAYMENT_ACK from the server&quot;);</span>
<span class="fc" id="L721">            future = increasePaymentFuture;</span>
<span class="fc" id="L722">            value = lastPaymentActualAmount;</span>
        } finally {
<span class="pc" id="L724">            lock.unlock();</span>
<span class="fc" id="L725">        }</span>

        // Ensure the future runs without the client lock held.
<span class="fc" id="L728">        future.set(new PaymentIncrementAck(value, paymentAck.getInfo()));</span>
<span class="fc" id="L729">    }</span>

<span class="fc" id="L731">    public static class DefaultClientChannelProperties implements ClientChannelProperties {</span>

        @Override
        public SendRequest modifyContractSendRequest(SendRequest sendRequest) {
<span class="fc" id="L735">            return sendRequest;</span>
        }

        @Override
<span class="fc" id="L739">        public Coin acceptableMinPayment() { return Transaction.REFERENCE_DEFAULT_MIN_TX_FEE; }</span>

        @Override
        public long timeWindow() {
<span class="fc" id="L743">            return DEFAULT_TIME_WINDOW;</span>
        }

        @Override
        public VersionSelector versionSelector() {
<span class="nc" id="L748">            return VersionSelector.VERSION_2_ALLOW_1;</span>
        }

    }

<span class="fc" id="L753">    public static DefaultClientChannelProperties defaultChannelProperties = new DefaultClientChannelProperties();</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>