<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PaymentChannelServer.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bitcoinj</a> &gt; <a href="index.source.html" class="el_package">org.bitcoinj.protocols.channels</a> &gt; <span class="el_source">PaymentChannelServer.java</span></div><h1>PaymentChannelServer.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bitcoinj.protocols.channels;

import com.google.common.collect.ImmutableMap;
import com.google.common.util.concurrent.AsyncFunction;
import org.bitcoinj.core.*;
import org.bitcoinj.protocols.channels.PaymentChannelCloseException.CloseReason;
import org.bitcoinj.utils.Threading;
import org.bitcoinj.wallet.Wallet;

import com.google.common.util.concurrent.FutureCallback;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.protobuf.ByteString;
import net.jcip.annotations.GuardedBy;
import org.bitcoin.paymentchannel.Protos;
import org.slf4j.LoggerFactory;
import org.spongycastle.crypto.params.KeyParameter;

import javax.annotation.Nullable;
import java.util.Map;
import java.util.concurrent.locks.ReentrantLock;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;

/**
 * &lt;p&gt;A handler class which handles most of the complexity of creating a payment channel connection by providing a
 * simple in/out interface which is provided with protobufs from the client and which generates protobufs which should
 * be sent to the client.&lt;/p&gt;
 *
 * &lt;p&gt;Does all required verification of messages and properly stores state objects in the wallet-attached
 * {@link StoredPaymentChannelServerStates} so that they are automatically closed when necessary and payment
 * transactions are not lost if the application crashes before it unlocks.&lt;/p&gt;
 */
public class PaymentChannelServer {
    //TODO: Update JavaDocs with notes for communication over stateless protocols
<span class="fc" id="L53">    private static final org.slf4j.Logger log = LoggerFactory.getLogger(PaymentChannelServer.class);</span>

<span class="fc" id="L55">    protected final ReentrantLock lock = Threading.lock(&quot;channelserver&quot;);</span>

    /**
     * A map of supported versions; keys are major versions, and the corresponding
     * value is the minor version at that major level.
     */
<span class="fc" id="L61">    public static final Map&lt;Integer, Integer&gt; SERVER_VERSIONS = ImmutableMap.of(1, 0, 2, 0);</span>

    // The step in the initialization process we are in, some of this is duplicated in the PaymentChannelServerState
<span class="pc" id="L64">    private enum InitStep {</span>
<span class="fc" id="L65">        WAITING_ON_CLIENT_VERSION,</span>
        // This step is only used in V1 of the protocol.
<span class="fc" id="L67">        WAITING_ON_UNSIGNED_REFUND,</span>
<span class="fc" id="L68">        WAITING_ON_CONTRACT,</span>
<span class="fc" id="L69">        WAITING_ON_MULTISIG_ACCEPTANCE,</span>
<span class="fc" id="L70">        CHANNEL_OPEN</span>
    }
<span class="fc" id="L72">    @GuardedBy(&quot;lock&quot;) private InitStep step = InitStep.WAITING_ON_CLIENT_VERSION;</span>

    /**
     * Implements the connection between this server and the client, providing an interface which allows messages to be
     * sent to the client, requests for the connection to the client to be closed, and callbacks which occur when the
     * channel is fully open or the client completes a payment.
     */
    public interface ServerConnection {
        /**
         * &lt;p&gt;Requests that the given message be sent to the client. There are no blocking requirements for this method,
         * however the order of messages must be preserved.&lt;/p&gt;
         *
         * &lt;p&gt;If the send fails, no exception should be thrown, however
         * {@link PaymentChannelServer#connectionClosed()} should be called immediately.&lt;/p&gt;
         *
         * &lt;p&gt;Called while holding a lock on the {@link PaymentChannelServer} object - be careful about reentrancy&lt;/p&gt;
         */
        void sendToClient(Protos.TwoWayChannelMessage msg);

        /**
         * &lt;p&gt;Requests that the connection to the client be closed&lt;/p&gt;
         *
         * &lt;p&gt;Called while holding a lock on the {@link PaymentChannelServer} object - be careful about reentrancy&lt;/p&gt;
         *
         * @param reason The reason for the closure, see the individual values for more details.
         *               It is usually safe to ignore this value.
         */
        void destroyConnection(CloseReason reason);

        /**
         * &lt;p&gt;Triggered when the channel is opened and payments can begin&lt;/p&gt;
         *
         * &lt;p&gt;Called while holding a lock on the {@link PaymentChannelServer} object - be careful about reentrancy&lt;/p&gt;
         *
         * @param contractHash A unique identifier which represents this channel (actually the hash of the multisig contract)
         */
        void channelOpen(Sha256Hash contractHash);

        /**
         * &lt;p&gt;Called when the payment in this channel was successfully incremented by the client&lt;/p&gt;
         *
         * &lt;p&gt;Called while holding a lock on the {@link PaymentChannelServer} object - be careful about reentrancy&lt;/p&gt;
         *
         * @param by The increase in total payment
         * @param to The new total payment to us (not including fees which may be required to claim the payment)
         * @param info Information about this payment increase, used to extend this protocol.
         * @return A future that completes with the ack message that will be included in the PaymentAck message to the client. Use null for no ack message.
         */
        @Nullable
        ListenableFuture&lt;ByteString&gt; paymentIncrease(Coin by, Coin to, @Nullable ByteString info);

        /**
         * &lt;p&gt;Called when a channel is being closed and must be signed, possibly with an encrypted key.&lt;/p&gt;
         * @return A future for the (nullable) KeyParameter for the ECKey, or &lt;code&gt;null&lt;/code&gt; if no key is required.
         */
        @Nullable
        ListenableFuture&lt;KeyParameter&gt; getUserKey();
    }
    private final ServerConnection conn;

    public interface ServerChannelProperties {
        /**
         * The size of the payment that the client is requested to pay in the initiate phase.
         */
        Coin getMinPayment();

        /**
         * The maximum allowed channel time window in seconds.
         * Note that the server need to be online for the whole time the channel is open.
         * Failure to do this could cause loss of all payments received on the channel.
         */
        long getMaxTimeWindow();

        /**
         * The minimum allowed channel time window in seconds, must be larger than 7200.
         */
        long getMinTimeWindow();
    }

    // Used to track the negotiated version number
    @GuardedBy(&quot;lock&quot;) private int majorVersion;

    // Used to keep track of whether or not the &quot;socket&quot; ie connection is open and we can generate messages
<span class="fc" id="L155">    @GuardedBy(&quot;lock&quot;) private boolean connectionOpen = false;</span>
    // Indicates that no further messages should be sent and we intend to settle the connection
<span class="fc" id="L157">    @GuardedBy(&quot;lock&quot;) private boolean channelSettling = false;</span>

    // The wallet and peergroup which are used to complete/broadcast transactions
    private final Wallet wallet;
    private final TransactionBroadcaster broadcaster;

    // The key used for multisig in this channel
    @GuardedBy(&quot;lock&quot;) private ECKey myKey;

    // The fee server charges for managing (and settling the channel).
    // This is will be requested in the setup via the min_payment field in the initiate message.
    private final Coin minPayment;

    // The minimum accepted channel value
    private final Coin minAcceptedChannelSize;

    // The state manager for this channel
    @GuardedBy(&quot;lock&quot;) private PaymentChannelServerState state;

    // The time this channel expires (ie the refund transaction's locktime)
    @GuardedBy(&quot;lock&quot;) private long expireTime;

    public static final long DEFAULT_MAX_TIME_WINDOW = 7 * 24 * 60 * 60;

    /**
     * Maximum channel duration, in seconds, that the client can request. Defaults to 1 week.
     * Note that the server needs to be online for the whole time the channel is open.
     * Failure to do this could cause loss of all payments received on the channel.
     */
    protected final long maxTimeWindow;

    public static final long DEFAULT_MIN_TIME_WINDOW = 4 * 60 * 60;
    public static final long HARD_MIN_TIME_WINDOW = -StoredPaymentChannelServerStates.CHANNEL_EXPIRE_OFFSET;
    /**
     * Minimum channel duration, in seconds, that the client can request. Should always be larger than  than 2 hours, defaults to 4 hours
     */
    protected final long minTimeWindow;

    /**
     * Creates a new server-side state manager which handles a single client connection. The server will only accept
     * a channel with time window between 4 hours and 1 week. Note that the server need to be online for the whole time the channel is open.
     * Failure to do this could cause loss of all payments received on the channel.
     *
     * @param broadcaster The PeerGroup on which transactions will be broadcast - should have multiple connections.
     * @param wallet The wallet which will be used to complete transactions.
     *               Unlike {@link PaymentChannelClient}, this does not have to already contain a StoredState manager
     * @param minAcceptedChannelSize The minimum value the client must lock into this channel. A value too large will be
     *                               rejected by clients, and a value too low will require excessive channel reopening
     *                               and may cause fees to be require to settle the channel. A reasonable value depends
     *                               entirely on the expected maximum for the channel, and should likely be somewhere
     *                               between a few bitcents and a bitcoin.
     * @param conn A callback listener which represents the connection to the client (forwards messages we generate to
     *             the client and will close the connection on request)
     */
    public PaymentChannelServer(TransactionBroadcaster broadcaster, Wallet wallet,
                                Coin minAcceptedChannelSize, ServerConnection conn) {
<span class="fc" id="L213">        this(broadcaster, wallet, minAcceptedChannelSize, new DefaultServerChannelProperties(), conn);</span>
<span class="fc" id="L214">    }</span>

    /**
     * Creates a new server-side state manager which handles a single client connection.
     *
     * @param broadcaster The PeerGroup on which transactions will be broadcast - should have multiple connections.
     * @param wallet The wallet which will be used to complete transactions.
     *               Unlike {@link PaymentChannelClient}, this does not have to already contain a StoredState manager
     * @param minAcceptedChannelSize The minimum value the client must lock into this channel. A value too large will be
     *                               rejected by clients, and a value too low will require excessive channel reopening
     *                               and may cause fees to be require to settle the channel. A reasonable value depends
     *                               entirely on the expected maximum for the channel, and should likely be somewhere
     *                               between a few bitcents and a bitcoin.
     * @param serverChannelProperties Modify the channel's properties. You may extend {@link DefaultServerChannelProperties}
     * @param conn A callback listener which represents the connection to the client (forwards messages we generate to
     *              the client and will close the connection on request)
     */
    public PaymentChannelServer(TransactionBroadcaster broadcaster, Wallet wallet,
<span class="fc" id="L232">                                Coin minAcceptedChannelSize, ServerChannelProperties serverChannelProperties, ServerConnection conn) {</span>
<span class="fc" id="L233">        minTimeWindow = serverChannelProperties.getMinTimeWindow();</span>
<span class="fc" id="L234">        maxTimeWindow = serverChannelProperties.getMaxTimeWindow();</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">        if (minTimeWindow &gt; maxTimeWindow) throw new IllegalArgumentException(&quot;minTimeWindow must be less or equal to maxTimeWindow&quot;);</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">        if (minTimeWindow &lt; HARD_MIN_TIME_WINDOW) throw new IllegalArgumentException(&quot;minTimeWindow must be larger than&quot; + HARD_MIN_TIME_WINDOW  + &quot; seconds&quot;);</span>
<span class="fc" id="L237">        this.broadcaster = checkNotNull(broadcaster);</span>
<span class="fc" id="L238">        this.wallet = checkNotNull(wallet);</span>
<span class="fc" id="L239">        this.minPayment = checkNotNull(serverChannelProperties.getMinPayment());</span>
<span class="fc" id="L240">        this.minAcceptedChannelSize = checkNotNull(minAcceptedChannelSize);</span>
<span class="fc" id="L241">        this.conn = checkNotNull(conn);</span>
<span class="fc" id="L242">    }</span>

    /**
     * Returns the underlying {@link PaymentChannelServerState} object that is being manipulated. This object allows
     * you to learn how much money has been transferred, etc. May be null if the channel wasn't negotiated yet.
     */
    @Nullable
    public PaymentChannelServerState state() {
<span class="nc" id="L250">        return state;</span>
    }

    @GuardedBy(&quot;lock&quot;)
    private void receiveVersionMessage(Protos.TwoWayChannelMessage msg) throws VerificationException {
<span class="pc bpc" id="L255" title="2 of 4 branches missed.">        checkState(step == InitStep.WAITING_ON_CLIENT_VERSION &amp;&amp; msg.hasClientVersion());</span>
<span class="fc" id="L256">        final Protos.ClientVersion clientVersion = msg.getClientVersion();</span>
<span class="fc" id="L257">        majorVersion = clientVersion.getMajor();</span>
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">        if (!SERVER_VERSIONS.containsKey(majorVersion)) {</span>
<span class="nc" id="L259">            error(&quot;This server needs one of protocol versions &quot; + SERVER_VERSIONS.keySet() + &quot; , client offered &quot; + majorVersion,</span>
                    Protos.Error.ErrorCode.NO_ACCEPTABLE_VERSION, CloseReason.NO_ACCEPTABLE_VERSION);
<span class="nc" id="L261">            return;</span>
        }

<span class="fc" id="L264">        Protos.ServerVersion.Builder versionNegotiationBuilder = Protos.ServerVersion.newBuilder()</span>
<span class="fc" id="L265">                .setMajor(majorVersion).setMinor(SERVER_VERSIONS.get(majorVersion));</span>
<span class="fc" id="L266">        conn.sendToClient(Protos.TwoWayChannelMessage.newBuilder()</span>
<span class="fc" id="L267">                .setType(Protos.TwoWayChannelMessage.MessageType.SERVER_VERSION)</span>
<span class="fc" id="L268">                .setServerVersion(versionNegotiationBuilder)</span>
<span class="fc" id="L269">                .build());</span>
<span class="fc" id="L270">        ByteString reopenChannelContractHash = clientVersion.getPreviousChannelContractHash();</span>
<span class="pc bpc" id="L271" title="1 of 4 branches missed.">        if (reopenChannelContractHash != null &amp;&amp; reopenChannelContractHash.size() == 32) {</span>
<span class="fc" id="L272">            Sha256Hash contractHash = Sha256Hash.wrap(reopenChannelContractHash.toByteArray());</span>
<span class="fc" id="L273">            log.info(&quot;New client that wants to resume {}&quot;, contractHash);</span>
<span class="fc" id="L274">            StoredPaymentChannelServerStates channels = (StoredPaymentChannelServerStates)</span>
<span class="fc" id="L275">                    wallet.getExtensions().get(StoredPaymentChannelServerStates.EXTENSION_ID);</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">            if (channels != null) {</span>
<span class="fc" id="L277">                StoredServerChannel storedServerChannel = channels.getChannel(contractHash);</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">                if (storedServerChannel != null) {</span>
<span class="fc" id="L279">                    final PaymentChannelServer existingHandler = storedServerChannel.setConnectedHandler(this, false);</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">                    if (existingHandler != this) {</span>
<span class="fc" id="L281">                        log.warn(&quot;  ... and that channel is already in use, disconnecting other user.&quot;);</span>
<span class="fc" id="L282">                        existingHandler.close();</span>
<span class="fc" id="L283">                        storedServerChannel.setConnectedHandler(this, true);</span>
                    }

<span class="fc" id="L286">                    log.info(&quot;Got resume version message, responding with VERSIONS and CHANNEL_OPEN&quot;);</span>
<span class="fc" id="L287">                    state = storedServerChannel.getOrCreateState(wallet, broadcaster);</span>
<span class="fc" id="L288">                    step = InitStep.CHANNEL_OPEN;</span>
<span class="fc" id="L289">                    conn.sendToClient(Protos.TwoWayChannelMessage.newBuilder()</span>
<span class="fc" id="L290">                            .setType(Protos.TwoWayChannelMessage.MessageType.CHANNEL_OPEN)</span>
<span class="fc" id="L291">                            .build());</span>
<span class="fc" id="L292">                    conn.channelOpen(contractHash);</span>
<span class="fc" id="L293">                    return;</span>
                } else {
<span class="fc" id="L295">                    log.error(&quot; ... but we do not have any record of that contract! Resume failed.&quot;);</span>
                }
<span class="fc" id="L297">            } else {</span>
<span class="nc" id="L298">                log.error(&quot; ... but we do not have any stored channels! Resume failed.&quot;);</span>
            }
        }
<span class="fc" id="L301">        log.info(&quot;Got initial version message, responding with VERSIONS and INITIATE: min value={}&quot;,</span>
<span class="fc" id="L302">                minAcceptedChannelSize.value);</span>

<span class="fc" id="L304">        myKey = new ECKey();</span>
<span class="fc" id="L305">        wallet.freshReceiveKey();</span>

<span class="fc" id="L307">        expireTime = Utils.currentTimeSeconds() + truncateTimeWindow(clientVersion.getTimeWindowSecs());</span>
<span class="pc bpc" id="L308" title="1 of 3 branches missed.">        switch (majorVersion) {</span>
            case 1:
<span class="fc" id="L310">                step = InitStep.WAITING_ON_UNSIGNED_REFUND;</span>
<span class="fc" id="L311">                break;</span>
            case 2:
<span class="fc" id="L313">                step = InitStep.WAITING_ON_CONTRACT;</span>
<span class="fc" id="L314">                break;</span>
            default:
<span class="nc" id="L316">                error(&quot;Protocol version &quot; + majorVersion + &quot; not supported&quot;, Protos.Error.ErrorCode.NO_ACCEPTABLE_VERSION, CloseReason.NO_ACCEPTABLE_VERSION);</span>
                break;
        }

<span class="fc" id="L320">        Protos.Initiate.Builder initiateBuilder = Protos.Initiate.newBuilder()</span>
<span class="fc" id="L321">                .setMultisigKey(ByteString.copyFrom(myKey.getPubKey()))</span>
<span class="fc" id="L322">                .setExpireTimeSecs(expireTime)</span>
<span class="fc" id="L323">                .setMinAcceptedChannelSize(minAcceptedChannelSize.value)</span>
<span class="fc" id="L324">                .setMinPayment(minPayment.value);</span>

<span class="fc" id="L326">        conn.sendToClient(Protos.TwoWayChannelMessage.newBuilder()</span>
<span class="fc" id="L327">                .setInitiate(initiateBuilder)</span>
<span class="fc" id="L328">                .setType(Protos.TwoWayChannelMessage.MessageType.INITIATE)</span>
<span class="fc" id="L329">                .build());</span>
<span class="fc" id="L330">    }</span>

    private long truncateTimeWindow(long timeWindow) {
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (timeWindow &lt; minTimeWindow) {</span>
<span class="fc" id="L334">            log.info(&quot;client requested time window {} s to short, offering {} s&quot;, timeWindow, minTimeWindow);</span>
<span class="fc" id="L335">            return minTimeWindow;</span>
        }
<span class="fc bfc" id="L337" title="All 2 branches covered.">        if (timeWindow &gt; maxTimeWindow) {</span>
<span class="fc" id="L338">            log.info(&quot;client requested time window {} s to long, offering {} s&quot;, timeWindow, minTimeWindow);</span>
<span class="fc" id="L339">            return maxTimeWindow;</span>
        }
<span class="fc" id="L341">        return timeWindow;</span>
    }

    @GuardedBy(&quot;lock&quot;)
    private void receiveRefundMessage(Protos.TwoWayChannelMessage msg) throws VerificationException {
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">        checkState(majorVersion == 1);</span>
<span class="pc bpc" id="L347" title="2 of 4 branches missed.">        checkState(step == InitStep.WAITING_ON_UNSIGNED_REFUND &amp;&amp; msg.hasProvideRefund());</span>
<span class="fc" id="L348">        log.info(&quot;Got refund transaction, returning signature&quot;);</span>

<span class="fc" id="L350">        Protos.ProvideRefund providedRefund = msg.getProvideRefund();</span>
<span class="fc" id="L351">        state = new PaymentChannelV1ServerState(broadcaster, wallet, myKey, expireTime);</span>
        // We can cast to V1 state since this state is only used in the V1 protocol
<span class="fc" id="L353">        byte[] signature = ((PaymentChannelV1ServerState) state)</span>
<span class="fc" id="L354">                .provideRefundTransaction(wallet.getParams().getDefaultSerializer().makeTransaction(providedRefund.getTx().toByteArray()),</span>
<span class="fc" id="L355">                        providedRefund.getMultisigKey().toByteArray());</span>

<span class="fc" id="L357">        step = InitStep.WAITING_ON_CONTRACT;</span>

<span class="fc" id="L359">        Protos.ReturnRefund.Builder returnRefundBuilder = Protos.ReturnRefund.newBuilder()</span>
<span class="fc" id="L360">                .setSignature(ByteString.copyFrom(signature));</span>

<span class="fc" id="L362">        conn.sendToClient(Protos.TwoWayChannelMessage.newBuilder()</span>
<span class="fc" id="L363">                .setReturnRefund(returnRefundBuilder)</span>
<span class="fc" id="L364">                .setType(Protos.TwoWayChannelMessage.MessageType.RETURN_REFUND)</span>
<span class="fc" id="L365">                .build());</span>
<span class="fc" id="L366">    }</span>

    private void multisigContractPropogated(Protos.ProvideContract providedContract, Sha256Hash contractHash) {
<span class="fc" id="L369">        lock.lock();</span>
        try {
<span class="pc bpc" id="L371" title="2 of 4 branches missed.">            if (!connectionOpen || channelSettling)</span>
<span class="nc" id="L372">                return;</span>
<span class="fc" id="L373">            state.storeChannelInWallet(PaymentChannelServer.this);</span>
            try {
<span class="fc" id="L375">                receiveUpdatePaymentMessage(providedContract.getInitialPayment(), false /* no ack msg */);</span>
<span class="nc" id="L376">            } catch (VerificationException e) {</span>
<span class="nc" id="L377">                log.error(&quot;Initial payment failed to verify&quot;, e);</span>
<span class="nc" id="L378">                error(e.getMessage(), Protos.Error.ErrorCode.BAD_TRANSACTION, CloseReason.REMOTE_SENT_INVALID_MESSAGE);</span>
<span class="nc" id="L379">                return;</span>
<span class="nc" id="L380">            } catch (ValueOutOfRangeException e) {</span>
<span class="nc" id="L381">                log.error(&quot;Initial payment value was out of range&quot;, e);</span>
<span class="nc" id="L382">                error(e.getMessage(), Protos.Error.ErrorCode.BAD_TRANSACTION, CloseReason.REMOTE_SENT_INVALID_MESSAGE);</span>
<span class="nc" id="L383">                return;</span>
<span class="nc" id="L384">            } catch (InsufficientMoneyException e) {</span>
                // This shouldn't happen because the server shouldn't allow itself to get into this situation in the
                // first place, by specifying a min up front payment.
<span class="nc" id="L387">                log.error(&quot;Tried to settle channel and could not afford the fees whilst updating payment&quot;, e);</span>
<span class="nc" id="L388">                error(e.getMessage(), Protos.Error.ErrorCode.BAD_TRANSACTION, CloseReason.REMOTE_SENT_INVALID_MESSAGE);</span>
<span class="nc" id="L389">                return;</span>
<span class="fc" id="L390">            }</span>
<span class="fc" id="L391">            conn.sendToClient(Protos.TwoWayChannelMessage.newBuilder()</span>
<span class="fc" id="L392">                    .setType(Protos.TwoWayChannelMessage.MessageType.CHANNEL_OPEN)</span>
<span class="fc" id="L393">                    .build());</span>
<span class="fc" id="L394">            step = InitStep.CHANNEL_OPEN;</span>
<span class="fc" id="L395">            conn.channelOpen(contractHash);</span>
        } finally {
<span class="pc" id="L397">            lock.unlock();</span>
<span class="fc" id="L398">        }</span>
<span class="fc" id="L399">    }</span>

    @GuardedBy(&quot;lock&quot;)
    private void receiveContractMessage(Protos.TwoWayChannelMessage msg) throws VerificationException {
<span class="pc bpc" id="L403" title="1 of 4 branches missed.">        checkState(majorVersion == 1 || majorVersion == 2);</span>
<span class="pc bpc" id="L404" title="2 of 4 branches missed.">        checkState(step == InitStep.WAITING_ON_CONTRACT &amp;&amp; msg.hasProvideContract());</span>
<span class="fc" id="L405">        log.info(&quot;Got contract, broadcasting and responding with CHANNEL_OPEN&quot;);</span>
<span class="fc" id="L406">        final Protos.ProvideContract providedContract = msg.getProvideContract();</span>

<span class="fc bfc" id="L408" title="All 2 branches covered.">        if (majorVersion == 2) {</span>
<span class="fc" id="L409">            state = new PaymentChannelV2ServerState(broadcaster, wallet, myKey, expireTime);</span>
<span class="fc" id="L410">            checkState(providedContract.hasClientKey(), &quot;ProvideContract didn't have a client key in protocol v2&quot;);</span>
<span class="fc" id="L411">            ((PaymentChannelV2ServerState)state).provideClientKey(providedContract.getClientKey().toByteArray());</span>
        }

        //TODO notify connection handler that timeout should be significantly extended as we wait for network propagation?
<span class="fc" id="L415">        final Transaction contract = wallet.getParams().getDefaultSerializer().makeTransaction(providedContract.getTx().toByteArray());</span>
<span class="fc" id="L416">        step = InitStep.WAITING_ON_MULTISIG_ACCEPTANCE;</span>
<span class="fc" id="L417">        state.provideContract(contract)</span>
<span class="fc" id="L418">                .addListener(new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L421">                        multisigContractPropogated(providedContract, contract.getHash());</span>
<span class="fc" id="L422">                    }</span>
                }, Threading.SAME_THREAD);
<span class="fc" id="L424">    }</span>

    @GuardedBy(&quot;lock&quot;)
    private void receiveUpdatePaymentMessage(Protos.UpdatePayment msg, boolean sendAck) throws VerificationException, ValueOutOfRangeException, InsufficientMoneyException {
<span class="fc" id="L428">        log.info(&quot;Got a payment update&quot;);</span>

<span class="fc" id="L430">        Coin lastBestPayment = state.getBestValueToMe();</span>
<span class="fc" id="L431">        final Coin refundSize = Coin.valueOf(msg.getClientChangeValue());</span>
<span class="fc" id="L432">        boolean stillUsable = state.incrementPayment(refundSize, msg.getSignature().toByteArray());</span>
<span class="fc" id="L433">        Coin bestPaymentChange = state.getBestValueToMe().subtract(lastBestPayment);</span>

<span class="fc" id="L435">        ListenableFuture&lt;ByteString&gt; ackInfoFuture = null;</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">        if (bestPaymentChange.signum() &gt; 0) {</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">            ByteString info = (msg.hasInfo()) ? msg.getInfo() : null;</span>
<span class="fc" id="L438">            ackInfoFuture = conn.paymentIncrease(bestPaymentChange, state.getBestValueToMe(), info);</span>
        }

<span class="fc bfc" id="L441" title="All 2 branches covered.">        if (sendAck) {</span>
<span class="fc" id="L442">            final Protos.TwoWayChannelMessage.Builder ack = Protos.TwoWayChannelMessage.newBuilder();</span>
<span class="fc" id="L443">            ack.setType(Protos.TwoWayChannelMessage.MessageType.PAYMENT_ACK);</span>
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">            if (ackInfoFuture == null) {</span>
<span class="nc" id="L445">                conn.sendToClient(ack.build());</span>
            } else {
<span class="fc" id="L447">                Futures.addCallback(ackInfoFuture, new FutureCallback&lt;ByteString&gt;() {</span>
                    @Override
                    public void onSuccess(@Nullable ByteString result) {
<span class="fc bfc" id="L450" title="All 2 branches covered.">                        if (result != null) ack.setPaymentAck(ack.getPaymentAckBuilder().setInfo(result));</span>
<span class="fc" id="L451">                        conn.sendToClient(ack.build());</span>
<span class="fc" id="L452">                    }</span>

                    @Override
                    public void onFailure(Throwable t) {
<span class="nc" id="L456">                        log.info(&quot;Failed retrieving paymentIncrease info future&quot;);</span>
<span class="nc" id="L457">                        error(&quot;Failed processing payment update&quot;, Protos.Error.ErrorCode.OTHER, CloseReason.UPDATE_PAYMENT_FAILED);</span>
<span class="nc" id="L458">                    }</span>
                });
            }
        }

<span class="fc bfc" id="L463" title="All 2 branches covered.">        if (!stillUsable) {</span>
<span class="fc" id="L464">            log.info(&quot;Channel is now fully exhausted, closing/initiating settlement&quot;);</span>
<span class="fc" id="L465">            settlePayment(CloseReason.CHANNEL_EXHAUSTED);</span>
        }
<span class="fc" id="L467">    }</span>

    /**
     * Called when a message is received from the client. Processes the given message and generates events based on its
     * content.
     */
    public void receiveMessage(Protos.TwoWayChannelMessage msg) {
<span class="fc" id="L474">        lock.lock();</span>
        try {
<span class="fc" id="L476">            checkState(connectionOpen);</span>
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">            if (channelSettling)</span>
<span class="nc" id="L478">                return;</span>
            try {
<span class="pc bpc" id="L480" title="1 of 7 branches missed.">                switch (msg.getType()) {</span>
                    case CLIENT_VERSION:
<span class="fc" id="L482">                        receiveVersionMessage(msg);</span>
<span class="fc" id="L483">                        return;</span>
                    case PROVIDE_REFUND:
<span class="fc" id="L485">                        receiveRefundMessage(msg);</span>
<span class="fc" id="L486">                        return;</span>
                    case PROVIDE_CONTRACT:
<span class="fc" id="L488">                        receiveContractMessage(msg);</span>
<span class="fc" id="L489">                        return;</span>
                    case UPDATE_PAYMENT:
<span class="pc bpc" id="L491" title="2 of 4 branches missed.">                        checkState(step == InitStep.CHANNEL_OPEN &amp;&amp; msg.hasUpdatePayment());</span>
<span class="fc" id="L492">                        receiveUpdatePaymentMessage(msg.getUpdatePayment(), true);</span>
<span class="fc" id="L493">                        return;</span>
                    case CLOSE:
<span class="fc" id="L495">                        receiveCloseMessage();</span>
<span class="fc" id="L496">                        return;</span>
                    case ERROR:
<span class="fc" id="L498">                        checkState(msg.hasError());</span>
<span class="fc" id="L499">                        log.error(&quot;Client sent ERROR {} with explanation {}&quot;, msg.getError().getCode().name(),</span>
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">                                msg.getError().hasExplanation() ? msg.getError().getExplanation() : &quot;&quot;);</span>
<span class="fc" id="L501">                        conn.destroyConnection(CloseReason.REMOTE_SENT_ERROR);</span>
<span class="fc" id="L502">                        return;</span>
                    default:
<span class="nc" id="L504">                        final String errorText = &quot;Got unknown message type or type that doesn't apply to servers.&quot;;</span>
<span class="nc" id="L505">                        error(errorText, Protos.Error.ErrorCode.SYNTAX_ERROR, CloseReason.REMOTE_SENT_INVALID_MESSAGE);</span>
                }
<span class="fc" id="L507">            } catch (VerificationException e) {</span>
<span class="fc" id="L508">                log.error(&quot;Caught verification exception handling message from client&quot;, e);</span>
<span class="fc" id="L509">                error(e.getMessage(), Protos.Error.ErrorCode.BAD_TRANSACTION, CloseReason.REMOTE_SENT_INVALID_MESSAGE);</span>
<span class="nc" id="L510">            } catch (ValueOutOfRangeException e) {</span>
<span class="nc" id="L511">                log.error(&quot;Caught value out of range exception handling message from client&quot;, e);</span>
<span class="nc" id="L512">                error(e.getMessage(), Protos.Error.ErrorCode.BAD_TRANSACTION, CloseReason.REMOTE_SENT_INVALID_MESSAGE);</span>
<span class="nc" id="L513">            } catch (InsufficientMoneyException e) {</span>
<span class="nc" id="L514">                log.error(&quot;Caught insufficient money exception handling message from client&quot;, e);</span>
<span class="nc" id="L515">                error(e.getMessage(), Protos.Error.ErrorCode.BAD_TRANSACTION, CloseReason.REMOTE_SENT_INVALID_MESSAGE);</span>
<span class="nc" id="L516">            } catch (IllegalStateException e) {</span>
<span class="nc" id="L517">                log.error(&quot;Caught illegal state exception handling message from client&quot;, e);</span>
<span class="nc" id="L518">                error(e.getMessage(), Protos.Error.ErrorCode.SYNTAX_ERROR, CloseReason.REMOTE_SENT_INVALID_MESSAGE);</span>
<span class="pc" id="L519">            }</span>
        } finally {
<span class="pc" id="L521">            lock.unlock();</span>
<span class="fc" id="L522">        }</span>
<span class="fc" id="L523">    }</span>

    private void error(String message, Protos.Error.ErrorCode errorCode, CloseReason closeReason) {
<span class="fc" id="L526">        log.error(message);</span>
        Protos.Error.Builder errorBuilder;
<span class="fc" id="L528">        errorBuilder = Protos.Error.newBuilder()</span>
<span class="fc" id="L529">                .setCode(errorCode);</span>
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">        if (message != null)</span>
<span class="fc" id="L531">            errorBuilder.setExplanation(message);</span>
<span class="fc" id="L532">        conn.sendToClient(Protos.TwoWayChannelMessage.newBuilder()</span>
<span class="fc" id="L533">                .setError(errorBuilder)</span>
<span class="fc" id="L534">                .setType(Protos.TwoWayChannelMessage.MessageType.ERROR)</span>
<span class="fc" id="L535">                .build());</span>
<span class="fc" id="L536">        conn.destroyConnection(closeReason);</span>
<span class="fc" id="L537">    }</span>

    @GuardedBy(&quot;lock&quot;)
    private void receiveCloseMessage() throws InsufficientMoneyException {
<span class="fc" id="L541">        log.info(&quot;Got CLOSE message, closing channel&quot;);</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">        if (state != null) {</span>
<span class="fc" id="L543">            settlePayment(CloseReason.CLIENT_REQUESTED_CLOSE);</span>
        } else {
<span class="fc" id="L545">            conn.destroyConnection(CloseReason.CLIENT_REQUESTED_CLOSE);</span>
        }
<span class="fc" id="L547">    }</span>

    @GuardedBy(&quot;lock&quot;)
    private void settlePayment(final CloseReason clientRequestedClose) throws InsufficientMoneyException {
        // Setting channelSettling here prevents us from sending another CLOSE when state.close() calls
        // close() on us here below via the stored channel state.
        // TODO: Strongly separate the lifecycle of the payment channel from the TCP connection in these classes.
<span class="fc" id="L554">        channelSettling = true;</span>
<span class="fc" id="L555">        ListenableFuture&lt;KeyParameter&gt; keyFuture = conn.getUserKey();</span>
        ListenableFuture&lt;Transaction&gt; result;
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">        if (keyFuture != null) {</span>
<span class="nc" id="L558">            result = Futures.transformAsync(conn.getUserKey(), new AsyncFunction&lt;KeyParameter, Transaction&gt;() {</span>
                @Override
                public ListenableFuture&lt;Transaction&gt; apply(KeyParameter userKey) throws Exception {
<span class="nc" id="L561">                    return state.close(userKey);</span>
                }
            });
        } else {
<span class="fc" id="L565">            result = state.close();</span>
        }
<span class="fc" id="L567">        Futures.addCallback(result, new FutureCallback&lt;Transaction&gt;() {</span>
            @Override
            public void onSuccess(Transaction result) {
                // Send the successfully accepted transaction back to the client.
<span class="fc" id="L571">                final Protos.TwoWayChannelMessage.Builder msg = Protos.TwoWayChannelMessage.newBuilder();</span>
<span class="fc" id="L572">                msg.setType(Protos.TwoWayChannelMessage.MessageType.CLOSE);</span>
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">                if (result != null) {</span>
                    // Result can be null on various error paths, like if we never actually opened
                    // properly and so on.
<span class="fc" id="L576">                    msg.getSettlementBuilder().setTx(ByteString.copyFrom(result.unsafeBitcoinSerialize()));</span>
<span class="fc" id="L577">                    log.info(&quot;Sending CLOSE back with broadcast settlement tx.&quot;);</span>
                } else {
<span class="nc" id="L579">                    log.info(&quot;Sending CLOSE back without broadcast settlement tx.&quot;);</span>
                }
<span class="fc" id="L581">                conn.sendToClient(msg.build());</span>
<span class="fc" id="L582">                conn.destroyConnection(clientRequestedClose);</span>
<span class="fc" id="L583">            }</span>

            @Override
            public void onFailure(Throwable t) {
<span class="nc" id="L587">                log.error(&quot;Failed to broadcast settlement tx&quot;, t);</span>
<span class="nc" id="L588">                conn.destroyConnection(clientRequestedClose);</span>
<span class="nc" id="L589">            }</span>
        });
<span class="fc" id="L591">    }</span>

    /**
     * &lt;p&gt;Called when the connection terminates. Notifies the {@link StoredServerChannel} object that we can attempt to
     * resume this channel in the future and stops generating messages for the client.&lt;/p&gt;
     *
     * &lt;p&gt;Note that this &lt;b&gt;MUST&lt;/b&gt; still be called even after either
     * {@link org.bitcoinj.protocols.channels.PaymentChannelServer.ServerConnection#destroyConnection(org.bitcoinj.protocols.channels.PaymentChannelCloseException.CloseReason)} or
     * {@link PaymentChannelServer#close()} is called to actually handle the connection close logic.&lt;/p&gt;
     */
    public void connectionClosed() {
<span class="fc" id="L602">        lock.lock();</span>
        try {
<span class="fc" id="L604">            log.info(&quot;Server channel closed.&quot;);</span>
<span class="fc" id="L605">            connectionOpen = false;</span>

            try {
<span class="pc bpc" id="L608" title="2 of 4 branches missed.">                if (state != null &amp;&amp; state.getContract() != null) {</span>
<span class="fc" id="L609">                    StoredPaymentChannelServerStates channels = (StoredPaymentChannelServerStates)</span>
<span class="fc" id="L610">                            wallet.getExtensions().get(StoredPaymentChannelServerStates.EXTENSION_ID);</span>
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">                    if (channels != null) {</span>
<span class="fc" id="L612">                        StoredServerChannel storedServerChannel = channels.getChannel(state.getContract().getHash());</span>
<span class="fc bfc" id="L613" title="All 2 branches covered.">                        if (storedServerChannel != null) {</span>
<span class="fc" id="L614">                            storedServerChannel.clearConnectedHandler();</span>
                        }
                    }
                }
<span class="nc" id="L618">            } catch (IllegalStateException e) {</span>
                // Expected when we call getContract() sometimes
<span class="fc" id="L620">            }</span>
        } finally {
<span class="pc" id="L622">            lock.unlock();</span>
<span class="fc" id="L623">        }</span>
<span class="fc" id="L624">    }</span>

    /**
     * Called to indicate the connection has been opened and messages can now be generated for the client.
     */
    public void connectionOpen() {
<span class="fc" id="L630">        lock.lock();</span>
        try {
<span class="fc" id="L632">            log.info(&quot;New server channel active.&quot;);</span>
<span class="fc" id="L633">            connectionOpen = true;</span>
        } finally {
<span class="pc" id="L635">            lock.unlock();</span>
<span class="fc" id="L636">        }</span>
<span class="fc" id="L637">    }</span>

    /**
     * &lt;p&gt;Closes the connection by generating a settle message for the client and calls
     * {@link org.bitcoinj.protocols.channels.PaymentChannelServer.ServerConnection#destroyConnection(org.bitcoinj.protocols.channels.PaymentChannelCloseException.CloseReason)}. Note that this does not broadcast
     * the payment transaction and the client may still resume the same channel if they reconnect&lt;/p&gt;
     * &lt;p&gt;
     * &lt;p&gt;Note that {@link PaymentChannelServer#connectionClosed()} must still be called after the connection fully
     * closes.&lt;/p&gt;
     */
    public void close() {
<span class="fc" id="L648">        lock.lock();</span>
        try {
<span class="pc bpc" id="L650" title="1 of 4 branches missed.">            if (connectionOpen &amp;&amp; !channelSettling) {</span>
<span class="fc" id="L651">                final Protos.TwoWayChannelMessage.Builder msg = Protos.TwoWayChannelMessage.newBuilder();</span>
<span class="fc" id="L652">                msg.setType(Protos.TwoWayChannelMessage.MessageType.CLOSE);</span>
<span class="fc" id="L653">                conn.sendToClient(msg.build());</span>
<span class="fc" id="L654">                conn.destroyConnection(CloseReason.SERVER_REQUESTED_CLOSE);</span>
            }
        } finally {
<span class="pc" id="L657">            lock.unlock();</span>
<span class="fc" id="L658">        }</span>
<span class="fc" id="L659">    }</span>

    /**
     * Extend this class and override the values you want to change.
     */
<span class="fc" id="L664">    public static class DefaultServerChannelProperties implements ServerChannelProperties {</span>

        @Override
        public Coin getMinPayment() {
<span class="fc" id="L668">            return Transaction.REFERENCE_DEFAULT_MIN_TX_FEE;</span>
        }

        @Override
        public long getMaxTimeWindow() {
<span class="fc" id="L673">            return DEFAULT_MAX_TIME_WINDOW;</span>
        }

        @Override
        public long getMinTimeWindow() {
<span class="fc" id="L678">            return DEFAULT_MIN_TIME_WINDOW;</span>
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>