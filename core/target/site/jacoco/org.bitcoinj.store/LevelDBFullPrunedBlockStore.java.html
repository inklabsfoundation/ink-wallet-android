<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>LevelDBFullPrunedBlockStore.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bitcoinj</a> &gt; <a href="index.source.html" class="el_package">org.bitcoinj.store</a> &gt; <span class="el_source">LevelDBFullPrunedBlockStore.java</span></div><h1>LevelDBFullPrunedBlockStore.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016 Robin Owens
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bitcoinj.store;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.io.*;
import java.nio.ByteBuffer;

import org.bitcoinj.core.Address;
import org.bitcoinj.core.AddressFormatException;
import org.bitcoinj.core.NetworkParameters;
import org.bitcoinj.core.Sha256Hash;
import org.bitcoinj.core.StoredBlock;
import org.bitcoinj.core.StoredUndoableBlock;
import org.bitcoinj.core.Transaction;
import org.bitcoinj.core.TransactionOutputChanges;
import org.bitcoinj.core.UTXO;
import org.bitcoinj.core.UTXOProviderException;
import org.bitcoinj.core.VerificationException;
import org.bitcoinj.script.Script;
import org.bitcoinj.script.ScriptException;
import org.iq80.leveldb.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static org.fusesource.leveldbjni.JniDBFactory.*;

import com.google.common.base.Stopwatch;
import com.google.common.collect.Lists;

/**
 * &lt;p&gt;
 * An implementation of a Fully Pruned Block Store using a leveldb implementation as the backing data store.
 * &lt;p&gt;
 * 
 * &lt;p&gt;
 * Includes number of caches to optimise the initial blockchain download.
 * &lt;/p&gt;
 */

public class LevelDBFullPrunedBlockStore implements FullPrunedBlockStore {
<span class="fc" id="L64">    private static final Logger log = LoggerFactory.getLogger(LevelDBFullPrunedBlockStore.class);</span>

    NetworkParameters params;

    // LevelDB reference.
<span class="fc" id="L69">    DB db = null;</span>

    // Standard blockstore properties
    protected Sha256Hash chainHeadHash;
    protected StoredBlock chainHeadBlock;
    protected Sha256Hash verifiedChainHeadHash;
    protected StoredBlock verifiedChainHeadBlock;
    protected int fullStoreDepth;
    // Indicates if we track and report runtime for each method
    // this is very useful to focus performance tuning on correct areas.
<span class="fc" id="L79">    protected boolean instrument = false;</span>
    // instrumentation stats
    Stopwatch totalStopwatch;
    protected long hit;
    protected long miss;
    Map&lt;String, Stopwatch&gt; methodStartTime;
    Map&lt;String, Long&gt; methodCalls;
    Map&lt;String, Long&gt; methodTotalTime;
    int exitBlock; // Must be multiple of 1000 and causes code to exit at this
                   // block!
    // ONLY used for performance benchmarking.

    // LRU Cache for getTransactionOutput
    protected Map&lt;ByteBuffer, UTXO&gt; utxoCache;
    // Additional cache to cope with case when transactions are rolled back
    // e.g. when block fails to verify.
    protected Map&lt;ByteBuffer, UTXO&gt; utxoUncommittedCache;
    protected Set&lt;ByteBuffer&gt; utxoUncommittedDeletedCache;

    // Database folder
    protected String filename;

    // Do we auto commit transactions.
<span class="fc" id="L102">    protected boolean autoCommit = true;</span>

    // Datastructures to allow us to search for uncommited inserts/deletes.
    // leveldb does not support dirty reads so we have to
    // do it ourselves.
    Map&lt;ByteBuffer, byte[]&gt; uncommited;
    Set&lt;ByteBuffer&gt; uncommitedDeletes;

    // Sizes of leveldb caches.
    protected long leveldbReadCache;
    protected int leveldbWriteCache;

    // Size of cache for getTransactionOutput
    protected int openOutCache;
    // Bloomfilter for caching calls to hasUnspentOutputs
    protected BloomFilter bloom;

    // Defaults for cache sizes
    static final long LEVELDB_READ_CACHE_DEFAULT = 100 * 1048576; // 100 meg
    static final int LEVELDB_WRITE_CACHE_DEFAULT = 10 * 1048576; // 10 meg
    static final int OPENOUT_CACHE_DEFAULT = 100000;

    // LRUCache
    public class LRUCache extends LinkedHashMap&lt;ByteBuffer, UTXO&gt; {
        private static final long serialVersionUID = 1L;
        private int capacity;

<span class="fc" id="L129">        public LRUCache(int capacity, float loadFactor) {</span>
<span class="fc" id="L130">            super(capacity, loadFactor, true);</span>
<span class="fc" id="L131">            this.capacity = capacity;</span>
<span class="fc" id="L132">        }</span>

        @Override
        protected boolean removeEldestEntry(Map.Entry&lt;ByteBuffer, UTXO&gt; eldest) {
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">            return size() &gt; this.capacity;</span>
        }
    }

    // Simple bloomfilter. We take advantage of fact that a Transaction Hash
    // can be split into 3 30bit numbers that are all random and uncorrelated
    // so ideal to use as the input to a 3 function bloomfilter. No has function
    // needed.
    private class BloomFilter {
        private byte[] cache;
        public long returnedTrue;
        public long returnedFalse;
        public long added;

<span class="fc" id="L150">        public BloomFilter() {</span>
            // 2^27 so since 8 bits in a byte this is
            // 1,073,741,824 bits
<span class="fc" id="L153">            cache = new byte[134217728];</span>
            // This size chosen as with 3 functions we should only get 4% errors
            // with 150m entries.
<span class="fc" id="L156">        }</span>

        // Called to prime cache.
        // Might be idea to call periodically to flush out removed keys.
        // Would need to benchmark 1st though.
        public void reloadCache(DB db) {
            // LevelDB is great at scanning consecutive keys.
            // This take seconds even with 20m keys to add.
<span class="fc" id="L164">            log.info(&quot;Loading Bloom Filter&quot;);</span>
<span class="fc" id="L165">            DBIterator iterator = db.iterator();</span>
<span class="fc" id="L166">            byte[] key = getKey(KeyType.OPENOUT_ALL);</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">            for (iterator.seek(key); iterator.hasNext(); iterator.next()) {</span>
<span class="nc" id="L168">                ByteBuffer bbKey = ByteBuffer.wrap(iterator.peekNext().getKey());</span>
<span class="nc" id="L169">                byte firstByte = bbKey.get(); // remove the KeyType.OPENOUT_ALL</span>
                                              // byte.
<span class="nc bnc" id="L171" title="All 2 branches missed.">                if (key[0] != firstByte) {</span>
<span class="nc" id="L172">                    printStat();</span>
<span class="nc" id="L173">                    return;</span>
                }

<span class="nc" id="L176">                byte[] hash = new byte[32];</span>
<span class="nc" id="L177">                bbKey.get(hash);</span>
<span class="nc" id="L178">                add(hash);</span>
            }
            try {
<span class="fc" id="L181">                iterator.close();</span>
<span class="nc" id="L182">            } catch (IOException e) {</span>
<span class="nc" id="L183">                log.error(&quot;Error closing iterator&quot;, e);</span>
<span class="fc" id="L184">            }</span>
<span class="fc" id="L185">            printStat();</span>
<span class="fc" id="L186">        }</span>

        public void printStat() {
<span class="fc" id="L189">            log.info(&quot;Bloom Added: &quot; + added + &quot; T: &quot; + returnedTrue + &quot; F: &quot; + returnedFalse);</span>
<span class="fc" id="L190">        }</span>

        // Add a txhash to the filter.
        public void add(byte[] hash) {
<span class="fc" id="L194">            byte[] firstHash = new byte[4];</span>
<span class="fc" id="L195">            added++;</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">            for (int i = 0; i &lt; 3; i++) {</span>
<span class="fc" id="L197">                System.arraycopy(hash, i * 4, firstHash, 0, 4);</span>
<span class="fc" id="L198">                setBit(firstHash);</span>
            }
<span class="fc" id="L200">        }</span>

        public void add(Sha256Hash hash) {
<span class="fc" id="L203">            add(hash.getBytes());</span>
<span class="fc" id="L204">        }</span>

        // check if hash was added.
        // if returns false then 100% sure never added
        // if returns true need to check what state is in DB as can
        // not be 100% sure.
        public boolean wasAdded(Sha256Hash hash) {

<span class="fc" id="L212">            byte[] firstHash = new byte[4];</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">            for (int i = 0; i &lt; 3; i++) {</span>
<span class="fc" id="L214">                System.arraycopy(hash.getBytes(), i * 4, firstHash, 0, 4);</span>
<span class="fc" id="L215">                boolean result = getBit(firstHash);</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">                if (!result) {</span>
<span class="fc" id="L217">                    returnedFalse++;</span>
<span class="fc" id="L218">                    return false;</span>
                }
            }
<span class="fc" id="L221">            returnedTrue++;</span>
<span class="fc" id="L222">            return true;</span>
        }

        private void setBit(byte[] entry) {
<span class="fc" id="L226">            int arrayIndex = (entry[0] &amp; 0x3F) &lt;&lt; 21 | (entry[1] &amp; 0xFF) &lt;&lt; 13 | (entry[2] &amp; 0xFF) &lt;&lt; 5</span>
                    | (entry[3] &amp; 0xFF) &gt;&gt; 3;
<span class="fc" id="L228">            int bit = (entry[3] &amp; 0x07);</span>
<span class="fc" id="L229">            int orBit = (0x1 &lt;&lt; bit);</span>
<span class="fc" id="L230">            byte newEntry = (byte) ((int) cache[arrayIndex] | orBit);</span>
<span class="fc" id="L231">            cache[arrayIndex] = newEntry;</span>
<span class="fc" id="L232">        }</span>

        private boolean getBit(byte[] entry) {
<span class="fc" id="L235">            int arrayIndex = (entry[0] &amp; 0x3F) &lt;&lt; 21 | (entry[1] &amp; 0xFF) &lt;&lt; 13 | (entry[2] &amp; 0xFF) &lt;&lt; 5</span>
                    | (entry[3] &amp; 0xFF) &gt;&gt; 3;
<span class="fc" id="L237">            int bit = (entry[3] &amp; 0x07);</span>
<span class="fc" id="L238">            int orBit = (0x1 &lt;&lt; bit);</span>
<span class="fc" id="L239">            byte arrayEntry = cache[arrayIndex];</span>

<span class="fc" id="L241">            int result = arrayEntry &amp; orBit;</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">            if (result == 0) {</span>
<span class="fc" id="L243">                return false;</span>

            } else {
<span class="fc" id="L246">                return true;</span>
            }
        }
    }

    public LevelDBFullPrunedBlockStore(NetworkParameters params, String filename, int blockCount) {
<span class="fc" id="L252">        this(params, filename, blockCount, LEVELDB_READ_CACHE_DEFAULT, LEVELDB_WRITE_CACHE_DEFAULT,</span>
                OPENOUT_CACHE_DEFAULT, false, Integer.MAX_VALUE);
<span class="fc" id="L254">    }</span>

    public LevelDBFullPrunedBlockStore(NetworkParameters params, String filename, int blockCount, long leveldbReadCache,
<span class="fc" id="L257">            int leveldbWriteCache, int openOutCache, boolean instrument, int exitBlock) {</span>
<span class="fc" id="L258">        this.params = params;</span>
<span class="fc" id="L259">        fullStoreDepth = blockCount;</span>
<span class="fc" id="L260">        this.instrument = instrument;</span>
<span class="fc" id="L261">        this.exitBlock = exitBlock;</span>
<span class="fc" id="L262">        methodStartTime = new HashMap&lt;&gt;();</span>
<span class="fc" id="L263">        methodCalls = new HashMap&lt;&gt;();</span>
<span class="fc" id="L264">        methodTotalTime = new HashMap&lt;&gt;();</span>

<span class="fc" id="L266">        this.filename = filename;</span>
<span class="fc" id="L267">        this.leveldbReadCache = leveldbReadCache;</span>
<span class="fc" id="L268">        this.leveldbWriteCache = leveldbWriteCache;</span>
<span class="fc" id="L269">        this.openOutCache = openOutCache;</span>
<span class="fc" id="L270">        bloom = new BloomFilter();</span>
<span class="fc" id="L271">        totalStopwatch = Stopwatch.createStarted();</span>
<span class="fc" id="L272">        openDB();</span>
<span class="fc" id="L273">        bloom.reloadCache(db);</span>

        // Reset after bloom filter loaded
<span class="fc" id="L276">        totalStopwatch = Stopwatch.createStarted();</span>
<span class="fc" id="L277">    }</span>

    private void openDB() {
<span class="fc" id="L280">        Options options = new Options();</span>
<span class="fc" id="L281">        options.createIfMissing(true);</span>
        // options.compressionType(CompressionType.NONE);
<span class="fc" id="L283">        options.cacheSize(leveldbReadCache);</span>
<span class="fc" id="L284">        options.writeBufferSize(leveldbWriteCache);</span>
<span class="fc" id="L285">        options.maxOpenFiles(10000);</span>
        // options.blockSize(1024*1024*50);
        try {
<span class="fc" id="L288">            db = factory.open(new File(filename), options);</span>
<span class="nc" id="L289">        } catch (IOException e) {</span>
<span class="nc" id="L290">            throw new RuntimeException(&quot;Can not open DB&quot;, e);</span>
<span class="fc" id="L291">        }</span>

<span class="fc" id="L293">        utxoCache = new LRUCache(openOutCache, 0.75f);</span>
        try {
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">            if (batchGet(getKey(KeyType.CREATED)) == null) {</span>
<span class="fc" id="L296">                createNewStore(params);</span>
            } else {
<span class="nc" id="L298">                initFromDb();</span>
            }
<span class="nc" id="L300">        } catch (BlockStoreException e) {</span>
<span class="nc" id="L301">            throw new RuntimeException(&quot;Can not init/load db&quot;, e);</span>
<span class="fc" id="L302">        }</span>
<span class="fc" id="L303">    }</span>

    private void initFromDb() throws BlockStoreException {
<span class="nc" id="L306">        Sha256Hash hash = Sha256Hash.wrap(batchGet(getKey(KeyType.CHAIN_HEAD_SETTING)));</span>
<span class="nc" id="L307">        this.chainHeadBlock = get(hash);</span>
<span class="nc" id="L308">        this.chainHeadHash = hash;</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">        if (this.chainHeadBlock == null) {</span>
<span class="nc" id="L310">            throw new BlockStoreException(&quot;corrupt database block store - head block not found&quot;);</span>
        }

<span class="nc" id="L313">        hash = Sha256Hash.wrap(batchGet(getKey(KeyType.VERIFIED_CHAIN_HEAD_SETTING)));</span>
<span class="nc" id="L314">        this.verifiedChainHeadBlock = get(hash);</span>
<span class="nc" id="L315">        this.verifiedChainHeadHash = hash;</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">        if (this.verifiedChainHeadBlock == null) {</span>
<span class="nc" id="L317">            throw new BlockStoreException(&quot;corrupt databse block store - verified head block not found&quot;);</span>
        }
<span class="nc" id="L319">    }</span>

    private void createNewStore(NetworkParameters params) throws BlockStoreException {
        try {
            // Set up the genesis block. When we start out fresh, it is by
            // definition the top of the chain.
<span class="fc" id="L325">            StoredBlock storedGenesisHeader = new StoredBlock(params.getGenesisBlock().cloneAsHeader(),</span>
<span class="fc" id="L326">                    params.getGenesisBlock().getWork(), 0);</span>
            // The coinbase in the genesis block is not spendable. This is
            // because of how the reference client inits
            // its database - the genesis transaction isn't actually in the db
            // so its spent flags can never be updated.
<span class="fc" id="L331">            List&lt;Transaction&gt; genesisTransactions = Lists.newLinkedList();</span>
<span class="fc" id="L332">            StoredUndoableBlock storedGenesis = new StoredUndoableBlock(params.getGenesisBlock().getHash(),</span>
                    genesisTransactions);
<span class="fc" id="L334">            beginDatabaseBatchWrite();</span>
<span class="fc" id="L335">            put(storedGenesisHeader, storedGenesis);</span>
<span class="fc" id="L336">            setChainHead(storedGenesisHeader);</span>
<span class="fc" id="L337">            setVerifiedChainHead(storedGenesisHeader);</span>
<span class="fc" id="L338">            batchPut(getKey(KeyType.CREATED), bytes(&quot;done&quot;));</span>
<span class="fc" id="L339">            commitDatabaseBatchWrite();</span>
<span class="nc" id="L340">        } catch (VerificationException e) {</span>
<span class="nc" id="L341">            throw new RuntimeException(e); // Cannot happen.</span>
<span class="fc" id="L342">        }</span>
<span class="fc" id="L343">    }</span>

    void beginMethod(String name) {
<span class="nc" id="L346">        methodStartTime.put(name, Stopwatch.createStarted());</span>
<span class="nc" id="L347">    }</span>

    void endMethod(String name) {
<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (methodCalls.containsKey(name)) {</span>
<span class="nc" id="L351">            methodCalls.put(name, methodCalls.get(name) + 1);</span>
<span class="nc" id="L352">            methodTotalTime.put(name,</span>
<span class="nc" id="L353">                    methodTotalTime.get(name) + methodStartTime.get(name).elapsed(TimeUnit.NANOSECONDS));</span>
        } else {
<span class="nc" id="L355">            methodCalls.put(name, 1l);</span>
<span class="nc" id="L356">            methodTotalTime.put(name, methodStartTime.get(name).elapsed(TimeUnit.NANOSECONDS));</span>
        }
<span class="nc" id="L358">    }</span>

    // Debug method to display stats on runtime of each method
    // and cache hit rates etc..
    void dumpStats() {
<span class="nc" id="L363">        long wallTimeNanos = totalStopwatch.elapsed(TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L364">        long dbtime = 0;</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">        for (String name : methodCalls.keySet()) {</span>
<span class="nc" id="L366">            long calls = methodCalls.get(name);</span>
<span class="nc" id="L367">            long time = methodTotalTime.get(name);</span>
<span class="nc" id="L368">            dbtime += time;</span>
<span class="nc" id="L369">            long average = time / calls;</span>
<span class="nc" id="L370">            double proportion = (time + 0.0) / (wallTimeNanos + 0.0);</span>
<span class="nc" id="L371">            log.info(name + &quot; c:&quot; + calls + &quot; r:&quot; + time + &quot; a:&quot; + average + &quot; p:&quot; + String.format(&quot;%.2f&quot;, proportion));</span>
<span class="nc" id="L372">        }</span>
<span class="nc" id="L373">        double dbproportion = (dbtime + 0.0) / (wallTimeNanos + 0.0);</span>
<span class="nc" id="L374">        double hitrate = (hit + 0.0) / (hit + miss + 0.0);</span>
<span class="nc" id="L375">        log.info(&quot;Cache size:&quot; + utxoCache.size() + &quot; hit:&quot; + hit + &quot; miss:&quot; + miss + &quot; rate:&quot;</span>
<span class="nc" id="L376">                + String.format(&quot;%.2f&quot;, hitrate));</span>
<span class="nc" id="L377">        bloom.printStat();</span>
<span class="nc" id="L378">        log.info(&quot;hasTxOut call:&quot; + hasCall + &quot; True:&quot; + hasTrue + &quot; False:&quot; + hasFalse);</span>
<span class="nc" id="L379">        log.info(&quot;Wall:&quot; + totalStopwatch + &quot; percent:&quot; + String.format(&quot;%.2f&quot;, dbproportion));</span>
<span class="nc" id="L380">        String stats = db.getProperty(&quot;leveldb.stats&quot;);</span>
<span class="nc" id="L381">        System.out.println(stats);</span>

<span class="nc" id="L383">    }</span>

    @Override
    public void put(StoredBlock block) throws BlockStoreException {
<span class="nc" id="L387">        putUpdateStoredBlock(block, false);</span>
<span class="nc" id="L388">    }</span>

    @Override
    public StoredBlock getChainHead() throws BlockStoreException {
<span class="fc" id="L392">        return chainHeadBlock;</span>
    }

    @Override
    public void setChainHead(StoredBlock chainHead) throws BlockStoreException {
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">        if (instrument)</span>
<span class="nc" id="L398">            beginMethod(&quot;setChainHead&quot;);</span>
<span class="fc" id="L399">        Sha256Hash hash = chainHead.getHeader().getHash();</span>
<span class="fc" id="L400">        this.chainHeadHash = hash;</span>
<span class="fc" id="L401">        this.chainHeadBlock = chainHead;</span>
<span class="fc" id="L402">        batchPut(getKey(KeyType.CHAIN_HEAD_SETTING), hash.getBytes());</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">        if (instrument)</span>
<span class="nc" id="L404">            endMethod(&quot;setChainHead&quot;);</span>
<span class="fc" id="L405">    }</span>

    @Override
    public void close() throws BlockStoreException {
        try {
<span class="fc" id="L410">            db.close();</span>
<span class="nc" id="L411">        } catch (IOException e) {</span>
<span class="nc" id="L412">            throw new BlockStoreException(&quot;Could not close db&quot;, e);</span>
<span class="fc" id="L413">        }</span>
<span class="fc" id="L414">    }</span>

    @Override
    public NetworkParameters getParams() {
<span class="fc" id="L418">        return params;</span>
    }

    @Override
    public List&lt;UTXO&gt; getOpenTransactionOutputs(List&lt;Address&gt; addresses) throws UTXOProviderException {
        // Run this on a snapshot of database so internally consistent result
        // This is critical or if one address paid another could get incorrect
        // results

<span class="fc" id="L427">        List&lt;UTXO&gt; results = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">        for (Address a : addresses) {</span>
<span class="fc" id="L429">            ByteBuffer bb = ByteBuffer.allocate(21);</span>
<span class="fc" id="L430">            bb.put((byte) KeyType.ADDRESS_HASHINDEX.ordinal());</span>
<span class="fc" id="L431">            bb.put(a.getHash160());</span>

<span class="fc" id="L433">            ReadOptions ro = new ReadOptions();</span>
<span class="fc" id="L434">            Snapshot sn = db.getSnapshot();</span>
<span class="fc" id="L435">            ro.snapshot(sn);</span>

            // Scanning over iterator very fast

<span class="fc" id="L439">            DBIterator iterator = db.iterator(ro);</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">            for (iterator.seek(bb.array()); iterator.hasNext(); iterator.next()) {</span>
<span class="fc" id="L441">                ByteBuffer bbKey = ByteBuffer.wrap(iterator.peekNext().getKey());</span>
<span class="fc" id="L442">                bbKey.get(); // remove the address_hashindex byte.</span>
<span class="fc" id="L443">                byte[] addressKey = new byte[20];</span>
<span class="fc" id="L444">                bbKey.get(addressKey);</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">                if (!Arrays.equals(addressKey, a.getHash160())) {</span>
<span class="fc" id="L446">                    break;</span>
                }
<span class="fc" id="L448">                byte[] hashBytes = new byte[32];</span>
<span class="fc" id="L449">                bbKey.get(hashBytes);</span>
<span class="fc" id="L450">                int index = bbKey.getInt();</span>
<span class="fc" id="L451">                Sha256Hash hash = Sha256Hash.wrap(hashBytes);</span>
                UTXO txout;
                try {
                    // TODO this should be on the SNAPSHOT too......
                    // this is really a BUG.
<span class="fc" id="L456">                    txout = getTransactionOutput(hash, index);</span>
<span class="nc" id="L457">                } catch (BlockStoreException e) {</span>
<span class="nc" id="L458">                    throw new UTXOProviderException(&quot;block store execption&quot;, e);</span>
<span class="fc" id="L459">                }</span>
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">                if (txout != null) {</span>
<span class="fc" id="L461">                    Script sc = txout.getScript();</span>
<span class="fc" id="L462">                    Address address = sc.getToAddress(params, true);</span>
<span class="fc" id="L463">                    UTXO output = new UTXO(txout.getHash(), txout.getIndex(), txout.getValue(), txout.getHeight(),</span>
<span class="fc" id="L464">                            txout.isCoinbase(), txout.getScript(), address.toString());</span>
<span class="fc" id="L465">                    results.add(output);</span>
                }
            }
            try {
<span class="fc" id="L469">                iterator.close();</span>
<span class="fc" id="L470">                ro = null;</span>
<span class="fc" id="L471">                sn.close();</span>
<span class="fc" id="L472">                sn = null;</span>
<span class="nc" id="L473">            } catch (IOException e) {</span>
<span class="nc" id="L474">                log.error(&quot;Error closing snapshot/iterator?&quot;, e);</span>
<span class="fc" id="L475">            }</span>
<span class="fc" id="L476">        }</span>
<span class="fc" id="L477">        return results;</span>
    }

    @Override
    public int getChainHeadHeight() throws UTXOProviderException {
        try {
<span class="fc" id="L483">            return getVerifiedChainHead().getHeight();</span>
<span class="nc" id="L484">        } catch (BlockStoreException e) {</span>
<span class="nc" id="L485">            throw new UTXOProviderException(e);</span>
        }
    }

    protected void putUpdateStoredBlock(StoredBlock storedBlock, boolean wasUndoable) {
        // We put as one record as then the get is much faster.
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">        if (instrument)</span>
<span class="nc" id="L492">            beginMethod(&quot;putUpdateStoredBlock&quot;);</span>
<span class="fc" id="L493">        Sha256Hash hash = storedBlock.getHeader().getHash();</span>
<span class="fc" id="L494">        ByteBuffer bb = ByteBuffer.allocate(97);</span>
<span class="fc" id="L495">        storedBlock.serializeCompact(bb);</span>
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">        bb.put((byte) (wasUndoable ? 1 : 0));</span>
<span class="fc" id="L497">        batchPut(getKey(KeyType.HEADERS_ALL, hash), bb.array());</span>
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">        if (instrument)</span>
<span class="nc" id="L499">            endMethod(&quot;putUpdateStoredBlock&quot;);</span>
<span class="fc" id="L500">    }</span>

    @Override
    public void put(StoredBlock storedBlock, StoredUndoableBlock undoableBlock) throws BlockStoreException {
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">        if (instrument)</span>
<span class="nc" id="L505">            beginMethod(&quot;put&quot;);</span>
<span class="fc" id="L506">        int height = storedBlock.getHeight();</span>
<span class="fc" id="L507">        byte[] transactions = null;</span>
<span class="fc" id="L508">        byte[] txOutChanges = null;</span>
        try {
<span class="fc" id="L510">            ByteArrayOutputStream bos = new ByteArrayOutputStream();</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">            if (undoableBlock.getTxOutChanges() != null) {</span>
<span class="fc" id="L512">                undoableBlock.getTxOutChanges().serializeToStream(bos);</span>
<span class="fc" id="L513">                txOutChanges = bos.toByteArray();</span>
            } else {
<span class="fc" id="L515">                int numTxn = undoableBlock.getTransactions().size();</span>
<span class="fc" id="L516">                bos.write((int) (0xFF &amp; (numTxn &gt;&gt; 0)));</span>
<span class="fc" id="L517">                bos.write((int) (0xFF &amp; (numTxn &gt;&gt; 8)));</span>
<span class="fc" id="L518">                bos.write((int) (0xFF &amp; (numTxn &gt;&gt; 16)));</span>
<span class="fc" id="L519">                bos.write((int) (0xFF &amp; (numTxn &gt;&gt; 24)));</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">                for (Transaction tx : undoableBlock.getTransactions())</span>
<span class="fc" id="L521">                    tx.bitcoinSerialize(bos);</span>
<span class="fc" id="L522">                transactions = bos.toByteArray();</span>
            }
<span class="fc" id="L524">            bos.close();</span>
<span class="nc" id="L525">        } catch (IOException e) {</span>
<span class="nc" id="L526">            throw new BlockStoreException(e);</span>
<span class="fc" id="L527">        }</span>

<span class="fc" id="L529">        Sha256Hash hash = storedBlock.getHeader().getHash();</span>

<span class="fc" id="L531">        ByteBuffer keyBuf = ByteBuffer.allocate(33);</span>
<span class="fc" id="L532">        keyBuf.put((byte) KeyType.HEIGHT_UNDOABLEBLOCKS.ordinal());</span>
<span class="fc" id="L533">        keyBuf.putInt(height);</span>
<span class="fc" id="L534">        keyBuf.put(hash.getBytes(), 4, 28);</span>
<span class="fc" id="L535">        batchPut(keyBuf.array(), new byte[1]);</span>

<span class="fc bfc" id="L537" title="All 2 branches covered.">        if (transactions == null) {</span>
<span class="fc" id="L538">            ByteBuffer undoBuf = ByteBuffer.allocate(4 + 4 + txOutChanges.length + 4 + 0);</span>
<span class="fc" id="L539">            undoBuf.putInt(height);</span>
<span class="fc" id="L540">            undoBuf.putInt(txOutChanges.length);</span>
<span class="fc" id="L541">            undoBuf.put(txOutChanges);</span>
<span class="fc" id="L542">            undoBuf.putInt(0);</span>
<span class="fc" id="L543">            batchPut(getKey(KeyType.UNDOABLEBLOCKS_ALL, hash), undoBuf.array());</span>
<span class="fc" id="L544">        } else {</span>
<span class="fc" id="L545">            ByteBuffer undoBuf = ByteBuffer.allocate(4 + 4 + 0 + 4 + transactions.length);</span>
<span class="fc" id="L546">            undoBuf.putInt(height);</span>
<span class="fc" id="L547">            undoBuf.putInt(0);</span>
<span class="fc" id="L548">            undoBuf.putInt(transactions.length);</span>
<span class="fc" id="L549">            undoBuf.put(transactions);</span>
<span class="fc" id="L550">            batchPut(getKey(KeyType.UNDOABLEBLOCKS_ALL, hash), undoBuf.array());</span>
        }
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">        if (instrument)</span>
<span class="nc" id="L553">            endMethod(&quot;put&quot;);</span>
<span class="fc" id="L554">        putUpdateStoredBlock(storedBlock, true);</span>
<span class="fc" id="L555">    }</span>

    // Since LevelDB is a key value store we do not have &quot;tables&quot;.
    // So these keys are the 1st byte of each key to indicate the &quot;table&quot; it is
    // in.
    // Do wonder if grouping each &quot;table&quot; like this is efficient or not...
<span class="pc" id="L561">    enum KeyType {</span>
<span class="fc" id="L562">        CREATED, CHAIN_HEAD_SETTING, VERIFIED_CHAIN_HEAD_SETTING, VERSION_SETTING, HEADERS_ALL, UNDOABLEBLOCKS_ALL, HEIGHT_UNDOABLEBLOCKS, OPENOUT_ALL, ADDRESS_HASHINDEX</span>
    }

    // These helpers just get the key for an input
    private byte[] getKey(KeyType keytype) {
<span class="fc" id="L567">        byte[] key = new byte[1];</span>
<span class="fc" id="L568">        key[0] = (byte) keytype.ordinal();</span>
<span class="fc" id="L569">        return key;</span>
    }

    private byte[] getTxKey(KeyType keytype, Sha256Hash hash) {
<span class="fc" id="L573">        byte[] key = new byte[33];</span>

<span class="fc" id="L575">        key[0] = (byte) keytype.ordinal();</span>
<span class="fc" id="L576">        System.arraycopy(hash.getBytes(), 0, key, 1, 32);</span>
<span class="fc" id="L577">        return key;</span>
    }

    private byte[] getTxKey(KeyType keytype, Sha256Hash hash, int index) {
<span class="fc" id="L581">        byte[] key = new byte[37];</span>

<span class="fc" id="L583">        key[0] = (byte) keytype.ordinal();</span>
<span class="fc" id="L584">        System.arraycopy(hash.getBytes(), 0, key, 1, 32);</span>
<span class="fc" id="L585">        byte[] heightBytes = ByteBuffer.allocate(4).putInt(index).array();</span>
<span class="fc" id="L586">        System.arraycopy(heightBytes, 0, key, 33, 4);</span>
<span class="fc" id="L587">        return key;</span>
    }

    private byte[] getKey(KeyType keytype, Sha256Hash hash) {
<span class="fc" id="L591">        byte[] key = new byte[29];</span>

<span class="fc" id="L593">        key[0] = (byte) keytype.ordinal();</span>
<span class="fc" id="L594">        System.arraycopy(hash.getBytes(), 4, key, 1, 28);</span>
<span class="fc" id="L595">        return key;</span>
    }

    private byte[] getKey(KeyType keytype, byte[] hash) {
<span class="fc" id="L599">        byte[] key = new byte[29];</span>

<span class="fc" id="L601">        key[0] = (byte) keytype.ordinal();</span>
<span class="fc" id="L602">        System.arraycopy(hash, 4, key, 1, 28);</span>
<span class="fc" id="L603">        return key;</span>
    }

    @Override
    public StoredBlock getOnceUndoableStoredBlock(Sha256Hash hash) throws BlockStoreException {
<span class="fc" id="L608">        return get(hash, true);</span>
    }

    @Override
    public StoredBlock get(Sha256Hash hash) throws BlockStoreException {
<span class="fc" id="L613">        return get(hash, false);</span>
    }

    public StoredBlock get(Sha256Hash hash, boolean wasUndoableOnly) throws BlockStoreException {

        // Optimize for chain head
<span class="pc bpc" id="L619" title="1 of 4 branches missed.">        if (chainHeadHash != null &amp;&amp; chainHeadHash.equals(hash))</span>
<span class="fc" id="L620">            return chainHeadBlock;</span>
<span class="pc bpc" id="L621" title="2 of 4 branches missed.">        if (verifiedChainHeadHash != null &amp;&amp; verifiedChainHeadHash.equals(hash))</span>
<span class="nc" id="L622">            return verifiedChainHeadBlock;</span>

<span class="pc bpc" id="L624" title="1 of 2 branches missed.">        if (instrument)</span>
<span class="nc" id="L625">            beginMethod(&quot;get&quot;);// ignore optimised case as not interesting for</span>
                               // tuning.
        boolean undoableResult;

<span class="fc" id="L629">        byte[] result = batchGet(getKey(KeyType.HEADERS_ALL, hash));</span>
<span class="fc bfc" id="L630" title="All 2 branches covered.">        if (result == null) {</span>
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">            if (instrument)</span>
<span class="nc" id="L632">                endMethod(&quot;get&quot;);</span>
<span class="fc" id="L633">            return null;</span>
        }
<span class="pc bpc" id="L635" title="1 of 2 branches missed.">        undoableResult = (result[96] == 1 ? true : false);</span>
<span class="pc bpc" id="L636" title="1 of 4 branches missed.">        if (wasUndoableOnly &amp;&amp; !undoableResult) {</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">            if (instrument)</span>
<span class="nc" id="L638">                endMethod(&quot;get&quot;);</span>
<span class="nc" id="L639">            return null;</span>
        }
        // TODO Should I chop the last byte off? Seems to work with it left
        // there...
<span class="fc" id="L643">        StoredBlock stored = StoredBlock.deserializeCompact(params, ByteBuffer.wrap(result));</span>
<span class="fc" id="L644">        stored.getHeader().verifyHeader();</span>

<span class="pc bpc" id="L646" title="1 of 2 branches missed.">        if (instrument)</span>
<span class="nc" id="L647">            endMethod(&quot;get&quot;);</span>
<span class="fc" id="L648">        return stored;</span>
    }

    @Override
    public StoredUndoableBlock getUndoBlock(Sha256Hash hash) throws BlockStoreException {
        try {
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">            if (instrument)</span>
<span class="nc" id="L655">                beginMethod(&quot;getUndoBlock&quot;);</span>

<span class="fc" id="L657">            byte[] result = batchGet(getKey(KeyType.UNDOABLEBLOCKS_ALL, hash));</span>

<span class="pc bpc" id="L659" title="1 of 2 branches missed.">            if (result == null) {</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">                if (instrument)</span>
<span class="nc" id="L661">                    endMethod(&quot;getUndoBlock&quot;);</span>
<span class="nc" id="L662">                return null;</span>
            }
<span class="fc" id="L664">            ByteBuffer bb = ByteBuffer.wrap(result);</span>
<span class="fc" id="L665">            bb.getInt();// TODO Read height - but seems to be unused - maybe can</span>
                        // skip storing it but only 4 bytes!
<span class="fc" id="L667">            int txOutSize = bb.getInt();</span>

            StoredUndoableBlock block;
<span class="fc bfc" id="L670" title="All 2 branches covered.">            if (txOutSize == 0) {</span>
<span class="fc" id="L671">                int txSize = bb.getInt();</span>
<span class="fc" id="L672">                byte[] transactions = new byte[txSize];</span>
<span class="fc" id="L673">                bb.get(transactions);</span>
<span class="fc" id="L674">                int offset = 0;</span>
<span class="fc" id="L675">                int numTxn = ((transactions[offset++] &amp; 0xFF) &lt;&lt; 0) | ((transactions[offset++] &amp; 0xFF) &lt;&lt; 8)</span>
                        | ((transactions[offset++] &amp; 0xFF) &lt;&lt; 16) | ((transactions[offset++] &amp; 0xFF) &lt;&lt; 24);
<span class="fc" id="L677">                List&lt;Transaction&gt; transactionList = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">                for (int i = 0; i &lt; numTxn; i++) {</span>
<span class="fc" id="L679">                    Transaction tx = new Transaction(params, transactions, offset);</span>
<span class="fc" id="L680">                    transactionList.add(tx);</span>
<span class="fc" id="L681">                    offset += tx.getMessageSize();</span>
                }
<span class="fc" id="L683">                block = new StoredUndoableBlock(hash, transactionList);</span>
<span class="fc" id="L684">            } else {</span>
<span class="fc" id="L685">                byte[] txOutChanges = new byte[txOutSize];</span>
<span class="fc" id="L686">                bb.get(txOutChanges);</span>
<span class="fc" id="L687">                TransactionOutputChanges outChangesObject = new TransactionOutputChanges(</span>
                        new ByteArrayInputStream(txOutChanges));
<span class="fc" id="L689">                block = new StoredUndoableBlock(hash, outChangesObject);</span>
            }
<span class="pc bpc" id="L691" title="1 of 2 branches missed.">            if (instrument)</span>
<span class="nc" id="L692">                endMethod(&quot;getUndoBlock&quot;);</span>
<span class="fc" id="L693">            return block;</span>
<span class="nc" id="L694">        } catch (IOException e) {</span>
            // Corrupted database.
<span class="nc bnc" id="L696" title="All 2 branches missed.">            if (instrument)</span>
<span class="nc" id="L697">                endMethod(&quot;getUndoBlock&quot;);</span>
<span class="nc" id="L698">            throw new BlockStoreException(e);</span>
        }

    }

    @Override
    public UTXO getTransactionOutput(Sha256Hash hash, long index) throws BlockStoreException {
<span class="pc bpc" id="L705" title="1 of 2 branches missed.">        if (instrument)</span>
<span class="nc" id="L706">            beginMethod(&quot;getTransactionOutput&quot;);</span>

        try {
<span class="fc" id="L709">            UTXO result = null;</span>
<span class="fc" id="L710">            byte[] key = getTxKey(KeyType.OPENOUT_ALL, hash, (int) index);</span>
            // Use cache
<span class="fc bfc" id="L712" title="All 2 branches covered.">            if (autoCommit) {</span>
                // Simple case of auto commit on so cache is consistent.
<span class="fc" id="L714">                result = utxoCache.get(ByteBuffer.wrap(key));</span>
            } else {
                // Check if we have an uncommitted delete.
<span class="fc bfc" id="L717" title="All 2 branches covered.">                if (utxoUncommittedDeletedCache.contains(ByteBuffer.wrap(key))) {</span>
                    // has been deleted so return null;
<span class="fc" id="L719">                    hit++;</span>
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">                    if (instrument)</span>
<span class="nc" id="L721">                        endMethod(&quot;getTransactionOutput&quot;);</span>
<span class="fc" id="L722">                    return result;</span>
                }
                // Check if we have an uncommitted entry
<span class="fc" id="L725">                result = utxoUncommittedCache.get(ByteBuffer.wrap(key));</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">                if (result == null)</span>
<span class="fc" id="L727">                    result = utxoCache.get(ByteBuffer.wrap(key));</span>
                // And lastly above check if we have a committed cached entry

            }
<span class="fc bfc" id="L731" title="All 2 branches covered.">            if (result != null) {</span>
<span class="fc" id="L732">                hit++;</span>
<span class="pc bpc" id="L733" title="1 of 2 branches missed.">                if (instrument)</span>
<span class="nc" id="L734">                    endMethod(&quot;getTransactionOutput&quot;);</span>
<span class="fc" id="L735">                return result;</span>
            }
<span class="fc" id="L737">            miss++;</span>
            // If we get here have to hit the database.
<span class="fc" id="L739">            byte[] inbytes = batchGet(key);</span>
<span class="pc bpc" id="L740" title="1 of 2 branches missed.">            if (inbytes == null) {</span>
<span class="pc bpc" id="L741" title="1 of 2 branches missed.">                if (instrument)</span>
<span class="nc" id="L742">                    endMethod(&quot;getTransactionOutput&quot;);</span>
<span class="fc" id="L743">                return null;</span>
            }
<span class="nc" id="L745">            ByteArrayInputStream bis = new ByteArrayInputStream(inbytes);</span>
<span class="nc" id="L746">            UTXO txout = new UTXO(bis);</span>

<span class="nc bnc" id="L748" title="All 2 branches missed.">            if (instrument)</span>
<span class="nc" id="L749">                endMethod(&quot;getTransactionOutput&quot;);</span>
<span class="nc" id="L750">            return txout;</span>
<span class="nc" id="L751">        } catch (DBException e) {</span>
<span class="nc" id="L752">            log.error(&quot;Exception in getTransactionOutput.&quot;, e);</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">            if (instrument)</span>
<span class="nc" id="L754">                endMethod(&quot;getTransactionOutput&quot;);</span>
<span class="nc" id="L755">        } catch (IOException e) {</span>
<span class="nc" id="L756">            log.error(&quot;Exception in getTransactionOutput.&quot;, e);</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">            if (instrument)</span>
<span class="nc" id="L758">                endMethod(&quot;getTransactionOutput&quot;);</span>
<span class="nc" id="L759">        }</span>
<span class="nc" id="L760">        throw new BlockStoreException(&quot;problem&quot;);</span>
    }

    @Override
    public void addUnspentTransactionOutput(UTXO out) throws BlockStoreException {

<span class="pc bpc" id="L766" title="1 of 2 branches missed.">        if (instrument)</span>
<span class="nc" id="L767">            beginMethod(&quot;addUnspentTransactionOutput&quot;);</span>

        // Add to bloom filter - is very fast to add.
<span class="fc" id="L770">        bloom.add(out.getHash());</span>
<span class="fc" id="L771">        ByteArrayOutputStream bos = new ByteArrayOutputStream();</span>
        try {
<span class="fc" id="L773">            out.serializeToStream(bos);</span>
<span class="nc" id="L774">        } catch (IOException e) {</span>
<span class="nc" id="L775">            throw new BlockStoreException(&quot;problem serialising utxo&quot;, e);</span>
<span class="fc" id="L776">        }</span>

<span class="fc" id="L778">        byte[] key = getTxKey(KeyType.OPENOUT_ALL, out.getHash(), (int) out.getIndex());</span>
<span class="fc" id="L779">        batchPut(key, bos.toByteArray());</span>

<span class="pc bpc" id="L781" title="1 of 2 branches missed.">        if (autoCommit) {</span>
<span class="nc" id="L782">            utxoCache.put(ByteBuffer.wrap(key), out);</span>
        } else {
<span class="fc" id="L784">            utxoUncommittedCache.put(ByteBuffer.wrap(key), out);</span>
            // leveldb just stores the last key/value added.
            // So if we do an add must remove any previous deletes.
<span class="fc" id="L787">            utxoUncommittedDeletedCache.remove(ByteBuffer.wrap(key));</span>
        }

        // Could run this in parallel with above too.
        // Should update instrumentation to see if worth while.
        Address a;
<span class="fc bfc" id="L793" title="All 4 branches covered.">        if (out.getAddress() == null || out.getAddress().equals(&quot;&quot;)) {</span>
<span class="pc bpc" id="L794" title="1 of 2 branches missed.">            if (instrument)</span>
<span class="nc" id="L795">                endMethod(&quot;addUnspentTransactionOutput&quot;);</span>
<span class="fc" id="L796">            return;</span>
        } else {
            try {
<span class="fc" id="L799">                a = Address.fromBase58(params, out.getAddress());</span>
<span class="nc" id="L800">            } catch (AddressFormatException e) {</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">                if (instrument)</span>
<span class="nc" id="L802">                    endMethod(&quot;addUnspentTransactionOutput&quot;);</span>
<span class="nc" id="L803">                return;</span>
<span class="fc" id="L804">            }</span>
        }
<span class="fc" id="L806">        ByteBuffer bb = ByteBuffer.allocate(57);</span>
<span class="fc" id="L807">        bb.put((byte) KeyType.ADDRESS_HASHINDEX.ordinal());</span>
<span class="fc" id="L808">        bb.put(a.getHash160());</span>
<span class="fc" id="L809">        bb.put(out.getHash().getBytes());</span>
<span class="fc" id="L810">        bb.putInt((int) out.getIndex());</span>
<span class="fc" id="L811">        byte[] value = new byte[0];</span>
<span class="fc" id="L812">        batchPut(bb.array(), value);</span>
<span class="pc bpc" id="L813" title="1 of 2 branches missed.">        if (instrument)</span>
<span class="nc" id="L814">            endMethod(&quot;addUnspentTransactionOutput&quot;);</span>
<span class="fc" id="L815">    }</span>

    private void batchPut(byte[] key, byte[] value) {
<span class="fc bfc" id="L818" title="All 2 branches covered.">        if (autoCommit) {</span>
<span class="fc" id="L819">            db.put(key, value);</span>
        } else {
            // Add this so we can get at uncommitted inserts which
            // leveldb does not support
<span class="fc" id="L823">            uncommited.put(ByteBuffer.wrap(key), value);</span>
<span class="fc" id="L824">            batch.put(key, value);</span>
        }
<span class="fc" id="L826">    }</span>

    private byte[] batchGet(byte[] key) {
<span class="fc" id="L829">        ByteBuffer bbKey = ByteBuffer.wrap(key);</span>

        // This is needed to cope with deletes that are not yet committed to db.
<span class="pc bpc" id="L832" title="2 of 6 branches missed.">        if (!autoCommit &amp;&amp; uncommitedDeletes != null &amp;&amp; uncommitedDeletes.contains(bbKey))</span>
<span class="nc" id="L833">            return null;</span>

<span class="fc" id="L835">        byte[] value = null;</span>
        // And this to handle uncommitted inserts (dirty reads)
<span class="pc bpc" id="L837" title="1 of 4 branches missed.">        if (!autoCommit &amp;&amp; uncommited != null) {</span>
<span class="fc" id="L838">            value = uncommited.get(bbKey);</span>
<span class="fc bfc" id="L839" title="All 2 branches covered.">            if (value != null)</span>
<span class="fc" id="L840">                return value;</span>
        }
        try {
<span class="fc" id="L843">            value = db.get(key);</span>
<span class="nc" id="L844">        } catch (DBException e) {</span>
<span class="nc" id="L845">            log.error(&quot;Caught error opening file&quot;, e);</span>
            try {
<span class="nc" id="L847">                Thread.sleep(1000);</span>
<span class="nc" id="L848">            } catch (InterruptedException e1) {</span>
<span class="nc" id="L849">            }</span>
<span class="nc" id="L850">            value = db.get(key);</span>
<span class="fc" id="L851">        }</span>
<span class="fc" id="L852">        return value;</span>
    }

    private void batchDelete(byte[] key) {
<span class="pc bpc" id="L856" title="1 of 2 branches missed.">        if (!autoCommit) {</span>
<span class="fc" id="L857">            batch.delete(key);</span>
<span class="fc" id="L858">            uncommited.remove(ByteBuffer.wrap(key));</span>
<span class="fc" id="L859">            uncommitedDeletes.add(ByteBuffer.wrap(key));</span>
        } else {
<span class="nc" id="L861">            db.delete(key);</span>
        }
<span class="fc" id="L863">    }</span>

    @Override
    public void removeUnspentTransactionOutput(UTXO out) throws BlockStoreException {
<span class="pc bpc" id="L867" title="1 of 2 branches missed.">        if (instrument)</span>
<span class="nc" id="L868">            beginMethod(&quot;removeUnspentTransactionOutput&quot;);</span>

<span class="fc" id="L870">        byte[] key = getTxKey(KeyType.OPENOUT_ALL, out.getHash(), (int) out.getIndex());</span>

<span class="pc bpc" id="L872" title="1 of 2 branches missed.">        if (autoCommit) {</span>
<span class="nc" id="L873">            utxoCache.remove(ByteBuffer.wrap(key));</span>
        } else {
<span class="fc" id="L875">            utxoUncommittedDeletedCache.add(ByteBuffer.wrap(key));</span>
<span class="fc" id="L876">            utxoUncommittedCache.remove(ByteBuffer.wrap(key));</span>
        }

<span class="fc" id="L879">        batchDelete(key);</span>
        // could run this and the above in parallel
        // Need to update instrumentation to check if worth the effort

        // TODO storing as byte[] hash to save space. But think should just
        // store as String of address. Might be faster. Need to test.
<span class="fc" id="L885">        ByteBuffer bb = ByteBuffer.allocate(57);</span>
        Address a;
<span class="fc" id="L887">        byte[] hashBytes = null;</span>
        try {
<span class="fc" id="L889">            String address = out.getAddress();</span>
<span class="fc bfc" id="L890" title="All 4 branches covered.">            if (address == null || address.equals(&quot;&quot;)) {</span>
<span class="fc" id="L891">                Script sc = out.getScript();</span>
<span class="nc" id="L892">                a = sc.getToAddress(params);</span>
<span class="nc" id="L893">                hashBytes = a.getHash160();</span>
<span class="nc" id="L894">            } else {</span>
<span class="fc" id="L895">                a = Address.fromBase58(params, out.getAddress());</span>
<span class="fc" id="L896">                hashBytes = a.getHash160();</span>
            }
<span class="nc" id="L898">        } catch (AddressFormatException e) {</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">            if (instrument)</span>
<span class="nc" id="L900">                endMethod(&quot;removeUnspentTransactionOutput&quot;);</span>
<span class="nc" id="L901">            return;</span>
<span class="fc" id="L902">        } catch (ScriptException e) {</span>
<span class="pc bpc" id="L903" title="1 of 2 branches missed.">            if (instrument)</span>
<span class="nc" id="L904">                endMethod(&quot;removeUnspentTransactionOutput&quot;);</span>
<span class="fc" id="L905">            return;</span>
<span class="fc" id="L906">        }</span>
<span class="fc" id="L907">        bb.put((byte) KeyType.ADDRESS_HASHINDEX.ordinal());</span>
<span class="fc" id="L908">        bb.put(hashBytes);</span>
<span class="fc" id="L909">        bb.put(out.getHash().getBytes());</span>
<span class="fc" id="L910">        bb.putInt((int) out.getIndex());</span>
<span class="fc" id="L911">        batchDelete(bb.array());</span>

<span class="pc bpc" id="L913" title="1 of 2 branches missed.">        if (instrument)</span>
<span class="nc" id="L914">            endMethod(&quot;removeUnspentTransactionOutput&quot;);</span>
<span class="fc" id="L915">    }</span>

    // Instrumentation of bloom filter to check theory
    // matches reality. Without this initial chain sync takes
    // 50-75% longer.
    long hasCall;
    long hasTrue;
    long hasFalse;

    @Override
    public boolean hasUnspentOutputs(Sha256Hash hash, int numOutputs) throws BlockStoreException {
<span class="pc bpc" id="L926" title="1 of 2 branches missed.">        if (instrument)</span>
<span class="nc" id="L927">            beginMethod(&quot;hasUnspentOutputs&quot;);</span>
<span class="fc" id="L928">        hasCall++;</span>
<span class="fc bfc" id="L929" title="All 2 branches covered.">        if (!bloom.wasAdded(hash)) {</span>
<span class="pc bpc" id="L930" title="1 of 2 branches missed.">            if (instrument)</span>
<span class="nc" id="L931">                endMethod(&quot;hasUnspentOutputs&quot;);</span>
<span class="fc" id="L932">            hasFalse++;</span>
<span class="fc" id="L933">            return false;</span>
        }
        // no index is fine as will find any entry with any index...
        // TODO should I be checking uncommitted inserts/deletes???
<span class="fc" id="L937">        byte[] key = getTxKey(KeyType.OPENOUT_ALL, hash);</span>
<span class="fc" id="L938">        byte[] subResult = new byte[key.length];</span>
<span class="fc" id="L939">        DBIterator iterator = db.iterator();</span>
<span class="pc bpc" id="L940" title="1 of 2 branches missed.">        for (iterator.seek(key); iterator.hasNext();) {</span>
<span class="fc" id="L941">            byte[] result = iterator.peekNext().getKey();</span>
<span class="fc" id="L942">            System.arraycopy(result, 0, subResult, 0, subResult.length);</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">            if (Arrays.equals(key, subResult)) {</span>
<span class="fc" id="L944">                hasTrue++;</span>
                try {
<span class="fc" id="L946">                    iterator.close();</span>
<span class="nc" id="L947">                } catch (IOException e) {</span>
<span class="nc" id="L948">                    log.error(&quot;Error closing iterator&quot;, e);</span>
<span class="fc" id="L949">                }</span>
<span class="pc bpc" id="L950" title="1 of 2 branches missed.">                if (instrument)</span>
<span class="nc" id="L951">                    endMethod(&quot;hasUnspentOutputs&quot;);</span>
<span class="fc" id="L952">                return true;</span>
            } else {
<span class="fc" id="L954">                hasFalse++;</span>
                try {
<span class="fc" id="L956">                    iterator.close();</span>
<span class="nc" id="L957">                } catch (IOException e) {</span>
<span class="nc" id="L958">                    log.error(&quot;Error closing iterator&quot;, e);</span>
<span class="fc" id="L959">                }</span>
<span class="pc bpc" id="L960" title="1 of 2 branches missed.">                if (instrument)</span>
<span class="nc" id="L961">                    endMethod(&quot;hasUnspentOutputs&quot;);</span>
<span class="fc" id="L962">                return false;</span>
            }
        }
        try {
<span class="nc" id="L966">            iterator.close();</span>
<span class="nc" id="L967">        } catch (IOException e) {</span>
<span class="nc" id="L968">            log.error(&quot;Error closing iterator&quot;, e);</span>
<span class="nc" id="L969">        }</span>
<span class="nc" id="L970">        hasFalse++;</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">        if (instrument)</span>
<span class="nc" id="L972">            endMethod(&quot;hasUnspentOutputs&quot;);</span>
<span class="nc" id="L973">        return false;</span>
    }

    @Override
    public StoredBlock getVerifiedChainHead() throws BlockStoreException {
<span class="fc" id="L978">        return verifiedChainHeadBlock;</span>
    }

    @Override
    public void setVerifiedChainHead(StoredBlock chainHead) throws BlockStoreException {
<span class="pc bpc" id="L983" title="1 of 2 branches missed.">        if (instrument)</span>
<span class="nc" id="L984">            beginMethod(&quot;setVerifiedChainHead&quot;);</span>
<span class="fc" id="L985">        Sha256Hash hash = chainHead.getHeader().getHash();</span>
<span class="fc" id="L986">        this.verifiedChainHeadHash = hash;</span>
<span class="fc" id="L987">        this.verifiedChainHeadBlock = chainHead;</span>
<span class="fc" id="L988">        batchPut(getKey(KeyType.VERIFIED_CHAIN_HEAD_SETTING), hash.getBytes());</span>
<span class="fc bfc" id="L989" title="All 2 branches covered.">        if (this.chainHeadBlock.getHeight() &lt; chainHead.getHeight())</span>
<span class="fc" id="L990">            setChainHead(chainHead);</span>
<span class="fc" id="L991">        removeUndoableBlocksWhereHeightIsLessThan(chainHead.getHeight() - fullStoreDepth);</span>
<span class="pc bpc" id="L992" title="1 of 2 branches missed.">        if (instrument)</span>
<span class="nc" id="L993">            endMethod(&quot;setVerifiedChainHead&quot;);</span>
<span class="fc" id="L994">    }</span>

    void removeUndoableBlocksWhereHeightIsLessThan(int height) {
<span class="fc bfc" id="L997" title="All 2 branches covered.">        if (height &lt; 0)</span>
<span class="fc" id="L998">            return;</span>
<span class="fc" id="L999">        DBIterator iterator = db.iterator();</span>
<span class="fc" id="L1000">        ByteBuffer keyBuf = ByteBuffer.allocate(5);</span>
<span class="fc" id="L1001">        keyBuf.put((byte) KeyType.HEIGHT_UNDOABLEBLOCKS.ordinal());</span>
<span class="fc" id="L1002">        keyBuf.putInt(height);</span>

<span class="pc bpc" id="L1004" title="1 of 2 branches missed.">        for (iterator.seek(keyBuf.array()); iterator.hasNext(); iterator.next()) {</span>

<span class="fc" id="L1006">            byte[] bytekey = iterator.peekNext().getKey();</span>
<span class="fc" id="L1007">            ByteBuffer buff = ByteBuffer.wrap(bytekey);</span>
<span class="fc" id="L1008">            buff.get(); // Just remove byte from buffer.</span>
<span class="fc" id="L1009">            int keyHeight = buff.getInt();</span>

<span class="fc" id="L1011">            byte[] hashbytes = new byte[32];</span>
<span class="fc" id="L1012">            buff.get(hashbytes, 4, 28);</span>

<span class="fc bfc" id="L1014" title="All 2 branches covered.">            if (keyHeight &gt; height)</span>
<span class="fc" id="L1015">                break;</span>

<span class="fc" id="L1017">            batchDelete(getKey(KeyType.UNDOABLEBLOCKS_ALL, hashbytes));</span>
<span class="fc" id="L1018">            batchDelete(bytekey);</span>
        }
        try {
<span class="fc" id="L1021">            iterator.close();</span>
<span class="nc" id="L1022">        } catch (IOException e) {</span>
<span class="nc" id="L1023">            log.error(&quot;Error closing iterator&quot;, e);</span>
<span class="fc" id="L1024">        }</span>

<span class="fc" id="L1026">    }</span>

    WriteBatch batch;

    @Override
    public void beginDatabaseBatchWrite() throws BlockStoreException {
        // This is often called twice in row! But they are not nested
        // transactions!
        // We just ignore the second call.
<span class="fc bfc" id="L1035" title="All 2 branches covered.">        if (!autoCommit) {</span>
<span class="fc" id="L1036">            return;</span>
        }
<span class="pc bpc" id="L1038" title="1 of 2 branches missed.">        if (instrument)</span>
<span class="nc" id="L1039">            beginMethod(&quot;beginDatabaseBatchWrite&quot;);</span>

<span class="fc" id="L1041">        batch = db.createWriteBatch();</span>
<span class="fc" id="L1042">        uncommited = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1043">        uncommitedDeletes = new HashSet&lt;&gt;();</span>
<span class="fc" id="L1044">        utxoUncommittedCache = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1045">        utxoUncommittedDeletedCache = new HashSet&lt;&gt;();</span>
<span class="fc" id="L1046">        autoCommit = false;</span>
<span class="pc bpc" id="L1047" title="1 of 2 branches missed.">        if (instrument)</span>
<span class="nc" id="L1048">            endMethod(&quot;beginDatabaseBatchWrite&quot;);</span>
<span class="fc" id="L1049">    }</span>

    @Override
    public void commitDatabaseBatchWrite() throws BlockStoreException {
<span class="fc" id="L1053">        uncommited = null;</span>
<span class="fc" id="L1054">        uncommitedDeletes = null;</span>
<span class="pc bpc" id="L1055" title="1 of 2 branches missed.">        if (instrument)</span>
<span class="nc" id="L1056">            beginMethod(&quot;commitDatabaseBatchWrite&quot;);</span>

<span class="fc" id="L1058">        db.write(batch);</span>
        // order of these is not important as we only allow entry to be in one
        // or the other.
        // must update cache with uncommitted adds/deletes.
<span class="fc bfc" id="L1062" title="All 2 branches covered.">        for (Map.Entry&lt;ByteBuffer, UTXO&gt; entry : utxoUncommittedCache.entrySet()) {</span>

<span class="fc" id="L1064">            utxoCache.put(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L1065">        }</span>
<span class="fc" id="L1066">        utxoUncommittedCache = null;</span>
<span class="fc bfc" id="L1067" title="All 2 branches covered.">        for (ByteBuffer entry : utxoUncommittedDeletedCache) {</span>
<span class="fc" id="L1068">            utxoCache.remove(entry);</span>
<span class="fc" id="L1069">        }</span>
<span class="fc" id="L1070">        utxoUncommittedDeletedCache = null;</span>

<span class="fc" id="L1072">        autoCommit = true;</span>

        try {
<span class="fc" id="L1075">            batch.close();</span>
<span class="fc" id="L1076">            batch = null;</span>
<span class="nc" id="L1077">        } catch (IOException e) {</span>
<span class="nc" id="L1078">            log.error(&quot;Error in db commit.&quot;, e);</span>
<span class="nc" id="L1079">            throw new BlockStoreException(&quot;could not close batch.&quot;);</span>
<span class="fc" id="L1080">        }</span>

<span class="pc bpc" id="L1082" title="1 of 2 branches missed.">        if (instrument)</span>
<span class="nc" id="L1083">            endMethod(&quot;commitDatabaseBatchWrite&quot;);</span>

<span class="pc bpc" id="L1085" title="3 of 4 branches missed.">        if (instrument &amp;&amp; verifiedChainHeadBlock.getHeight() % 1000 == 0) {</span>
<span class="nc" id="L1086">            log.info(&quot;Height: &quot; + verifiedChainHeadBlock.getHeight());</span>
<span class="nc" id="L1087">            dumpStats();</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">            if (verifiedChainHeadBlock.getHeight() == exitBlock) {</span>
<span class="nc" id="L1089">                System.err.println(&quot;Exit due to exitBlock set&quot;);</span>
<span class="nc" id="L1090">                System.exit(1);</span>
            }
        }
<span class="fc" id="L1093">    }</span>

    @Override
    public void abortDatabaseBatchWrite() throws BlockStoreException {
        try {
<span class="fc" id="L1098">            uncommited = null;</span>
<span class="fc" id="L1099">            uncommitedDeletes = null;</span>
<span class="fc" id="L1100">            utxoUncommittedCache = null;</span>
<span class="fc" id="L1101">            utxoUncommittedDeletedCache = null;</span>
<span class="fc" id="L1102">            autoCommit = true;</span>
<span class="fc bfc" id="L1103" title="All 2 branches covered.">            if (batch != null) {</span>
<span class="fc" id="L1104">                batch.close();</span>
<span class="fc" id="L1105">                batch = null;</span>
            }
<span class="nc" id="L1107">        } catch (IOException e) {</span>
<span class="nc" id="L1108">            throw new BlockStoreException(&quot;could not close batch in abort.&quot;, e);</span>
<span class="fc" id="L1109">        }</span>
<span class="fc" id="L1110">    }</span>

    public void resetStore() {
        // only used in unit tests.
        // bit dangerous and deletes files!
        try {
<span class="fc" id="L1116">            db.close();</span>
<span class="fc" id="L1117">            uncommited = null;</span>
<span class="fc" id="L1118">            uncommitedDeletes = null;</span>
<span class="fc" id="L1119">            autoCommit = true;</span>
<span class="fc" id="L1120">            bloom = new BloomFilter();</span>
<span class="fc" id="L1121">            utxoCache = new LRUCache(openOutCache, 0.75f);</span>
<span class="nc" id="L1122">        } catch (IOException e) {</span>
<span class="nc" id="L1123">            log.error(&quot;Exception in resetStore.&quot;, e);</span>
<span class="fc" id="L1124">        }</span>

<span class="fc" id="L1126">        File f = new File(filename);</span>
<span class="pc bpc" id="L1127" title="1 of 2 branches missed.">        if (f.isDirectory()) {</span>
<span class="fc bfc" id="L1128" title="All 2 branches covered.">            for (File c : f.listFiles())</span>
<span class="fc" id="L1129">                c.delete();</span>
        }
<span class="fc" id="L1131">        openDB();</span>
<span class="fc" id="L1132">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>