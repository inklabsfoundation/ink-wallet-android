<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DatabaseFullPrunedBlockStore.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bitcoinj</a> &gt; <a href="index.source.html" class="el_package">org.bitcoinj.store</a> &gt; <span class="el_source">DatabaseFullPrunedBlockStore.java</span></div><h1>DatabaseFullPrunedBlockStore.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2014 BitPOS Pty Ltd.
 * Copyright 2014 Andreas Schildbach.
 * Copyright 2014 Kalpesh Parmar.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bitcoinj.store;

import com.google.common.collect.Lists;
import org.bitcoinj.core.*;
import org.bitcoinj.script.Script;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nullable;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.sql.*;
import java.util.*;

/**
 * &lt;p&gt;A generic full pruned block store for a relational database.  This generic class requires
 * certain table structures for the block store.&lt;/p&gt;
 *
 * &lt;p&gt;The following are the tables and field names/types that are assumed:-&lt;/p&gt;
 *
 * &lt;p&gt;
 * &lt;b&gt;setting&lt;/b&gt; table
 * &lt;table&gt;
 *     &lt;tr&gt;&lt;th&gt;Field Name&lt;/th&gt;&lt;th&gt;Type (generic)&lt;/th&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td&gt;string&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;value&lt;/td&gt;&lt;td&gt;binary&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;/p&gt;
 *
 * &lt;p&gt;&lt;br/&gt;
 * &lt;b&gt;headers&lt;/b&gt; table
 * &lt;table&gt;
 *     &lt;tr&gt;&lt;th&gt;Field Name&lt;/th&gt;&lt;th&gt;Type (generic)&lt;/th&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;hash&lt;/td&gt;&lt;td&gt;binary&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;chainwork&lt;/td&gt;&lt;td&gt;binary&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;height&lt;/td&gt;&lt;td&gt;integer&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;header&lt;/td&gt;&lt;td&gt;binary&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;wasundoable&lt;/td&gt;&lt;td&gt;boolean&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;/p&gt;
 *
 * &lt;p&gt;&lt;br/&gt;
 * &lt;b&gt;undoableblocks&lt;/b&gt; table
 * &lt;table&gt;
 *     &lt;tr&gt;&lt;th&gt;Field Name&lt;/th&gt;&lt;th&gt;Type (generic)&lt;/th&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;hash&lt;/td&gt;&lt;td&gt;binary&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;height&lt;/td&gt;&lt;td&gt;integer&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;txoutchanges&lt;/td&gt;&lt;td&gt;binary&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;transactions&lt;/td&gt;&lt;td&gt;binary&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;/p&gt;
 *
 * &lt;p&gt;&lt;br/&gt;
 * &lt;b&gt;openoutputs&lt;/b&gt; table
 * &lt;table&gt;
 *     &lt;tr&gt;&lt;th&gt;Field Name&lt;/th&gt;&lt;th&gt;Type (generic)&lt;/th&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;hash&lt;/td&gt;&lt;td&gt;binary&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;index&lt;/td&gt;&lt;td&gt;integer&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;height&lt;/td&gt;&lt;td&gt;integer&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;value&lt;/td&gt;&lt;td&gt;integer&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;scriptbytes&lt;/td&gt;&lt;td&gt;binary&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;toaddress&lt;/td&gt;&lt;td&gt;string&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;addresstargetable&lt;/td&gt;&lt;td&gt;integer&lt;/td&gt;&lt;/tr&gt;
 *     &lt;tr&gt;&lt;td&gt;coinbase&lt;/td&gt;&lt;td&gt;boolean&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;/p&gt;
 *
 */
public abstract class DatabaseFullPrunedBlockStore implements FullPrunedBlockStore {
<span class="fc" id="L90">    private static final Logger log = LoggerFactory.getLogger(DatabaseFullPrunedBlockStore.class);</span>

    private static final String CHAIN_HEAD_SETTING                              = &quot;chainhead&quot;;
    private static final String VERIFIED_CHAIN_HEAD_SETTING                     = &quot;verifiedchainhead&quot;;
    private static final String VERSION_SETTING                                 = &quot;version&quot;;

    // Drop table SQL.
    private static final String DROP_SETTINGS_TABLE                             = &quot;DROP TABLE settings&quot;;
    private static final String DROP_HEADERS_TABLE                              = &quot;DROP TABLE headers&quot;;
    private static final String DROP_UNDOABLE_TABLE                             = &quot;DROP TABLE undoableblocks&quot;;
    private static final String DROP_OPEN_OUTPUT_TABLE                          = &quot;DROP TABLE openoutputs&quot;;

    // Queries SQL.
    private static final String SELECT_SETTINGS_SQL                             = &quot;SELECT value FROM settings WHERE name = ?&quot;;
    private static final String INSERT_SETTINGS_SQL                             = &quot;INSERT INTO settings(name, value) VALUES(?, ?)&quot;;
    private static final String UPDATE_SETTINGS_SQL                             = &quot;UPDATE settings SET value = ? WHERE name = ?&quot;;

    private static final String SELECT_HEADERS_SQL                              = &quot;SELECT chainwork, height, header, wasundoable FROM headers WHERE hash = ?&quot;;
    private static final String INSERT_HEADERS_SQL                              = &quot;INSERT INTO headers(hash, chainwork, height, header, wasundoable) VALUES(?, ?, ?, ?, ?)&quot;;
    private static final String UPDATE_HEADERS_SQL                              = &quot;UPDATE headers SET wasundoable=? WHERE hash=?&quot;;

    private static final String SELECT_UNDOABLEBLOCKS_SQL                       = &quot;SELECT txoutchanges, transactions FROM undoableblocks WHERE hash = ?&quot;;
    private static final String INSERT_UNDOABLEBLOCKS_SQL                       = &quot;INSERT INTO undoableblocks(hash, height, txoutchanges, transactions) VALUES(?, ?, ?, ?)&quot;;
    private static final String UPDATE_UNDOABLEBLOCKS_SQL                       = &quot;UPDATE undoableblocks SET txoutchanges=?, transactions=? WHERE hash = ?&quot;;
    private static final String DELETE_UNDOABLEBLOCKS_SQL                       = &quot;DELETE FROM undoableblocks WHERE height &lt;= ?&quot;;

    private static final String SELECT_OPENOUTPUTS_SQL                          = &quot;SELECT height, value, scriptbytes, coinbase, toaddress, addresstargetable FROM openoutputs WHERE hash = ? AND index = ?&quot;;
    private static final String SELECT_OPENOUTPUTS_COUNT_SQL                    = &quot;SELECT COUNT(*) FROM openoutputs WHERE hash = ?&quot;;
    private static final String INSERT_OPENOUTPUTS_SQL                          = &quot;INSERT INTO openoutputs (hash, index, height, value, scriptbytes, toaddress, addresstargetable, coinbase) VALUES (?, ?, ?, ?, ?, ?, ?, ?)&quot;;
    private static final String DELETE_OPENOUTPUTS_SQL                          = &quot;DELETE FROM openoutputs WHERE hash = ? AND index = ?&quot;;

    // Dump table SQL (this is just for data sizing statistics).
    private static final String SELECT_DUMP_SETTINGS_SQL                        = &quot;SELECT name, value FROM settings&quot;;
    private static final String SELECT_DUMP_HEADERS_SQL                         = &quot;SELECT chainwork, header FROM headers&quot;;
    private static final String SELECT_DUMP_UNDOABLEBLOCKS_SQL                  = &quot;SELECT txoutchanges, transactions FROM undoableblocks&quot;;
    private static final String SELECT_DUMP_OPENOUTPUTS_SQL                     = &quot;SELECT value, scriptbytes FROM openoutputs&quot;;

    private static final String SELECT_TRANSACTION_OUTPUTS_SQL                  = &quot;SELECT hash, value, scriptbytes, height, index, coinbase, toaddress, addresstargetable FROM openoutputs where toaddress = ?&quot;;

    // Select the balance of an address SQL.
    private static final String SELECT_BALANCE_SQL                              = &quot;select sum(value) from openoutputs where toaddress = ?&quot;;

    // Tables exist SQL.
    private static final String SELECT_CHECK_TABLES_EXIST_SQL                   = &quot;SELECT * FROM settings WHERE 1 = 2&quot;;

    // Compatibility SQL.
    private static final String SELECT_COMPATIBILITY_COINBASE_SQL               = &quot;SELECT coinbase FROM openoutputs WHERE 1 = 2&quot;;

    protected Sha256Hash chainHeadHash;
    protected StoredBlock chainHeadBlock;
    protected Sha256Hash verifiedChainHeadHash;
    protected StoredBlock verifiedChainHeadBlock;
    protected NetworkParameters params;
    protected ThreadLocal&lt;Connection&gt; conn;
    protected List&lt;Connection&gt; allConnections;
    protected String connectionURL;
    protected int fullStoreDepth;
    protected String username;
    protected String password;
    protected String schemaName;

    /**
     * &lt;p&gt;Create a new DatabaseFullPrunedBlockStore, using the full connection URL instead of a hostname and password,
     * and optionally allowing a schema to be specified.&lt;/p&gt;
     *
     * @param params A copy of the NetworkParameters used.
     * @param connectionURL The jdbc url to connect to the database.
     * @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     * @param username The database username.
     * @param password The password to the database.
     * @param schemaName The name of the schema to put the tables in.  May be null if no schema is being used.
     * @throws BlockStoreException If there is a failure to connect and/or initialise the database.
     */
    public DatabaseFullPrunedBlockStore(NetworkParameters params, String connectionURL, int fullStoreDepth,
<span class="fc" id="L164">                                        @Nullable String username, @Nullable String password, @Nullable String schemaName) throws BlockStoreException {</span>
<span class="fc" id="L165">        this.params = params;</span>
<span class="fc" id="L166">        this.fullStoreDepth = fullStoreDepth;</span>
<span class="fc" id="L167">        this.connectionURL = connectionURL;</span>
<span class="fc" id="L168">        this.schemaName = schemaName;</span>
<span class="fc" id="L169">        this.username = username;</span>
<span class="fc" id="L170">        this.password = password;</span>
<span class="fc" id="L171">        this.conn = new ThreadLocal&lt;&gt;();</span>
<span class="fc" id="L172">        this.allConnections = new LinkedList&lt;&gt;();</span>

        try {
<span class="fc" id="L175">            Class.forName(getDatabaseDriverClass());</span>
<span class="fc" id="L176">            log.info(getDatabaseDriverClass() + &quot; loaded. &quot;);</span>
<span class="nc" id="L177">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L178">            log.error(&quot;check CLASSPATH for database driver jar &quot;, e);</span>
<span class="fc" id="L179">        }</span>

<span class="fc" id="L181">        maybeConnect();</span>

        try {
            // Create tables if needed
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">            if (!tablesExists()) {</span>
<span class="fc" id="L186">                createTables();</span>
            } else {
<span class="nc" id="L188">                checkCompatibility();</span>
            }
<span class="fc" id="L190">            initFromDatabase();</span>
<span class="nc" id="L191">        } catch (SQLException e) {</span>
<span class="nc" id="L192">            throw new BlockStoreException(e);</span>
<span class="fc" id="L193">        }</span>
<span class="fc" id="L194">    }</span>

    /**
     * Get the database driver class,
     * &lt;p&gt;i.e org.postgresql.Driver.&lt;/p&gt;
     * @return The fully qualified database driver class.
     */
    protected abstract String getDatabaseDriverClass();

    /**
     * Get the SQL statements that create the schema (DDL).
     * @return The list of SQL statements.
     */
    protected abstract List&lt;String&gt; getCreateSchemeSQL();

    /**
     * Get the SQL statements that create the tables (DDL).
     * @return The list of SQL statements.
     */
    protected abstract List&lt;String&gt; getCreateTablesSQL();

    /**
     * Get the SQL statements that create the indexes (DDL).
     * @return The list of SQL statements.
     */
    protected abstract List&lt;String&gt; getCreateIndexesSQL();

    /**
     * Get the database specific error code that indicated a duplicate key error when inserting a record.
     * &lt;p&gt;This is the code returned by {@link java.sql.SQLException#getSQLState()}&lt;/p&gt;
     * @return The database duplicate error code.
     */
    protected abstract String getDuplicateKeyErrorCode();

    /**
     * Get the SQL to select the total balance for a given address.
     * @return The SQL prepared statement.
     */
    protected String getBalanceSelectSQL() {
<span class="nc" id="L233">        return SELECT_BALANCE_SQL;</span>
    }

    /**
     * Get the SQL statement that checks if tables exist.
     * @return The SQL prepared statement.
     */
    protected String getTablesExistSQL() {
<span class="fc" id="L241">        return SELECT_CHECK_TABLES_EXIST_SQL;</span>
    }

    /**
     * Get the SQL statements to check if the database is compatible.
     * @return The SQL prepared statements.
     */
    protected List&lt;String&gt; getCompatibilitySQL() {
<span class="nc" id="L249">        List&lt;String&gt; sqlStatements = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L250">        sqlStatements.add(SELECT_COMPATIBILITY_COINBASE_SQL);</span>
<span class="nc" id="L251">        return sqlStatements;</span>
    }

    /**
     * Get the SQL to select the transaction outputs for a given address.
     * @return The SQL prepared statement.
     */
    protected String getTransactionOutputSelectSQL() {
<span class="fc" id="L259">        return SELECT_TRANSACTION_OUTPUTS_SQL;</span>
    }

    /**
     * Get the SQL to drop all the tables (DDL).
     * @return The SQL drop statements.
     */
    protected List&lt;String&gt; getDropTablesSQL() {
<span class="fc" id="L267">        List&lt;String&gt; sqlStatements = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L268">        sqlStatements.add(DROP_SETTINGS_TABLE);</span>
<span class="fc" id="L269">        sqlStatements.add(DROP_HEADERS_TABLE);</span>
<span class="fc" id="L270">        sqlStatements.add(DROP_UNDOABLE_TABLE);</span>
<span class="fc" id="L271">        sqlStatements.add(DROP_OPEN_OUTPUT_TABLE);</span>
<span class="fc" id="L272">        return sqlStatements;</span>
    }

    /**
     * Get the SQL to select a setting value.
     * @return The SQL select statement.
     */
    protected String getSelectSettingsSQL() {
<span class="fc" id="L280">        return SELECT_SETTINGS_SQL;</span>
    }

    /**
     * Get the SQL to insert a settings record.
     * @return The SQL insert statement.
     */
    protected String getInsertSettingsSQL() {
<span class="fc" id="L288">        return INSERT_SETTINGS_SQL;</span>
    }

    /**
     * Get the SQL to update a setting value.
     * @return The SQL update statement.
     */
    protected String getUpdateSettingsSLQ() {
<span class="fc" id="L296">        return UPDATE_SETTINGS_SQL;</span>
    }

    /**
     * Get the SQL to select a headers record.
     * @return The SQL select  statement.
     */
    protected String getSelectHeadersSQL() {
<span class="fc" id="L304">        return SELECT_HEADERS_SQL;</span>
    }

    /**
     * Get the SQL to insert a headers record.
     * @return The SQL insert statement.
     */
    protected String getInsertHeadersSQL() {
<span class="fc" id="L312">        return INSERT_HEADERS_SQL;</span>
    }

    /**
     * Get the SQL to update a headers record.
     * @return The SQL update statement.
     */
    protected String getUpdateHeadersSQL() {
<span class="nc" id="L320">        return UPDATE_HEADERS_SQL;</span>
    }

    /**
     * Get the SQL to select an undoableblocks record.
     * @return The SQL select statement.
     */
    protected String getSelectUndoableBlocksSQL() {
<span class="fc" id="L328">        return SELECT_UNDOABLEBLOCKS_SQL;</span>
    }

    /**
     * Get the SQL to insert a undoableblocks record.
     * @return The SQL insert statement.
     */
    protected String getInsertUndoableBlocksSQL() {
<span class="fc" id="L336">        return INSERT_UNDOABLEBLOCKS_SQL;</span>
    }

    /**
     * Get the SQL to update a undoableblocks record.
     * @return The SQL update statement.
     */
    protected String getUpdateUndoableBlocksSQL() {
<span class="fc" id="L344">        return UPDATE_UNDOABLEBLOCKS_SQL;</span>
    }

    /**
     * Get the SQL to delete a undoableblocks record.
     * @return The SQL delete statement.
     */
    protected String getDeleteUndoableBlocksSQL() {
<span class="fc" id="L352">        return DELETE_UNDOABLEBLOCKS_SQL;</span>
    }

    /**
     * Get the SQL to select a openoutputs record.
     * @return The SQL select statement.
     */
    protected String getSelectOpenoutputsSQL() {
<span class="fc" id="L360">        return SELECT_OPENOUTPUTS_SQL;</span>
    }

    /**
     * Get the SQL to select count of openoutputs.
     * @return The SQL select statement.
     */
    protected String getSelectOpenoutputsCountSQL() {
<span class="fc" id="L368">        return SELECT_OPENOUTPUTS_COUNT_SQL;</span>
    }

    /**
     * Get the SQL to insert a openoutputs record.
     * @return The SQL insert statement.
     */
    protected String getInsertOpenoutputsSQL() {
<span class="fc" id="L376">        return INSERT_OPENOUTPUTS_SQL;</span>
    }

    /**
     * Get the SQL to delete a openoutputs record.
     * @return The SQL delete statement.
     */
    protected String getDeleteOpenoutputsSQL() {
<span class="fc" id="L384">        return DELETE_OPENOUTPUTS_SQL;</span>
    }

    /**
     * Get the SQL to select the setting dump fields for sizing/statistics.
     * @return The SQL select statement.
     */
    protected String getSelectSettingsDumpSQL() {
<span class="nc" id="L392">        return SELECT_DUMP_SETTINGS_SQL;</span>
    }

    /**
     * Get the SQL to select the headers dump fields for sizing/statistics.
     * @return The SQL select statement.
     */
    protected String getSelectHeadersDumpSQL() {
<span class="nc" id="L400">        return SELECT_DUMP_HEADERS_SQL;</span>
    }

    /**
     * Get the SQL to select the undoableblocks dump fields for sizing/statistics.
     * @return The SQL select statement.
     */
    protected String getSelectUndoableblocksDumpSQL() {
<span class="nc" id="L408">        return SELECT_DUMP_UNDOABLEBLOCKS_SQL;</span>
    }

    /**
     * Get the SQL to select the openoutouts dump fields for sizing/statistics.
     * @return The SQL select statement.
     */
    protected String getSelectopenoutputsDumpSQL() {
<span class="nc" id="L416">        return SELECT_DUMP_OPENOUTPUTS_SQL;</span>
    }

    /**
     * &lt;p&gt;If there isn't a connection on the {@link ThreadLocal} then create and store it.&lt;/p&gt;
     * &lt;p&gt;This will also automatically set up the schema if it does not exist within the DB.&lt;/p&gt;
     * @throws BlockStoreException if successful connection to the DB couldn't be made.
     */
    protected synchronized final void maybeConnect() throws BlockStoreException {
        try {
<span class="pc bpc" id="L426" title="1 of 4 branches missed.">            if (conn.get() != null &amp;&amp; !conn.get().isClosed())</span>
<span class="fc" id="L427">                return;</span>

<span class="pc bpc" id="L429" title="2 of 4 branches missed.">            if (username == null || password == null) {</span>
<span class="nc" id="L430">                conn.set(DriverManager.getConnection(connectionURL));</span>
            } else {
<span class="fc" id="L432">                Properties props = new Properties();</span>
<span class="fc" id="L433">                props.setProperty(&quot;user&quot;, this.username);</span>
<span class="fc" id="L434">                props.setProperty(&quot;password&quot;, this.password);</span>
<span class="fc" id="L435">                conn.set(DriverManager.getConnection(connectionURL, props));</span>
            }
<span class="fc" id="L437">            allConnections.add(conn.get());</span>
<span class="fc" id="L438">            Connection connection = conn.get();</span>
            // set the schema if one is needed
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">            if (schemaName != null) {</span>
<span class="nc" id="L441">                Statement s = connection.createStatement();</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">                for (String sql : getCreateSchemeSQL()) {</span>
<span class="nc" id="L443">                    s.execute(sql);</span>
<span class="nc" id="L444">                }</span>
            }
<span class="fc" id="L446">            log.info(&quot;Made a new connection to database &quot; + connectionURL);</span>
<span class="nc" id="L447">        } catch (SQLException ex) {</span>
<span class="nc" id="L448">            throw new BlockStoreException(ex);</span>
<span class="fc" id="L449">        }</span>
<span class="fc" id="L450">    }</span>

    @Override
    public synchronized void close() {
<span class="fc bfc" id="L454" title="All 2 branches covered.">        for (Connection conn : allConnections) {</span>
            try {
<span class="pc bpc" id="L456" title="1 of 2 branches missed.">                if (!conn.getAutoCommit()) {</span>
<span class="nc" id="L457">                    conn.rollback();</span>
                }
<span class="fc" id="L459">                conn.close();</span>
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">                if (conn == this.conn.get()) {</span>
<span class="fc" id="L461">                    this.conn.set(null);</span>
                }
<span class="nc" id="L463">            } catch (SQLException ex) {</span>
<span class="nc" id="L464">                throw new RuntimeException(ex);</span>
<span class="fc" id="L465">            }</span>
<span class="fc" id="L466">        }</span>
<span class="fc" id="L467">        allConnections.clear();</span>
<span class="fc" id="L468">    }</span>

    /**
     * &lt;p&gt;Check if a tables exists within the database.&lt;/p&gt;
     *
     * &lt;p&gt;This specifically checks for the 'settings' table and
     * if it exists makes an assumption that the rest of the data
     * structures are present.&lt;/p&gt;
     *
     * @return If the tables exists.
     * @throws java.sql.SQLException
     */
    private boolean tablesExists() throws SQLException {
<span class="fc" id="L481">        PreparedStatement ps = null;</span>
        try {
<span class="nc" id="L483">            ps = conn.get().prepareStatement(getTablesExistSQL());</span>
<span class="nc" id="L484">            ResultSet results = ps.executeQuery();</span>
<span class="nc" id="L485">            results.close();</span>
<span class="nc" id="L486">            return true;</span>
<span class="fc" id="L487">        } catch (SQLException ex) {</span>
<span class="fc" id="L488">            return false;</span>
        } finally {
<span class="pc bpc" id="L490" title="11 of 12 branches missed.">            if(ps != null &amp;&amp; !ps.isClosed()) {</span>
<span class="nc" id="L491">                ps.close();</span>
            }
        }
    }

    /**
     * Check that the database is compatible with this version of the {@link DatabaseFullPrunedBlockStore}.
     * @throws BlockStoreException If the database is not compatible.
     */
    private void checkCompatibility() throws SQLException, BlockStoreException {
<span class="nc bnc" id="L501" title="All 2 branches missed.">        for(String sql : getCompatibilitySQL()) {</span>
<span class="nc" id="L502">            PreparedStatement ps = null;</span>
            try {
<span class="nc" id="L504">                ps = conn.get().prepareStatement(sql);</span>
<span class="nc" id="L505">                ResultSet results = ps.executeQuery();</span>
<span class="nc" id="L506">                results.close();</span>
<span class="nc" id="L507">            } catch (SQLException ex) {</span>
<span class="nc" id="L508">                throw new BlockStoreException(&quot;Database block store is not compatible with the current release.  &quot; +</span>
<span class="nc" id="L509">                        &quot;See bitcoinj release notes for further information: &quot; + ex.getMessage());</span>
            } finally {
<span class="nc bnc" id="L511" title="All 8 branches missed.">                if (ps != null &amp;&amp; !ps.isClosed()) {</span>
<span class="nc" id="L512">                    ps.close();</span>
                }
            }
<span class="nc" id="L515">        }</span>
<span class="nc" id="L516">    }</span>

    /**
     * Create the tables/block store in the database and
     * @throws java.sql.SQLException If there is a database error.
     * @throws BlockStoreException If the block store could not be created.
     */
    private void createTables() throws SQLException, BlockStoreException {
<span class="fc" id="L524">        Statement s = conn.get().createStatement();</span>
        // create all the database tables
<span class="fc bfc" id="L526" title="All 2 branches covered.">        for (String sql : getCreateTablesSQL()) {</span>
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L528">                log.debug(&quot;DatabaseFullPrunedBlockStore : CREATE table [SQL= {0}]&quot;, sql);</span>
            }
<span class="fc" id="L530">            s.executeUpdate(sql);</span>
<span class="fc" id="L531">        }</span>
        // create all the database indexes
<span class="fc bfc" id="L533" title="All 2 branches covered.">        for (String sql : getCreateIndexesSQL()) {</span>
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L535">                log.debug(&quot;DatabaseFullPrunedBlockStore : CREATE index [SQL= {0}]&quot;, sql);</span>
            }
<span class="fc" id="L537">            s.executeUpdate(sql);</span>
<span class="fc" id="L538">        }</span>
<span class="fc" id="L539">        s.close();</span>

        // insert the initial settings for this store
<span class="fc" id="L542">        PreparedStatement ps = conn.get().prepareStatement(getInsertSettingsSQL());</span>
<span class="fc" id="L543">        ps.setString(1, CHAIN_HEAD_SETTING);</span>
<span class="fc" id="L544">        ps.setNull(2, Types.BINARY);</span>
<span class="fc" id="L545">        ps.execute();</span>
<span class="fc" id="L546">        ps.setString(1, VERIFIED_CHAIN_HEAD_SETTING);</span>
<span class="fc" id="L547">        ps.setNull(2, Types.BINARY);</span>
<span class="fc" id="L548">        ps.execute();</span>
<span class="fc" id="L549">        ps.setString(1, VERSION_SETTING);</span>
<span class="fc" id="L550">        ps.setBytes(2, &quot;03&quot;.getBytes());</span>
<span class="fc" id="L551">        ps.execute();</span>
<span class="fc" id="L552">        ps.close();</span>
<span class="fc" id="L553">        createNewStore(params);</span>
<span class="fc" id="L554">    }</span>

    /**
     * Create a new store for the given {@link org.bitcoinj.core.NetworkParameters}.
     * @param params The network.
     * @throws BlockStoreException If the store couldn't be created.
     */
    private void createNewStore(NetworkParameters params) throws BlockStoreException {
        try {
            // Set up the genesis block. When we start out fresh, it is by
            // definition the top of the chain.
<span class="fc" id="L565">            StoredBlock storedGenesisHeader = new StoredBlock(params.getGenesisBlock().cloneAsHeader(), params.getGenesisBlock().getWork(), 0);</span>
            // The coinbase in the genesis block is not spendable. This is because of how Bitcoin Core inits
            // its database - the genesis transaction isn't actually in the db so its spent flags can never be updated.
<span class="fc" id="L568">            List&lt;Transaction&gt; genesisTransactions = Lists.newLinkedList();</span>
<span class="fc" id="L569">            StoredUndoableBlock storedGenesis = new StoredUndoableBlock(params.getGenesisBlock().getHash(), genesisTransactions);</span>
<span class="fc" id="L570">            put(storedGenesisHeader, storedGenesis);</span>
<span class="fc" id="L571">            setChainHead(storedGenesisHeader);</span>
<span class="fc" id="L572">            setVerifiedChainHead(storedGenesisHeader);</span>
<span class="nc" id="L573">        } catch (VerificationException e) {</span>
<span class="nc" id="L574">            throw new RuntimeException(e); // Cannot happen.</span>
<span class="fc" id="L575">        }</span>
<span class="fc" id="L576">    }</span>

    /**
     * Initialise the store state from the database.
     * @throws java.sql.SQLException If there is a database error.
     * @throws BlockStoreException If there is a block store error.
     */
    private void initFromDatabase() throws SQLException, BlockStoreException {
<span class="fc" id="L584">        PreparedStatement ps = conn.get().prepareStatement(getSelectSettingsSQL());</span>
        ResultSet rs;
<span class="fc" id="L586">        ps.setString(1, CHAIN_HEAD_SETTING);</span>
<span class="fc" id="L587">        rs = ps.executeQuery();</span>
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">        if (!rs.next()) {</span>
<span class="nc" id="L589">            throw new BlockStoreException(&quot;corrupt database block store - no chain head pointer&quot;);</span>
        }
<span class="fc" id="L591">        Sha256Hash hash = Sha256Hash.wrap(rs.getBytes(1));</span>
<span class="fc" id="L592">        rs.close();</span>
<span class="fc" id="L593">        this.chainHeadBlock = get(hash);</span>
<span class="fc" id="L594">        this.chainHeadHash = hash;</span>
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">        if (this.chainHeadBlock == null) {</span>
<span class="nc" id="L596">            throw new BlockStoreException(&quot;corrupt database block store - head block not found&quot;);</span>
        }
<span class="fc" id="L598">        ps.setString(1, VERIFIED_CHAIN_HEAD_SETTING);</span>
<span class="fc" id="L599">        rs = ps.executeQuery();</span>
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">        if (!rs.next()) {</span>
<span class="nc" id="L601">            throw new BlockStoreException(&quot;corrupt database block store - no verified chain head pointer&quot;);</span>
        }
<span class="fc" id="L603">        hash = Sha256Hash.wrap(rs.getBytes(1));</span>
<span class="fc" id="L604">        rs.close();</span>
<span class="fc" id="L605">        ps.close();</span>
<span class="fc" id="L606">        this.verifiedChainHeadBlock = get(hash);</span>
<span class="fc" id="L607">        this.verifiedChainHeadHash = hash;</span>
<span class="pc bpc" id="L608" title="1 of 2 branches missed.">        if (this.verifiedChainHeadBlock == null) {</span>
<span class="nc" id="L609">            throw new BlockStoreException(&quot;corrupt database block store - verified head block not found&quot;);</span>
        }
<span class="fc" id="L611">    }</span>

    protected void putUpdateStoredBlock(StoredBlock storedBlock, boolean wasUndoable) throws SQLException {
        try {
<span class="fc" id="L615">            PreparedStatement s =</span>
<span class="fc" id="L616">                    conn.get().prepareStatement(getInsertHeadersSQL());</span>
            // We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes
<span class="fc" id="L618">            byte[] hashBytes = new byte[28];</span>
<span class="fc" id="L619">            System.arraycopy(storedBlock.getHeader().getHash().getBytes(), 4, hashBytes, 0, 28);</span>
<span class="fc" id="L620">            s.setBytes(1, hashBytes);</span>
<span class="fc" id="L621">            s.setBytes(2, storedBlock.getChainWork().toByteArray());</span>
<span class="fc" id="L622">            s.setInt(3, storedBlock.getHeight());</span>
<span class="fc" id="L623">            s.setBytes(4, storedBlock.getHeader().cloneAsHeader().unsafeBitcoinSerialize());</span>
<span class="fc" id="L624">            s.setBoolean(5, wasUndoable);</span>
<span class="fc" id="L625">            s.executeUpdate();</span>
<span class="fc" id="L626">            s.close();</span>
<span class="nc" id="L627">        } catch (SQLException e) {</span>
            // It is possible we try to add a duplicate StoredBlock if we upgraded
            // In that case, we just update the entry to mark it wasUndoable
<span class="nc bnc" id="L630" title="All 4 branches missed.">            if  (!(e.getSQLState().equals(getDuplicateKeyErrorCode())) || !wasUndoable)</span>
<span class="nc" id="L631">                throw e;</span>

<span class="nc" id="L633">            PreparedStatement s = conn.get().prepareStatement(getUpdateHeadersSQL());</span>
<span class="nc" id="L634">            s.setBoolean(1, true);</span>
            // We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes
<span class="nc" id="L636">            byte[] hashBytes = new byte[28];</span>
<span class="nc" id="L637">            System.arraycopy(storedBlock.getHeader().getHash().getBytes(), 4, hashBytes, 0, 28);</span>
<span class="nc" id="L638">            s.setBytes(2, hashBytes);</span>
<span class="nc" id="L639">            s.executeUpdate();</span>
<span class="nc" id="L640">            s.close();</span>
<span class="fc" id="L641">        }</span>
<span class="fc" id="L642">    }</span>

    @Override
    public void put(StoredBlock storedBlock) throws BlockStoreException {
<span class="nc" id="L646">        maybeConnect();</span>
        try {
<span class="nc" id="L648">            putUpdateStoredBlock(storedBlock, false);</span>
<span class="nc" id="L649">        } catch (SQLException e) {</span>
<span class="nc" id="L650">            throw new BlockStoreException(e);</span>
<span class="nc" id="L651">        }</span>
<span class="nc" id="L652">    }</span>


    @Override
    public void put(StoredBlock storedBlock, StoredUndoableBlock undoableBlock) throws BlockStoreException {
<span class="fc" id="L657">        maybeConnect();</span>
        // We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes
<span class="fc" id="L659">        byte[] hashBytes = new byte[28];</span>
<span class="fc" id="L660">        System.arraycopy(storedBlock.getHeader().getHash().getBytes(), 4, hashBytes, 0, 28);</span>
<span class="fc" id="L661">        int height = storedBlock.getHeight();</span>
<span class="fc" id="L662">        byte[] transactions = null;</span>
<span class="fc" id="L663">        byte[] txOutChanges = null;</span>
        try {
<span class="fc" id="L665">            ByteArrayOutputStream bos = new ByteArrayOutputStream();</span>
<span class="fc bfc" id="L666" title="All 2 branches covered.">            if (undoableBlock.getTxOutChanges() != null) {</span>
<span class="fc" id="L667">                undoableBlock.getTxOutChanges().serializeToStream(bos);</span>
<span class="fc" id="L668">                txOutChanges = bos.toByteArray();</span>
            } else {
<span class="fc" id="L670">                int numTxn = undoableBlock.getTransactions().size();</span>
<span class="fc" id="L671">                bos.write(0xFF &amp; numTxn);</span>
<span class="fc" id="L672">                bos.write(0xFF &amp; (numTxn &gt;&gt; 8));</span>
<span class="fc" id="L673">                bos.write(0xFF &amp; (numTxn &gt;&gt; 16));</span>
<span class="fc" id="L674">                bos.write(0xFF &amp; (numTxn &gt;&gt; 24));</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">                for (Transaction tx : undoableBlock.getTransactions())</span>
<span class="fc" id="L676">                    tx.bitcoinSerialize(bos);</span>
<span class="fc" id="L677">                transactions = bos.toByteArray();</span>
            }
<span class="fc" id="L679">            bos.close();</span>
<span class="nc" id="L680">        } catch (IOException e) {</span>
<span class="nc" id="L681">            throw new BlockStoreException(e);</span>
<span class="fc" id="L682">        }</span>

        try {
            try {
<span class="fc" id="L686">                PreparedStatement s =</span>
<span class="fc" id="L687">                        conn.get().prepareStatement(getInsertUndoableBlocksSQL());</span>
<span class="fc" id="L688">                s.setBytes(1, hashBytes);</span>
<span class="fc" id="L689">                s.setInt(2, height);</span>
<span class="fc bfc" id="L690" title="All 2 branches covered.">                if (transactions == null) {</span>
<span class="fc" id="L691">                    s.setBytes(3, txOutChanges);</span>
<span class="fc" id="L692">                    s.setNull(4, Types.BINARY);</span>
                } else {
<span class="fc" id="L694">                    s.setNull(3, Types.BINARY);</span>
<span class="fc" id="L695">                    s.setBytes(4, transactions);</span>
                }
<span class="fc" id="L697">                s.executeUpdate();</span>
<span class="fc" id="L698">                s.close();</span>
                try {
<span class="fc" id="L700">                    putUpdateStoredBlock(storedBlock, true);</span>
<span class="nc" id="L701">                } catch (SQLException e) {</span>
<span class="nc" id="L702">                    throw new BlockStoreException(e);</span>
<span class="fc" id="L703">                }</span>
<span class="fc" id="L704">            } catch (SQLException e) {</span>
<span class="pc bpc" id="L705" title="1 of 2 branches missed.">                if (!e.getSQLState().equals(getDuplicateKeyErrorCode()))</span>
<span class="nc" id="L706">                    throw new BlockStoreException(e);</span>

                // There is probably an update-or-insert statement, but it wasn't obvious from the docs
<span class="fc" id="L709">                PreparedStatement s =</span>
<span class="fc" id="L710">                        conn.get().prepareStatement(getUpdateUndoableBlocksSQL());</span>
<span class="fc" id="L711">                s.setBytes(3, hashBytes);</span>
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">                if (transactions == null) {</span>
<span class="fc" id="L713">                    s.setBytes(1, txOutChanges);</span>
<span class="fc" id="L714">                    s.setNull(2, Types.BINARY);</span>
                } else {
<span class="nc" id="L716">                    s.setNull(1, Types.BINARY);</span>
<span class="nc" id="L717">                    s.setBytes(2, transactions);</span>
                }
<span class="fc" id="L719">                s.executeUpdate();</span>
<span class="fc" id="L720">                s.close();</span>
<span class="fc" id="L721">            }</span>
<span class="nc" id="L722">        } catch (SQLException ex) {</span>
<span class="nc" id="L723">            throw new BlockStoreException(ex);</span>
<span class="fc" id="L724">        }</span>
<span class="fc" id="L725">    }</span>

    public StoredBlock get(Sha256Hash hash, boolean wasUndoableOnly) throws BlockStoreException {
        // Optimize for chain head
<span class="pc bpc" id="L729" title="1 of 4 branches missed.">        if (chainHeadHash != null &amp;&amp; chainHeadHash.equals(hash))</span>
<span class="fc" id="L730">            return chainHeadBlock;</span>
<span class="pc bpc" id="L731" title="2 of 4 branches missed.">        if (verifiedChainHeadHash != null &amp;&amp; verifiedChainHeadHash.equals(hash))</span>
<span class="nc" id="L732">            return verifiedChainHeadBlock;</span>
<span class="fc" id="L733">        maybeConnect();</span>
<span class="fc" id="L734">        PreparedStatement s = null;</span>
        try {
<span class="fc" id="L736">            s = conn.get()</span>
<span class="fc" id="L737">                    .prepareStatement(getSelectHeadersSQL());</span>
            // We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes
<span class="fc" id="L739">            byte[] hashBytes = new byte[28];</span>
<span class="fc" id="L740">            System.arraycopy(hash.getBytes(), 4, hashBytes, 0, 28);</span>
<span class="fc" id="L741">            s.setBytes(1, hashBytes);</span>
<span class="fc" id="L742">            ResultSet results = s.executeQuery();</span>
<span class="fc bfc" id="L743" title="All 2 branches covered.">            if (!results.next()) {</span>
<span class="fc" id="L744">                return null;</span>
            }
            // Parse it.

<span class="pc bpc" id="L748" title="1 of 4 branches missed.">            if (wasUndoableOnly &amp;&amp; !results.getBoolean(4))</span>
<span class="nc" id="L749">                return null;</span>

<span class="fc" id="L751">            BigInteger chainWork = new BigInteger(results.getBytes(1));</span>
<span class="fc" id="L752">            int height = results.getInt(2);</span>
<span class="fc" id="L753">            Block b = params.getDefaultSerializer().makeBlock(results.getBytes(3));</span>
<span class="fc" id="L754">            b.verifyHeader();</span>
<span class="fc" id="L755">            StoredBlock stored = new StoredBlock(b, chainWork, height);</span>
<span class="fc" id="L756">            return stored;</span>
<span class="nc" id="L757">        } catch (SQLException ex) {</span>
<span class="nc" id="L758">            throw new BlockStoreException(ex);</span>
<span class="nc" id="L759">        } catch (ProtocolException e) {</span>
            // Corrupted database.
<span class="nc" id="L761">            throw new BlockStoreException(e);</span>
<span class="nc" id="L762">        } catch (VerificationException e) {</span>
            // Should not be able to happen unless the database contains bad
            // blocks.
<span class="nc" id="L765">            throw new BlockStoreException(e);</span>
        } finally {
<span class="pc bpc" id="L767" title="6 of 8 branches missed.">            if (s != null) {</span>
                try {
<span class="pc" id="L769">                    s.close();</span>
<span class="nc" id="L770">                } catch (SQLException e) {</span>
<span class="nc" id="L771">                    throw new BlockStoreException(&quot;Failed to close PreparedStatement&quot;);</span>
<span class="pc" id="L772">                }</span>
            }
        }
    }

    @Override
    public StoredBlock get(Sha256Hash hash) throws BlockStoreException {
<span class="fc" id="L779">        return get(hash, false);</span>
    }

    @Override
    public StoredBlock getOnceUndoableStoredBlock(Sha256Hash hash) throws BlockStoreException {
<span class="fc" id="L784">        return get(hash, true);</span>
    }

    @Override
    public StoredUndoableBlock getUndoBlock(Sha256Hash hash) throws BlockStoreException {
<span class="fc" id="L789">        maybeConnect();</span>
<span class="fc" id="L790">        PreparedStatement s = null;</span>
        try {
<span class="fc" id="L792">            s = conn.get()</span>
<span class="fc" id="L793">                    .prepareStatement(getSelectUndoableBlocksSQL());</span>
            // We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes

<span class="fc" id="L796">            byte[] hashBytes = new byte[28];</span>
<span class="fc" id="L797">            System.arraycopy(hash.getBytes(), 4, hashBytes, 0, 28);</span>
<span class="fc" id="L798">            s.setBytes(1, hashBytes);</span>
<span class="fc" id="L799">            ResultSet results = s.executeQuery();</span>
<span class="pc bpc" id="L800" title="1 of 2 branches missed.">            if (!results.next()) {</span>
<span class="nc" id="L801">                return null;</span>
            }
            // Parse it.
<span class="fc" id="L804">            byte[] txOutChanges = results.getBytes(1);</span>
<span class="fc" id="L805">            byte[] transactions = results.getBytes(2);</span>
            StoredUndoableBlock block;
<span class="fc bfc" id="L807" title="All 2 branches covered.">            if (txOutChanges == null) {</span>
<span class="fc" id="L808">                int offset = 0;</span>
<span class="fc" id="L809">                int numTxn = ((transactions[offset++] &amp; 0xFF)) |</span>
                        ((transactions[offset++] &amp; 0xFF) &lt;&lt; 8) |
                        ((transactions[offset++] &amp; 0xFF) &lt;&lt; 16) |
                        ((transactions[offset++] &amp; 0xFF) &lt;&lt; 24);
<span class="fc" id="L813">                List&lt;Transaction&gt; transactionList = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">                for (int i = 0; i &lt; numTxn; i++) {</span>
<span class="fc" id="L815">                    Transaction tx = params.getDefaultSerializer().makeTransaction(transactions, offset);</span>
<span class="fc" id="L816">                    transactionList.add(tx);</span>
<span class="fc" id="L817">                    offset += tx.getMessageSize();</span>
                }
<span class="fc" id="L819">                block = new StoredUndoableBlock(hash, transactionList);</span>
<span class="fc" id="L820">            } else {</span>
<span class="fc" id="L821">                TransactionOutputChanges outChangesObject =</span>
                        new TransactionOutputChanges(new ByteArrayInputStream(txOutChanges));
<span class="fc" id="L823">                block = new StoredUndoableBlock(hash, outChangesObject);</span>
            }
<span class="fc" id="L825">            return block;</span>
<span class="nc" id="L826">        } catch (SQLException ex) {</span>
<span class="nc" id="L827">            throw new BlockStoreException(ex);</span>
<span class="nc" id="L828">        } catch (NullPointerException e) {</span>
            // Corrupted database.
<span class="nc" id="L830">            throw new BlockStoreException(e);</span>
<span class="nc" id="L831">        } catch (ClassCastException e) {</span>
            // Corrupted database.
<span class="nc" id="L833">            throw new BlockStoreException(e);</span>
<span class="nc" id="L834">        } catch (ProtocolException e) {</span>
            // Corrupted database.
<span class="nc" id="L836">            throw new BlockStoreException(e);</span>
<span class="nc" id="L837">        } catch (IOException e) {</span>
            // Corrupted database.
<span class="nc" id="L839">            throw new BlockStoreException(e);</span>
        } finally {
<span class="pc bpc" id="L841" title="5 of 6 branches missed.">            if (s != null) {</span>
                try {
<span class="pc" id="L843">                    s.close();</span>
<span class="nc" id="L844">                } catch (SQLException e) {</span>
<span class="nc" id="L845">                    throw new BlockStoreException(&quot;Failed to close PreparedStatement&quot;);</span>
<span class="pc" id="L846">                }</span>
            }
        }
    }

    @Override
    public StoredBlock getChainHead() throws BlockStoreException {
<span class="fc" id="L853">        return chainHeadBlock;</span>
    }

    @Override
    public void setChainHead(StoredBlock chainHead) throws BlockStoreException {
<span class="fc" id="L858">        Sha256Hash hash = chainHead.getHeader().getHash();</span>
<span class="fc" id="L859">        this.chainHeadHash = hash;</span>
<span class="fc" id="L860">        this.chainHeadBlock = chainHead;</span>
<span class="fc" id="L861">        maybeConnect();</span>
        try {
<span class="fc" id="L863">            PreparedStatement s = conn.get()</span>
<span class="fc" id="L864">                    .prepareStatement(getUpdateSettingsSLQ());</span>
<span class="fc" id="L865">            s.setString(2, CHAIN_HEAD_SETTING);</span>
<span class="fc" id="L866">            s.setBytes(1, hash.getBytes());</span>
<span class="fc" id="L867">            s.executeUpdate();</span>
<span class="fc" id="L868">            s.close();</span>
<span class="nc" id="L869">        } catch (SQLException ex) {</span>
<span class="nc" id="L870">            throw new BlockStoreException(ex);</span>
<span class="fc" id="L871">        }</span>
<span class="fc" id="L872">    }</span>

    @Override
    public StoredBlock getVerifiedChainHead() throws BlockStoreException {
<span class="fc" id="L876">        return verifiedChainHeadBlock;</span>
    }

    @Override
    public void setVerifiedChainHead(StoredBlock chainHead) throws BlockStoreException {
<span class="fc" id="L881">        Sha256Hash hash = chainHead.getHeader().getHash();</span>
<span class="fc" id="L882">        this.verifiedChainHeadHash = hash;</span>
<span class="fc" id="L883">        this.verifiedChainHeadBlock = chainHead;</span>
<span class="fc" id="L884">        maybeConnect();</span>
        try {
<span class="fc" id="L886">            PreparedStatement s = conn.get()</span>
<span class="fc" id="L887">                    .prepareStatement(getUpdateSettingsSLQ());</span>
<span class="fc" id="L888">            s.setString(2, VERIFIED_CHAIN_HEAD_SETTING);</span>
<span class="fc" id="L889">            s.setBytes(1, hash.getBytes());</span>
<span class="fc" id="L890">            s.executeUpdate();</span>
<span class="fc" id="L891">            s.close();</span>
<span class="nc" id="L892">        } catch (SQLException ex) {</span>
<span class="nc" id="L893">            throw new BlockStoreException(ex);</span>
<span class="fc" id="L894">        }</span>
<span class="fc bfc" id="L895" title="All 2 branches covered.">        if (this.chainHeadBlock.getHeight() &lt; chainHead.getHeight())</span>
<span class="fc" id="L896">            setChainHead(chainHead);</span>
<span class="fc" id="L897">        removeUndoableBlocksWhereHeightIsLessThan(chainHead.getHeight() - fullStoreDepth);</span>
<span class="fc" id="L898">    }</span>

    private void removeUndoableBlocksWhereHeightIsLessThan(int height) throws BlockStoreException {
        try {
<span class="fc" id="L902">            PreparedStatement s = conn.get()</span>
<span class="fc" id="L903">                    .prepareStatement(getDeleteUndoableBlocksSQL());</span>
<span class="fc" id="L904">            s.setInt(1, height);</span>
<span class="pc bpc" id="L905" title="1 of 2 branches missed.">            if (log.isDebugEnabled())</span>
<span class="nc" id="L906">                log.debug(&quot;Deleting undoable undoable block with height &lt;= &quot; + height);</span>
<span class="fc" id="L907">            s.executeUpdate();</span>
<span class="fc" id="L908">            s.close();</span>
<span class="nc" id="L909">        } catch (SQLException ex) {</span>
<span class="nc" id="L910">            throw new BlockStoreException(ex);</span>
<span class="fc" id="L911">        }</span>
<span class="fc" id="L912">    }</span>

    @Override
    public UTXO getTransactionOutput(Sha256Hash hash, long index) throws BlockStoreException {
<span class="fc" id="L916">        maybeConnect();</span>
<span class="fc" id="L917">        PreparedStatement s = null;</span>
        try {
<span class="fc" id="L919">            s = conn.get()</span>
<span class="fc" id="L920">                    .prepareStatement(getSelectOpenoutputsSQL());</span>
<span class="fc" id="L921">            s.setBytes(1, hash.getBytes());</span>
            // index is actually an unsigned int
<span class="fc" id="L923">            s.setInt(2, (int) index);</span>
<span class="fc" id="L924">            ResultSet results = s.executeQuery();</span>
<span class="fc bfc" id="L925" title="All 2 branches covered.">            if (!results.next()) {</span>
<span class="fc" id="L926">                return null;</span>
            }
            // Parse it.
<span class="fc" id="L929">            int height = results.getInt(1);</span>
<span class="fc" id="L930">            Coin value = Coin.valueOf(results.getLong(2));</span>
<span class="fc" id="L931">            byte[] scriptBytes = results.getBytes(3);</span>
<span class="fc" id="L932">            boolean coinbase = results.getBoolean(4);</span>
<span class="fc" id="L933">            String address = results.getString(5);</span>
<span class="fc" id="L934">            UTXO txout = new UTXO(hash,</span>
                    index,
                    value,
                    height,
                    coinbase,
                    new Script(scriptBytes),
                    address);
<span class="fc" id="L941">            return txout;</span>
<span class="nc" id="L942">        } catch (SQLException ex) {</span>
<span class="nc" id="L943">            throw new BlockStoreException(ex);</span>
        } finally {
<span class="pc bpc" id="L945" title="4 of 6 branches missed.">            if (s != null) {</span>
                try {
<span class="pc" id="L947">                    s.close();</span>
<span class="nc" id="L948">                } catch (SQLException e) {</span>
<span class="nc" id="L949">                    throw new BlockStoreException(&quot;Failed to close PreparedStatement&quot;);</span>
<span class="pc" id="L950">                }</span>
            }
        }
    }

    @Override
    public void addUnspentTransactionOutput(UTXO out) throws BlockStoreException {
<span class="fc" id="L957">        maybeConnect();</span>
<span class="fc" id="L958">        PreparedStatement s = null;</span>
        try {
<span class="fc" id="L960">            s = conn.get().prepareStatement(getInsertOpenoutputsSQL());</span>
<span class="fc" id="L961">            s.setBytes(1, out.getHash().getBytes());</span>
            // index is actually an unsigned int
<span class="fc" id="L963">            s.setInt(2, (int) out.getIndex());</span>
<span class="fc" id="L964">            s.setInt(3, out.getHeight());</span>
<span class="fc" id="L965">            s.setLong(4, out.getValue().value);</span>
<span class="fc" id="L966">            s.setBytes(5, out.getScript().getProgram());</span>
<span class="fc" id="L967">            s.setString(6, out.getAddress());</span>
<span class="fc" id="L968">            s.setInt(7, out.getScript().getScriptType().ordinal());</span>
<span class="fc" id="L969">            s.setBoolean(8, out.isCoinbase());</span>
<span class="fc" id="L970">            s.executeUpdate();</span>
<span class="fc" id="L971">            s.close();</span>
<span class="nc" id="L972">        } catch (SQLException e) {</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">            if (!(e.getSQLState().equals(getDuplicateKeyErrorCode())))</span>
<span class="nc" id="L974">                throw new BlockStoreException(e);</span>
        } finally {
<span class="pc bpc" id="L976" title="5 of 6 branches missed.">            if (s != null) {</span>
                try {
<span class="pc" id="L978">                    s.close();</span>
<span class="nc" id="L979">                } catch (SQLException e) {</span>
<span class="nc" id="L980">                    throw new BlockStoreException(e);</span>
<span class="pc" id="L981">                }</span>
            }
        }
<span class="fc" id="L984">    }</span>

    @Override
    public void removeUnspentTransactionOutput(UTXO out) throws BlockStoreException {
<span class="fc" id="L988">        maybeConnect();</span>
        // TODO: This should only need one query (maybe a stored procedure)
<span class="pc bpc" id="L990" title="1 of 2 branches missed.">        if (getTransactionOutput(out.getHash(), out.getIndex()) == null)</span>
<span class="nc" id="L991">            throw new BlockStoreException(&quot;Tried to remove a UTXO from DatabaseFullPrunedBlockStore that it didn't have!&quot;);</span>
        try {
<span class="fc" id="L993">            PreparedStatement s = conn.get()</span>
<span class="fc" id="L994">                    .prepareStatement(getDeleteOpenoutputsSQL());</span>
<span class="fc" id="L995">            s.setBytes(1, out.getHash().getBytes());</span>
            // index is actually an unsigned int
<span class="fc" id="L997">            s.setInt(2, (int)out.getIndex());</span>
<span class="fc" id="L998">            s.executeUpdate();</span>
<span class="fc" id="L999">            s.close();</span>
<span class="nc" id="L1000">        } catch (SQLException e) {</span>
<span class="nc" id="L1001">            throw new BlockStoreException(e);</span>
<span class="fc" id="L1002">        }</span>
<span class="fc" id="L1003">    }</span>

    @Override
    public void beginDatabaseBatchWrite() throws BlockStoreException {
<span class="fc" id="L1007">        maybeConnect();</span>
<span class="pc bpc" id="L1008" title="1 of 2 branches missed.">        if (log.isDebugEnabled())</span>
<span class="nc" id="L1009">            log.debug(&quot;Starting database batch write with connection: &quot; + conn.get().toString());</span>
        try {
<span class="fc" id="L1011">            conn.get().setAutoCommit(false);</span>
<span class="nc" id="L1012">        } catch (SQLException e) {</span>
<span class="nc" id="L1013">            throw new BlockStoreException(e);</span>
<span class="fc" id="L1014">        }</span>
<span class="fc" id="L1015">    }</span>

    @Override
    public void commitDatabaseBatchWrite() throws BlockStoreException {
<span class="fc" id="L1019">        maybeConnect();</span>
<span class="pc bpc" id="L1020" title="1 of 2 branches missed.">        if (log.isDebugEnabled())</span>
<span class="nc" id="L1021">            log.debug(&quot;Committing database batch write with connection: &quot; + conn.get().toString());</span>
        try {
<span class="fc" id="L1023">            conn.get().commit();</span>
<span class="fc" id="L1024">            conn.get().setAutoCommit(true);</span>
<span class="nc" id="L1025">        } catch (SQLException e) {</span>
<span class="nc" id="L1026">            throw new BlockStoreException(e);</span>
<span class="fc" id="L1027">        }</span>
<span class="fc" id="L1028">    }</span>

    @Override
    public void abortDatabaseBatchWrite() throws BlockStoreException {
<span class="fc" id="L1032">        maybeConnect();</span>
<span class="pc bpc" id="L1033" title="1 of 2 branches missed.">        if (log.isDebugEnabled())</span>
<span class="nc" id="L1034">            log.debug(&quot;Rollback database batch write with connection: &quot; + conn.get().toString());</span>
        try {
<span class="fc bfc" id="L1036" title="All 2 branches covered.">            if (!conn.get().getAutoCommit()) {</span>
<span class="fc" id="L1037">                conn.get().rollback();</span>
<span class="fc" id="L1038">                conn.get().setAutoCommit(true);</span>
            } else {
<span class="fc" id="L1040">                log.warn(&quot;Warning: Rollback attempt without transaction&quot;);</span>
            }
<span class="nc" id="L1042">        } catch (SQLException e) {</span>
<span class="nc" id="L1043">            throw new BlockStoreException(e);</span>
<span class="fc" id="L1044">        }</span>
<span class="fc" id="L1045">    }</span>

    @Override
    public boolean hasUnspentOutputs(Sha256Hash hash, int numOutputs) throws BlockStoreException {
<span class="fc" id="L1049">        maybeConnect();</span>
<span class="fc" id="L1050">        PreparedStatement s = null;</span>
        try {
<span class="fc" id="L1052">            s = conn.get().prepareStatement(getSelectOpenoutputsCountSQL());</span>
<span class="fc" id="L1053">            s.setBytes(1, hash.getBytes());</span>
<span class="fc" id="L1054">            ResultSet results = s.executeQuery();</span>
<span class="pc bpc" id="L1055" title="1 of 2 branches missed.">            if (!results.next()) {</span>
<span class="nc" id="L1056">                throw new BlockStoreException(&quot;Got no results from a COUNT(*) query&quot;);</span>
            }
<span class="fc" id="L1058">            int count = results.getInt(1);</span>
<span class="fc bfc" id="L1059" title="All 2 branches covered.">            return count != 0;</span>
<span class="nc" id="L1060">        } catch (SQLException ex) {</span>
<span class="nc" id="L1061">            throw new BlockStoreException(ex);</span>
        } finally {
<span class="pc bpc" id="L1063" title="3 of 4 branches missed.">            if (s != null) {</span>
                try {
<span class="pc" id="L1065">                    s.close();</span>
<span class="nc" id="L1066">                } catch (SQLException e) {</span>
<span class="nc" id="L1067">                    throw new BlockStoreException(&quot;Failed to close PreparedStatement&quot;);</span>
<span class="pc" id="L1068">                }</span>
            }
        }
    }

    @Override
    public NetworkParameters getParams() {
<span class="fc" id="L1075">        return params;</span>
    }

    @Override
    public int getChainHeadHeight() throws UTXOProviderException {
        try {
<span class="fc" id="L1081">            return getVerifiedChainHead().getHeight();</span>
<span class="nc" id="L1082">        } catch (BlockStoreException e) {</span>
<span class="nc" id="L1083">            throw new UTXOProviderException(e);</span>
        }
    }

    /**
     * Resets the store by deleting the contents of the tables and reinitialising them.
     * @throws BlockStoreException If the tables couldn't be cleared and initialised.
     */
    public void resetStore() throws BlockStoreException {
<span class="fc" id="L1092">        maybeConnect();</span>
        try {
<span class="fc" id="L1094">            deleteStore();</span>
<span class="fc" id="L1095">            createTables();</span>
<span class="fc" id="L1096">            initFromDatabase();</span>
<span class="nc" id="L1097">        } catch (SQLException ex) {</span>
<span class="nc" id="L1098">            throw new RuntimeException(ex);</span>
<span class="fc" id="L1099">        }</span>
<span class="fc" id="L1100">    }</span>

    /**
     * Deletes the store by deleting the tables within the database.
     * @throws BlockStoreException If tables couldn't be deleted.
     */
    public void deleteStore() throws BlockStoreException {
<span class="fc" id="L1107">        maybeConnect();</span>
        try {
<span class="fc" id="L1109">            Statement s = conn.get().createStatement();</span>
<span class="fc bfc" id="L1110" title="All 2 branches covered.">            for(String sql : getDropTablesSQL()) {</span>
<span class="fc" id="L1111">                s.execute(sql);</span>
<span class="fc" id="L1112">            }</span>
<span class="fc" id="L1113">            s.close();</span>
<span class="nc" id="L1114">        } catch (SQLException ex) {</span>
<span class="nc" id="L1115">            throw new RuntimeException(ex);</span>
<span class="fc" id="L1116">        }</span>
<span class="fc" id="L1117">    }</span>

    /**
     * Calculate the balance for a coinbase, to-address, or p2sh address.
     *
     * &lt;p&gt;The balance {@link org.bitcoinj.store.DatabaseFullPrunedBlockStore#getBalanceSelectSQL()} returns
     * the balance (summed) as an number, then use calculateClientSide=false&lt;/p&gt;
     *
     * &lt;p&gt;The balance {@link org.bitcoinj.store.DatabaseFullPrunedBlockStore#getBalanceSelectSQL()} returns
     * the all the openoutputs as stored in the DB (binary), then use calculateClientSide=true&lt;/p&gt;
     *
     * @param address The address to calculate the balance of
     * @return The balance of the address supplied.  If the address has not been seen, or there are no outputs open for this
     *         address, the return value is 0.
     * @throws BlockStoreException If there is an error getting the balance.
     */
    public BigInteger calculateBalanceForAddress(Address address) throws BlockStoreException {
<span class="nc" id="L1134">        maybeConnect();</span>
<span class="nc" id="L1135">        PreparedStatement s = null;</span>
        try {
<span class="nc" id="L1137">            s = conn.get().prepareStatement(getBalanceSelectSQL());</span>
<span class="nc" id="L1138">            s.setString(1, address.toString());</span>
<span class="nc" id="L1139">            ResultSet rs = s.executeQuery();</span>
<span class="nc" id="L1140">            BigInteger balance = BigInteger.ZERO;</span>
<span class="nc bnc" id="L1141" title="All 2 branches missed.">            if (rs.next()) {</span>
<span class="nc" id="L1142">                return BigInteger.valueOf(rs.getLong(1));</span>
            }
<span class="nc" id="L1144">            return balance;</span>
<span class="nc" id="L1145">        } catch (SQLException ex) {</span>
<span class="nc" id="L1146">            throw new BlockStoreException(ex);</span>
        } finally {
<span class="nc bnc" id="L1148" title="All 6 branches missed.">            if (s != null) {</span>
                try {
<span class="nc" id="L1150">                    s.close();</span>
<span class="nc" id="L1151">                } catch (SQLException e) {</span>
<span class="nc" id="L1152">                    throw new BlockStoreException(&quot;Could not close statement&quot;);</span>
<span class="nc" id="L1153">                }</span>
            }
        }
    }

    @Override
    public List&lt;UTXO&gt; getOpenTransactionOutputs(List&lt;Address&gt; addresses) throws UTXOProviderException {
<span class="fc" id="L1160">        PreparedStatement s = null;</span>
<span class="fc" id="L1161">        List&lt;UTXO&gt; outputs = new ArrayList&lt;&gt;();</span>
        try {
<span class="fc" id="L1163">            maybeConnect();</span>
<span class="fc" id="L1164">            s = conn.get().prepareStatement(getTransactionOutputSelectSQL());</span>
<span class="fc bfc" id="L1165" title="All 2 branches covered.">            for (Address address : addresses) {</span>
<span class="fc" id="L1166">                s.setString(1, address.toString());</span>
<span class="fc" id="L1167">                ResultSet rs = s.executeQuery();</span>
<span class="fc bfc" id="L1168" title="All 2 branches covered.">                while (rs.next()) {</span>
<span class="fc" id="L1169">                    Sha256Hash hash = Sha256Hash.wrap(rs.getBytes(1));</span>
<span class="fc" id="L1170">                    Coin amount = Coin.valueOf(rs.getLong(2));</span>
<span class="fc" id="L1171">                    byte[] scriptBytes = rs.getBytes(3);</span>
<span class="fc" id="L1172">                    int height = rs.getInt(4);</span>
<span class="fc" id="L1173">                    int index = rs.getInt(5);</span>
<span class="fc" id="L1174">                    boolean coinbase = rs.getBoolean(6);</span>
<span class="fc" id="L1175">                    String toAddress = rs.getString(7);</span>
<span class="fc" id="L1176">                    UTXO output = new UTXO(hash,</span>
                            index,
                            amount,
                            height,
                            coinbase,
                            new Script(scriptBytes),
                            toAddress);
<span class="fc" id="L1183">                    outputs.add(output);</span>
<span class="fc" id="L1184">                }</span>
<span class="fc" id="L1185">            }</span>
<span class="fc" id="L1186">            return outputs;</span>
<span class="nc" id="L1187">        } catch (SQLException ex) {</span>
<span class="nc" id="L1188">            throw new UTXOProviderException(ex);</span>
<span class="nc" id="L1189">        } catch (BlockStoreException bse) {</span>
<span class="nc" id="L1190">            throw new UTXOProviderException(bse);</span>
        } finally {
<span class="pc bpc" id="L1192" title="3 of 4 branches missed.">            if (s != null)</span>
                try {
<span class="pc" id="L1194">                    s.close();</span>
<span class="nc" id="L1195">                } catch (SQLException e) {</span>
<span class="nc" id="L1196">                    throw new UTXOProviderException(&quot;Could not close statement&quot;, e);</span>
<span class="pc" id="L1197">                }</span>
        }
    }

    /**
     * Dumps information about the size of actual data in the database to standard output
     * The only truly useless data counted is printed in the form &quot;N in id indexes&quot;
     * This does not take database indexes into account.
     */
    public void dumpSizes() throws SQLException, BlockStoreException {
<span class="nc" id="L1207">        maybeConnect();</span>
<span class="nc" id="L1208">        Statement s = conn.get().createStatement();</span>
<span class="nc" id="L1209">        long size = 0;</span>
<span class="nc" id="L1210">        long totalSize = 0;</span>
<span class="nc" id="L1211">        int count = 0;</span>
<span class="nc" id="L1212">        ResultSet rs = s.executeQuery(getSelectSettingsDumpSQL());</span>
<span class="nc bnc" id="L1213" title="All 2 branches missed.">        while (rs.next()) {</span>
<span class="nc" id="L1214">            size += rs.getString(1).length();</span>
<span class="nc" id="L1215">            size += rs.getBytes(2).length;</span>
<span class="nc" id="L1216">            count++;</span>
        }
<span class="nc" id="L1218">        rs.close();</span>
<span class="nc" id="L1219">        System.out.printf(Locale.US, &quot;Settings size: %d, count: %d, average size: %f%n&quot;, size, count, (double)size/count);</span>

<span class="nc" id="L1221">        totalSize += size; size = 0; count = 0;</span>
<span class="nc" id="L1222">        rs = s.executeQuery(getSelectHeadersDumpSQL());</span>
<span class="nc bnc" id="L1223" title="All 2 branches missed.">        while (rs.next()) {</span>
<span class="nc" id="L1224">            size += 28; // hash</span>
<span class="nc" id="L1225">            size += rs.getBytes(1).length;</span>
<span class="nc" id="L1226">            size += 4; // height</span>
<span class="nc" id="L1227">            size += rs.getBytes(2).length;</span>
<span class="nc" id="L1228">            count++;</span>
        }
<span class="nc" id="L1230">        rs.close();</span>
<span class="nc" id="L1231">        System.out.printf(Locale.US, &quot;Headers size: %d, count: %d, average size: %f%n&quot;, size, count, (double)size/count);</span>

<span class="nc" id="L1233">        totalSize += size; size = 0; count = 0;</span>
<span class="nc" id="L1234">        rs = s.executeQuery(getSelectUndoableblocksDumpSQL());</span>
<span class="nc bnc" id="L1235" title="All 2 branches missed.">        while (rs.next()) {</span>
<span class="nc" id="L1236">            size += 28; // hash</span>
<span class="nc" id="L1237">            size += 4; // height</span>
<span class="nc" id="L1238">            byte[] txOutChanges = rs.getBytes(1);</span>
<span class="nc" id="L1239">            byte[] transactions = rs.getBytes(2);</span>
<span class="nc bnc" id="L1240" title="All 2 branches missed.">            if (txOutChanges == null)</span>
<span class="nc" id="L1241">                size += transactions.length;</span>
            else
<span class="nc" id="L1243">                size += txOutChanges.length;</span>
            // size += the space to represent NULL
<span class="nc" id="L1245">            count++;</span>
<span class="nc" id="L1246">        }</span>
<span class="nc" id="L1247">        rs.close();</span>
<span class="nc" id="L1248">        System.out.printf(Locale.US, &quot;Undoable Blocks size: %d, count: %d, average size: %f%n&quot;, size, count, (double)size/count);</span>

<span class="nc" id="L1250">        totalSize += size; size = 0; count = 0;</span>
<span class="nc" id="L1251">        long scriptSize = 0;</span>
<span class="nc" id="L1252">        rs = s.executeQuery(getSelectopenoutputsDumpSQL());</span>
<span class="nc bnc" id="L1253" title="All 2 branches missed.">        while (rs.next()) {</span>
<span class="nc" id="L1254">            size += 32; // hash</span>
<span class="nc" id="L1255">            size += 4; // index</span>
<span class="nc" id="L1256">            size += 4; // height</span>
<span class="nc" id="L1257">            size += rs.getBytes(1).length;</span>
<span class="nc" id="L1258">            size += rs.getBytes(2).length;</span>
<span class="nc" id="L1259">            scriptSize += rs.getBytes(2).length;</span>
<span class="nc" id="L1260">            count++;</span>
        }
<span class="nc" id="L1262">        rs.close();</span>
<span class="nc" id="L1263">        System.out.printf(Locale.US, &quot;Open Outputs size: %d, count: %d, average size: %f, average script size: %f (%d in id indexes)%n&quot;,</span>
<span class="nc" id="L1264">                size, count, (double)size/count, (double)scriptSize/count, count * 8);</span>

<span class="nc" id="L1266">        totalSize += size;</span>
<span class="nc" id="L1267">        System.out.println(&quot;Total Size: &quot; + totalSize);</span>

<span class="nc" id="L1269">        s.close();</span>
<span class="nc" id="L1270">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>