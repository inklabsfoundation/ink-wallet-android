<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BtcFormat.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bitcoinj</a> &gt; <a href="index.source.html" class="el_package">org.bitcoinj.utils</a> &gt; <span class="el_source">BtcFormat.java</span></div><h1>BtcFormat.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2014 Adam Mackler
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bitcoinj.utils;

import org.bitcoinj.utils.BtcAutoFormat.Style;
import static org.bitcoinj.utils.BtcAutoFormat.Style.*;

import org.bitcoinj.core.Coin;
import com.google.common.base.Objects;
import com.google.common.collect.ImmutableList;
import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkState;
import com.google.common.base.Strings;

import java.math.BigDecimal;
import java.math.BigInteger;

import static java.math.RoundingMode.HALF_UP;

import java.text.AttributedCharacterIterator;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.FieldPosition;
import java.text.Format;
import java.text.NumberFormat;
import java.text.ParseException;
import java.text.ParsePosition;

import java.util.Locale;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * &lt;p&gt;Instances of this class format and parse locale-specific numerical
 * representations of Bitcoin monetary values.
 *
 * &lt;p&gt;A primary goal of this class is to minimize the danger of
 * human-misreading of monetary values due to mis-counting the number
 * of zeros (or, more generally, of decimal places) in the number that
 * represents a Bitcoin monetary value.  Some of the features offered for doing this
 * are: &lt;ol&gt;
 *   &lt;li&gt;automatic adjustment of denominational units in which a
 *       value is represented so as to lessen the number of adjacent zeros,
 *   &lt;li&gt;use of locale-specific decimal-separators to group digits in
 *       the integer portion of formatted numbers,
 *   &lt;li&gt;fine control over the number and  grouping of fractional decimal places, and
 *   &lt;li&gt;access to character information that allows for vertical
 *       alignment of tabular columns of formatted values.&lt;/ol&gt;
 *
 * &lt;h3&gt;Basic Usage&lt;/h3&gt;
 *
 * Basic usage is very simple: &lt;ol&gt;
 *   &lt;li&gt;Construct a new formatter object using one of the factory methods. 
 *   &lt;li&gt;Format a value by passing it as an argument to the
 *       {@link BtcFormat#format(Object)} method. 
 *   &lt;li&gt;Parse a value by passing a &lt;code&gt;String&lt;/code&gt;-type
 *       representation of it to the {@link BtcFormat#parse(String)} method.&lt;/ol&gt;
 *
 * &lt;p&gt;For example, depending on your locale, values might be formatted
 * and parsed as follows:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 * BtcFormat f = BtcFormat.getInstance();
 * String c = f.format(Coin.COIN);                &lt;strong&gt;// &quot;BTC 1.00&quot;&lt;/strong&gt;
 * String k = f.format(Coin.COIN.multiply(1000)); &lt;strong&gt;// &quot;BTC 1,000.00&quot;&lt;/strong&gt;
 * String m = f.format(Coin.COIN.divide(1000));   &lt;strong&gt;// &quot;mBTC 1.00&quot;&lt;/strong&gt;
 * Coin all = f.parseObject(&quot;M฿ 21&quot;);             &lt;strong&gt;// All the money in the world&lt;/strong&gt;
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;h3&gt;Auto-Denomination versus Fixed-Denomination&lt;/h3&gt;
 *
 * There are two provided concrete classes, one that automatically denominates values to
 * be formatted, {@link BtcAutoFormat}, and another that formats any value in units of a
 * fixed, specified denomination, {@link BtcFixedFormat}.  
 *
 * &lt;h5&gt;Automatic Denomination&lt;/h5&gt;
 *
 * Automatic denomination means that the formatter adjusts the denominational units in which a
 * formatted number is expressed based on the monetary value that number represents.  An
 * auto-denominating formatter is defined by its style, specified by one of the enumerated
 * values of {@link BtcAutoFormat.Style}.  There are two styles constants: {@link
 * BtcAutoFormat.Style#CODE} (the default), and {@link BtcAutoFormat.Style#SYMBOL}.  The
 * difference is that the &lt;code&gt;CODE&lt;/code&gt; style uses an internationally-distinct currency
 * code, such as &lt;code&gt;&quot;BTC&quot;&lt;/code&gt;, to indicate the units of denomination, while the
 * &lt;code&gt;SYMBOL&lt;/code&gt; style uses a possibly-ambiguous currency symbol such as
 * &lt;code&gt;&quot;฿&quot;&lt;/code&gt;.
 *
 * &lt;p&gt;The denomination used when formatting will be either bitcoin, millicoin
 * or microcoin, depending on the value being represented, chosen so as to minimize the number
 * of consecutive zeros displayed without losing precision.  For example, depending on the
 * locale, a value of one bitcoin might be formatted as &lt;pre&gt;฿1.00&lt;/pre&gt; where a value
 * exceeding that by one satoshi would be &lt;pre&gt;µ฿1,000,000.01&lt;/pre&gt;
 *
 * &lt;h5&gt;Fixed Denomination&lt;/h5&gt;
 * 
 * Fixed denomination means that the same denomination of units is used for every value that is
 * formatted or parsed by a given formatter instance.  A fixed-denomination formatter is
 * defined by its scale, which is the number of places one must shift the decimal point in
 * increasing precision to convert the representation of a given quantity of bitcoins into a
 * representation of the same value denominated in the formatter's units.  For example, a scale
 * value of &lt;code&gt;3&lt;/code&gt; specifies a denomination of millibitcoins, because to represent
 * &lt;code&gt;1.0000 BTC&lt;/code&gt;, or one bitcoin, in millibitcoins, one shifts the decimal point
 * three places, that is, to &lt;code&gt;1000.0 mBTC&lt;/code&gt;.
 *
 * &lt;h3&gt;Construction&lt;/h3&gt;
 *
 * There are two ways to obtain an instance of this class: &lt;ol&gt;
 *   &lt;li&gt;Use one of the factory methods; or
 *   &lt;li&gt;Use a {@link BtcFormat.Builder} object.&lt;/ol&gt;
 *
 * &lt;p&gt;The factory methods are appropriate for basic use where the default
 * configuration is either used or modified.  The &lt;code&gt;Builder&lt;/code&gt;
 * class provides more control over the configuration, and gives
 * access to some features not available through the factory methods,
 * such as using custom formatting patterns and currency symbols.
 *
 * &lt;h5&gt;Factory Methods&lt;/h5&gt;
 *
 * Although formatting and parsing is performed by one of the concrete
 * subclasses, you can obtain formatters using the various static factory
 * methods of this abstract base class &lt;code&gt;BtcFormat&lt;/code&gt;.  There
 * are a variety of overloaded methods that allow you to obtain a
 * formatter that behaves according to your needs.
 *
 * &lt;p&gt;The primary distinction is between automatic- and
 * fixed-denomination formatters.  By default, the
 * &lt;code&gt;getInstance()&lt;/code&gt; method with no arguments returns a new,
 * automatic-denominating &lt;code&gt;BtcAutoFormat&lt;/code&gt; instance for your
 * default locale that will display exactly two fractional decimal
 * places and a currency code.  For example, if you happen to be in
 * the USA:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 * BtcFormat f = BtcFormat.getInstance();
 * String s = f.format(Coin.COIN); &lt;strong&gt;// &quot;BTC 1.00&quot;&lt;/strong&gt;
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;The first argument to &lt;code&gt;getInstance()&lt;/code&gt; can determine
 * whether you get an auto- or fixed-denominating formatter.  If the
 * type of the first argument is an &lt;code&gt;int&lt;/code&gt;, then the value
 * of that &lt;code&gt;int&lt;/code&gt; will be interpreted as the decimal-place scale of
 * the {@link BtcFixedFormat} instance that is returned, and thus will
 * determine its denomination.  For example, if you want to format
 * values in units of microbitcoins:
 *
 * &lt;blockquote&gt;&lt;pre&gt;BtcFormat m = BtcFormat.getInstance(6);
 *String s = m.format(Coin.COIN); &lt;strong&gt;// &quot;1,000,000.00&quot;&lt;/strong&gt;
 * &lt;/blockquote&gt;
 *
 * &lt;p&gt;This class provides several constants bound to common scale values:
 *
 * &lt;blockquote&gt;&lt;pre&gt;BtcFormat milliFormat = BtcFormat.getInstance(MILLICOIN_SCALE);&lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;Alternatively, if the type of the first argument to
 * &lt;code&gt;getInstance()&lt;/code&gt; is one of the enumerated values of the
 * {@link BtcAutoFormat.Style} type, either &lt;code&gt;CODE&lt;/code&gt; or
 * &lt;code&gt;SYMBOL&lt;/code&gt;, then you will get a {@link BtcAutoFormat}
 * instance that uses either a currency code or symbol, respectively,
 * to indicate the results of its auto-denomination.
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 * BtcFormat s = BtcFormat.getInstance(SYMBOL);
 * Coin value = Coin.parseCoin(&quot;0.1234&quot;);
 * String mil = s.format(value);              &lt;strong&gt;// &quot;₥฿123.40&quot;&lt;/strong&gt;
 * String mic = s.format(value.divide(1000)); &lt;strong&gt;// &quot;µ฿123.40&quot;&lt;/strong&gt;
 * &lt;/blockquote&gt;
 *
 * &lt;p&gt;An alternative way to specify whether you want an auto- or fixed-denomination formatter
 * is to use one of the factory methods that is named to indicate that characteristics of the
 * new instance returned.  For fixed-denomination formatters, these methods are {@link
 * #getCoinInstance()}, {@link #getMilliInstance()}, and {@link #getMicroInstance()}.  These
 * three methods are equivalent to invoking &lt;code&gt;getInstance()&lt;/code&gt; with a first argument of
 * &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt; and &lt;code&gt;6&lt;/code&gt;, respectively.  For auto-denominating
 * formatters the relevant factory methods are {@link #getCodeInstance()} and {@link
 * #getSymbolInstance()}, which are equivalent to &lt;code&gt;getInstance(Style.CODE)&lt;/code&gt;, and
 * &lt;code&gt;getInstance(Style.SYMBOL)&lt;/code&gt;.
 *
 * &lt;p&gt;Regardless of how you specify whether your new formatter is to be of automatic- or
 * fixed-denomination, the next (and possibly first) parameter to each of the factory methods
 * is an optional &lt;code&gt;Locale&lt;/code&gt; value.
 *
 * For example, here we construct four instances for the same locale that each format
 * differently the same one-bitcoin value:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 * &lt;strong&gt;// Next line returns &quot;1,00 BTC&quot;&lt;/strong&gt;
 * BtcFormat.getInstance(Locale.GERMANY).format(Coin.COIN);
 * &lt;strong&gt;// Next line returns &quot;1,00 ฿&quot;&lt;/strong&gt;
 * BtcFormat.getInstance(SYMBOL, Locale.GERMANY).format(Coin.COIN);
 * &lt;strong&gt;// Next line returns &quot;1.000,00&quot;&lt;/strong&gt;
 * BtcFormat.getMilliInstance(Locale.GERMANY).format(Coin.COIN);
 * &lt;strong&gt;// Next line returns &quot;10.000,00&quot;&lt;/strong&gt;
 * BtcFormat.getInstance(4, Locale.GERMANY).format(Coin.COIN);
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * Omitting such a &lt;code&gt;Locale&lt;/code&gt; parameter will give you a
 * formatter for your default locale.
 *
 * &lt;p&gt;The final (and possibly only) arguments to the factory methods serve to set the default
 * number of fractional decimal places that will be displayed when formatting monetary values.
 * In the case of an auto-denominating formatter, this can be a single &lt;code&gt;int&lt;/code&gt; value,
 * which will determine the number of fractional decimal places to be used in all cases, except
 * where either (1) doing so would provide a place for fractional satoshis, or (2) that default
 * value is overridden when invoking the &lt;code&gt;format()&lt;/code&gt; method as described below.
 *
 * &lt;p&gt;In the case of a fixed-denomination formatter, you can pass any number of
 * &lt;code&gt;int&lt;/code&gt; values.  The first will determine the minimum number of fractional decimal
 * places, and each following &lt;code&gt;int&lt;/code&gt; value specifies the size of an optional group of
 * decimal-places to be displayed only if useful for expressing precision.  As with auto-denominating
 * formatters, numbers will never be formatted with a decimal place that represents a
 * fractional quantity of satoshis, and these defaults can be overridden by arguments to the
 * &lt;code&gt;format()&lt;/code&gt; method.  See below for examples.
 *
 * &lt;h5&gt;The &lt;code&gt;Builder&lt;/code&gt; Class&lt;/h5&gt;
 *
 * A new {@link BtcFormat.Builder} instance is returned by the {@link #builder()} method.  Such
 * an object has methods that set the configuration parameters of a &lt;code&gt;BtcFormat&lt;/code&gt;
 * object.  Its {@link Builder#build()} method constructs and returns a &lt;code&gt;BtcFormat&lt;/code&gt; instance
 * configured according to those settings.
 *
 * &lt;p&gt;In addition to setter-methods that correspond to the factory-method parameters explained
 * above, a &lt;code&gt;Builder&lt;/code&gt; also allows you to specify custom formatting and parsing
 * patterns and currency symbols and codes.  For example, rather than using the default
 * currency symbol, which has the same unicode character point as the national currency symbol of
 * Thailand, some people prefer to use a capital letter &quot;B&quot; with a vertical overstrike.
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 * BtcFormat.Builder builder = BtcFormat.builder();
 * builder.style(SYMBOL);
 * builder.symbol(&quot;B&amp;#x5c;u20e6&quot;); &lt;strong&gt;// unicode char &quot;double vertical stroke overlay&quot;&lt;/strong&gt;
 * BtcFormat f = builder.build();
 * String out = f.format(COIN); &lt;strong&gt;// &quot;B⃦1.00&quot; depending on locale&lt;/strong&gt;
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * The &lt;code&gt;Builder&lt;/code&gt; methods are chainable.  So, for example, if you are
 * deferential to ISO 4217, you might construct a formatter in a single line this way:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 * BtcFormat f = BtcFormat.builder().style(CODE).code(&quot;XBT&quot;).build();
 * String out = f.format(COIN); &lt;strong&gt;// &quot;XBT 1.00&quot;&lt;/strong&gt;
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;See the documentation of the {@link BtcFormat.Builder} class for details.
 *
 * &lt;h3&gt;Formatting&lt;/h3&gt;
 *
 * &lt;p&gt;You format a Bitcoin monetary value by passing it to the {@link BtcFormat#format(Object)}
 * method.  This argument can be either a {@link org.bitcoinj.core.Coin}-type object or a
 * numerical object such as {@link java.lang.Long} or {@link java.math.BigDecimal}.
 * Integer-based types such as {@link java.math.BigInteger} are interpreted as representing a
 * number of satoshis, while a {@link java.math.BigDecimal} is interpreted as representing a
 * number of bitcoins.  A value having a fractional amount of satoshis is rounded to the
 * nearest whole satoshi at least, and possibly to a greater unit depending on the number of
 * fractional decimal-places displayed.  The &lt;code&gt;format()&lt;/code&gt; method will not accept an
 * argument whose type is &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Float&lt;/code&gt; nor &lt;code&gt;Double&lt;/code&gt;.
 *
 * &lt;p&gt;Subsequent to the monetary value to be formatted, the {@link #format(Object)} method also
 * accepts as arguments optional &lt;code&gt;int&lt;/code&gt; values that specify the number of decimal
 * places to use to represent the fractional portion of the number.  This overrides the
 * default, and enables a single formatter instance to be reused, formatting different values
 * that require different numbers of fractional decimal places.  These parameters have the same
 * meaning as those that set the default values in the factory methods as described above.
 * Namely, a single &lt;code&gt;int&lt;/code&gt; value determines the minimum number of fractional decimal
 * places that will be used in all cases, to a precision limit of satoshis.  Instances of
 * {@link BtcFixedFormat} also accept a variable-length sequence of additional &lt;code&gt;int&lt;/code&gt;
 * values, each of which specifies the size of a group of fractional decimal-places to be used
 * in addition to all preceding places, only if useful to express precision, and only to a
 * maximum precision of satoshis.  For example:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 * BtcFormat f = BtcFormat.getCoinInstance();
 * Coin value = COIN.add(Coin.valueOf(5)); &lt;strong&gt;// 100000005 satoshis&lt;/strong&gt;
 * f.format(value, 2);       &lt;strong&gt;// &quot;1.00&quot;&lt;/strong&gt;
 * f.format(value, 3);       &lt;strong&gt;// &quot;1.000&quot;&lt;/strong&gt;
 * f.format(value, 2, 3);    &lt;strong&gt;// &quot;1.00&quot; three more zeros doesn't help &lt;/strong&gt;
 * f.format(value, 2, 3, 3); &lt;strong&gt;// &quot;1.00000005&quot; &lt;/strong&gt;
 * f.format(value, 2, 3, 4); &lt;strong&gt;// &quot;1.00000005&quot; fractions of satoshis have no place&lt;/strong&gt;
 * f.format(value, 2, 3, 2); &lt;strong&gt;// &quot;1.0000001&quot; rounds to nearest usable place&lt;/strong&gt;
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;Note that if using all the fractional decimal places in a specified group would give a
 * place to fractions of satoshis, then the size of that group will be reduced to a maximum
 * precision of satoshis.  Either all or none of the allowed decimal places of that group will
 * still be applied as doing so is useful for expressing the precision of the value being
 * formatted.
 *
 * &lt;p&gt;Several convenient constants of repeating group-size sequences are provided:
 * {@link BtcFixedFormat#REPEATING_PLACES}, {@link
 * BtcFixedFormat#REPEATING_DOUBLETS} and {@link
 * BtcFixedFormat#REPEATING_TRIPLETS}.  These signify repeating groups
 * of one, two and three decimals places, respectively.  For example,
 * to display only as many fractional places as useful in order to
 * prevent hanging zeros on the least-significant end of formatted
 * numbers:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 * format(value, 0, REPEATING_PLACES);
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;When using an automatically-denominating formatter, you might
 * want to know what denomination was chosen.  You can get the
 * currency-units indicator, as well as any other field in the
 * formatted output, by using a {@link java.text.FieldPosition} instance
 * constructed using an appropriate constant from the {@link
 * java.text.NumberFormat.Field} class:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 * BtcFormat de = BtcFormat.getInstance(Locale.GERMANY);
 * FieldPosition currField = new FieldPosition(NumberFormat.Field.CURRENCY);
 * &lt;strong&gt;// next line formats the value as &quot;987.654.321,23 µBTC&quot;&lt;/strong&gt;
 * String output = de.format(valueOf(98765432123L), new StringBuffer(), currField);
 * &lt;strong&gt;// next line sets variable currencyCode to &quot;µBTC&quot;&lt;/strong&gt;
 * String currencyCode = output.substring(currField.getBeginIndex(), currField.getEndIndex()));
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;When using a fixed-denomination formatter whose scale can be expressed as a standard
 * &quot;metric&quot; prefix, you can invoke the &lt;code&gt;code()&lt;/code&gt; and &lt;code&gt;symbol()&lt;/code&gt; methods to
 * obtain a &lt;code&gt;String&lt;/code&gt; whose value is the appropriate currency code or symbol,
 * respectively, for that formatter.
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 * BtcFixedFormat kilo = (BtcFixedFormat)BtcFormat(-3); &lt;strong&gt;// scale -3 for kilocoins&lt;/strong&gt;
 * Coin value = Coin.parseCoin(&quot;1230&quot;);
 * &lt;strong&gt;// variable coded will be set to &quot;kBTC 1.23&quot;&lt;/strong&gt;
 * String coded = kilo.code() + &quot; &quot; + kilo.format(value);
 * &lt;strong&gt;// variable symbolic will be set to &quot;k฿1.23&quot;&lt;/strong&gt;
 * String symbolic = kilo.symbol() + kilo.format(value);
 * BtcFormat(4).code(); &lt;strong&gt;// unnamed denomination has no code; raises exception&lt;/strong&gt;
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;h5&gt;Formatting for Tabular Columns&lt;/h5&gt;
 *
 * When displaying tables of monetary values, you can lessen the
 * risk of human misreading-error by vertically aligning the decimal
 * separator of those values.  This example demonstrates one way to do that:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 * &lt;strong&gt;// The elements of this array are the values we will format:&lt;/strong&gt;
 * Coin[] rows = {MAX_MONEY, MAX_MONEY.subtract(SATOSHI), Coin.parseCoin(&quot;1234&quot;),
 *                COIN, COIN.divide(1000),
 *                valueOf(10000), valueOf(1000), valueOf(100),
 *                SATOSHI};
 * BtcFormat f = BtcFormat.getCoinInstance(2, REPEATING_PLACES);
 * FieldPosition fp = new FieldPosition(DECIMAL_SEPARATOR); &lt;strong&gt;// see java.text.NumberFormat.Field&lt;/strong&gt;
 * String[] output = new String[rows.length];
 * int[] indexes = new int[rows.length];
 * int maxIndex = 0;
 * for (int i = 0; i &lt; rows.length; i++) {
 *     output[i] = f.format(rows[i], new StringBuffer(), fp).toString();
 *     indexes[i] = fp.getBeginIndex();
 *     if (indexes[i] &gt; maxIndex) maxIndex = indexes[i];
 * }
 * for (int i = 0; i &lt; output.length; i++) {
 *     System.out.println(repeat(&quot; &quot;, (maxIndex - indexes[i])) + output[i]);
 * }
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * Assuming you are using a monospaced font, and depending on your
 * locale, the foregoing will print the following:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 * 21,000,000.00
 * 20,999,999.99999999
 *      1,234.00
 *          1.00
 *          0.001
 *          0.0001
 *          0.00001
 *          0.000001
 *          0.00000001
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * If you need to vertically-align columns printed in a proportional font,
 * then see the documentation for the {@link java.text.NumberFormat} class
 * for an explanation of how to do that.
 *
 * &lt;h3&gt;Parsing&lt;/h3&gt;
 *
 * &lt;p&gt;The {@link #parse(String)} method accepts a &lt;code&gt;String&lt;/code&gt; argument, and returns a
 * {@link Coin}-type value.  The difference in parsing behavior between instances of {@link
 * BtcFixedFormat} and {@link BtcAutoFormat} is analogous to the difference in formatting
 * behavior between instances of those classes.  Instances of {@link BtcAutoFormat} recognize
 * currency codes and symbols in the &lt;code&gt;String&lt;/code&gt; being parsed, and interpret them as
 * indicators of the units in which the number being parsed is denominated.  On the other hand,
 * instances of {@link BtcFixedFormat} by default recognize no codes nor symbols, but rather
 * interpret every number as being denominated in the units that were specified when
 * constructing the instance doing the parsing.  This default behavior of {@link
 * BtcFixedFormat} can be overridden by setting a parsing pattern that includes a currency sign
 * using the {@link BtcFormat.Builder#pattern()} method.
 *
 * &lt;p&gt;The {@link BtcAutoFormat#parse(String)}&lt;/code&gt; method of {@link BtcAutoFormat} (and of
 * {@link BtcAutoFormat} configured with applicable non-default pattern) will recognize a
 * variety of currency symbols and codes, including all standard international (metric)
 * prefixes from micro to mega.  For example, denominational units of microcoins may be
 * specified by &lt;code&gt;µ฿&lt;/code&gt;, &lt;code&gt;u฿&lt;/code&gt;, &lt;code&gt;µB⃦&lt;/code&gt;, &lt;code&gt;µɃ&lt;/code&gt;,
 * &lt;code&gt;µBTC&lt;/code&gt; or other appropriate permutations of those characters.  Additionally, if
 * either or both of a custom currency code or symbol is configured using {@link
 * BtcFormat.Builder#code} or {@link BtcFormat.Builder#code}, then such code or symbol will
 * be recognized in addition to those recognized by default..
 *
 * &lt;p&gt;Instances of this class that recognize currency signs will recognize both currency
 * symbols and codes, regardless of which that instance uses for formatting.  However, if the
 * style is &lt;code&gt;CODE&lt;/code&gt; (and unless overridden by a custom pattern) then a space character must
 * separate the units indicator from the number.  When parsing with a &lt;code&gt;SYMBOL&lt;/code&gt;-style
 * &lt;code&gt;BtcFormat&lt;/code&gt; instance, on the other hand, whether or not the units indicator must
 * be separated by a space from the number is determined by the locale.  The {@link
 * BtcFormat#pattern()} method returns a representation of the pattern that
 * can be examined to determine whether a space must separate currency signs from numbers in
 * parsed &lt;code&gt;String&lt;/code&gt;s.
 *
 * &lt;p&gt;When parsing, if the currency-units indicator is absent, then a {@link BtcAutoFormat}
 * instance will infer a denomination of bitcoins while a {@link BtcFixedFormat} will infer the
 * denomination in which it expresses formatted values.  Note: by default (unless overridden by
 * a custom pattern), if the locale or style requires a space to separate the number from the
 * units indicator, that space must be present in the String to be parsed, even if the units
 * indicator is absent.
 *
 * &lt;p&gt;The &lt;code&gt;parse()&lt;/code&gt; method returns an instance of the
 * {@link Coin} class.  Therefore, attempting to parse a value greater
 * than the maximum that a &lt;code&gt;Coin&lt;/code&gt; object can represent will
 * raise a &lt;code&gt;ParseException&lt;/code&gt;, as will any other detected
 * parsing error.
 *
 *  &lt;h3&gt;Limitations&lt;/h3&gt;
 *
 *  &lt;h5&gt;Parsing&lt;/h5&gt;
 *
 * Parsing is performed by an underlying {@link java.text.NumberFormat} object.  While this
 * delivers the benefit of recognizing locale-specific patterns, some have criticized other
 * aspects of its behavior.  For example, see &lt;a
 * href=&quot;http://www.ibm.com/developerworks/library/j-numberformat/&quot;&gt;this article by Joe Sam
 * Shirah&lt;/a&gt;.  In particular, explicit positive-signs are not recognized.  If you are parsing
 * input from end-users, then you should consider whether you would benefit from any of the
 * work-arounds mentioned in that article.
 *
 * &lt;h5&gt;Exotic Locales&lt;/h5&gt;
 *
 * This class is not well-tested in locales that use non-ascii
 * character sets, especially those where writing proceeds from
 * right-to-left.  Helpful feedback in that regard is appreciated.
 *
 * &lt;h3&gt;Thread-Safety&lt;/h3&gt;
 *
 * &lt;p&gt;Instances of this class are immutable.
 *
 * @see          java.text.Format
 * @see          java.text.NumberFormat
 * @see          java.text.DecimalFormat
 * @see          java.text.DecimalFormatSymbols
 * @see          java.text.FieldPosition
 * @see          org.bitcoinj.core.Coin
 */

public abstract class BtcFormat extends Format {

    /* CONCURRENCY NOTES
     *
     * There is one mutable member of this class, the `DecimalFormat` object bound to variable
     * `numberFormat`.  The relevant methods invoked on it are: setMinimumFractionDigits(),
     * setMaximumFractionDigits(), and setDecimalFormatSymbols(), along with the respective
     * getter methods corresponding to each.  The first two methods are used to set the number
     * of fractional decimal places displayed when formatting, which is reflected in the
     * patterns returned by the public pattern() and localizedPattern() methods.  The last
     * method sets the value of that object's member `DecimalFormatSymbols` object for
     * formatting and parsing, which is also reflected in the aforementioned patterns.  The
     * patterns, which are the passed-through return values of the DecimalFormat object's
     * toPattern() and toLocalizedPattern() methods, and the value of the DecimalFormat
     * object's DecimalFormatSymbols member are among the values compared between instances of
     * this class in determining the return values of the `equals()` and `hashCode()` methods.
     *
     * From the foregoing, you can understand that immutability is achieved as follows: access
     * to the variable `numberFormat` referent's fraction-digits and format-symbols fields are
     * synchronized on that DecimalFormat object.  The state of those fraction-digits limits
     * and decimal-format symbols must be returned to a static state after being changed for
     * formatting or parsing since the user can see them reflected in the return values of
     * above-mentioned methods and because `equals()` and `hashCode()` use them for
     * comparisons.
     */

    /** The conventional international currency code for bitcoins: &quot;BTC&quot; */
    private static final String COIN_CODE = &quot;BTC&quot;;
    /** The default currency symbols for bitcoins */
    private static final String COIN_SYMBOL = &quot;฿&quot;;
    /** An alternative currency symbol to use in locales where the default symbol is used for the national currency. */
    protected static final String COIN_SYMBOL_ALT = &quot;Ƀ&quot;;

    protected final DecimalFormat numberFormat; // warning: mutable
    protected final int minimumFractionDigits;
    protected final List&lt;Integer&gt; decimalGroups;

    /* Scale is the number of decimal-places difference from same value in bitcoins */
    /** A constant useful for specifying a denomination of bitcoins, the &lt;code&gt;int&lt;/code&gt; value
     *  &lt;code&gt;0&lt;/code&gt;. */
    public static final int COIN_SCALE = 0;

    /** A constant useful for specifying a denomination of millibitcoins, the &lt;code&gt;int&lt;/code&gt;
     *  value &lt;code&gt;3&lt;/code&gt;. */
    public static final int MILLICOIN_SCALE = 3;

    /** A constant useful for specifying a denomination of microbitcoins, the &lt;code&gt;int&lt;/code&gt;
     *  value &lt;code&gt;6&lt;/code&gt;. */
    public static final int MICROCOIN_SCALE = 6;

    /** Return the number of decimal places by which any value denominated in the
     *  units indicated by the given scale differs from that same value denominated in satoshis */
<span class="fc" id="L522">    private static int offSatoshis(int scale) { return Coin.SMALLEST_UNIT_EXPONENT - scale; }</span>

<span class="fc" id="L524">    private static Locale defaultLocale() { return Locale.getDefault(); }</span>

    /**
     * &lt;p&gt;This class constructs new instances of {@link BtcFormat}, allowing for the
     * configuration of those instances before they are constructed.  After obtaining a
     * &lt;code&gt;Builder&lt;/code&gt; object from the {@link BtcFormat#builder()} method, invoke the
     * necessary setter methods to obtain your desired configuration.  Finaly, the {@link
     * #build()} method returns a new &lt;code&gt;BtcFormat&lt;/code&gt; object that has the specified
     * configuration.
     *
     * &lt;p&gt;All the setter methods override defaults.  Invoking &lt;code&gt;build()&lt;/code&gt; without invoking any
     * of the setting methods is equivalent to invoking {@link BtcFormat#getInstance()} with no arguments.
     *
     * &lt;p&gt;Each setter methods returns the same instance on which it is invoked,
     *  thus these methods can be chained.
     *
     * &lt;p&gt;Instances of this class are &lt;strong&gt;not&lt;/strong&gt; thread-safe.
     */
    public static class Builder {

<span class="pc" id="L544">        private enum Variant {</span>
<span class="fc" id="L545">            AUTO { @Override BtcFormat newInstance(Builder b) {</span>
<span class="fc" id="L546">                       return getInstance(b.style, b.locale, b.minimumFractionDigits);</span>
                   }},
<span class="fc" id="L548">            FIXED,</span>
<span class="fc" id="L549">            UNSET;</span>
            BtcFormat newInstance(Builder b) {
<span class="fc" id="L551">                return getInstance(b.scale, b.locale, b.minimumFractionDigits, b.fractionGroups);</span>
            }
        }
        // Parameters are initialized to default or unset values
<span class="fc" id="L555">        private Variant variant = Variant.UNSET;</span>
<span class="fc" id="L556">        private Locale locale = defaultLocale();</span>
<span class="fc" id="L557">        private int minimumFractionDigits = 2;</span>
<span class="fc" id="L558">        private int[] fractionGroups = {};</span>
<span class="fc" id="L559">        private Style style = BtcAutoFormat.Style.CODE;</span>
<span class="fc" id="L560">        private int scale = 0;</span>
<span class="fc" id="L561">        private String symbol = &quot;&quot;,code = &quot;&quot;,pattern = &quot;&quot;,localizedPattern = &quot;&quot;;</span>

<span class="fc" id="L563">        private Builder() {}</span>

        /** Specify the new &lt;code&gt;BtcFormat&lt;/code&gt; is to be automatically-denominating.
         * The argument determines which of either codes or symbols the new &lt;code&gt;BtcFormat&lt;/code&gt;
         * will use by default to indicate the denominations it chooses when formatting values.
         *
         * &lt;p&gt;Note that the &lt;code&gt;Style&lt;/code&gt; argument specifies the
         * &lt;em&gt;default&lt;/em&gt; style, which is overridden by invoking
         * either {@link #pattern(String)} or {@link #localizedPattern(String)}.
         *
         * @throws IllegalArgumentException if {@link #scale(int)} has
         *         previously been invoked on this instance.*/
        public Builder style(BtcAutoFormat.Style val) {
<span class="fc bfc" id="L576" title="All 2 branches covered.">            if (variant == Variant.FIXED)</span>
<span class="fc" id="L577">                throw new IllegalStateException(&quot;You cannot invoke both style() and scale()&quot;);</span>
<span class="fc" id="L578">            variant = Variant.AUTO;</span>
<span class="fc" id="L579">            style = val;</span>
<span class="fc" id="L580">            return this;</span>
        }

        /** Specify the number of decimal places in the fraction part of formatted numbers.
         * This is equivalent to the {@link #minimumFractionDigits(int)} method, but named
         * appropriately for the context of generating {@link BtcAutoFormat} instances.
         *
         *  &lt;p&gt;If neither this method nor &lt;code&gt;minimumFactionDigits()&lt;/code&gt; is invoked, the default value
         *  will be &lt;code&gt;2&lt;/code&gt;. */
<span class="fc" id="L589">        public Builder fractionDigits(int val) { return minimumFractionDigits(val); }</span>

        /** Specify a fixed-denomination of units to use when formatting and parsing values.
         *  The argument specifies the number of decimal places, in increasing
         *  precision, by which each formatted value will differ from that same value
         *  denominated in bitcoins.  For example, a denomination of millibitcoins is specified
         *  with a value of &lt;code&gt;3&lt;/code&gt;.
         *
         * &lt;p&gt;The &lt;code&gt;BtcFormat&lt;/code&gt; class provides appropriately named
         * &lt;code&gt;int&lt;/code&gt;-type constants for the three common values, {@link BtcFormat#COIN_SCALE},
         * {@link BtcFormat#MILLICOIN_SCALE} {@link BtcFormat#MICROCOIN_SCALE}.
         *
         * &lt;p&gt;If neither this method nor {@link #style(BtcAutoFormat.Style)} is invoked on a
         * &lt;code&gt;Builder&lt;/code&gt;, then the &lt;code&gt;BtcFormat&lt;/code&gt; will default to a
         * fixed-denomination of bitcoins, equivalent to invoking this method with an argument
         * of &lt;code&gt;0&lt;/code&gt;. */
        public Builder scale(int val) {
<span class="fc bfc" id="L606" title="All 2 branches covered.">            if (variant == Variant.AUTO)</span>
<span class="fc" id="L607">                throw new IllegalStateException(&quot;You cannot invoke both scale() and style()&quot;);</span>
<span class="fc" id="L608">            variant = Variant.FIXED;</span>
<span class="fc" id="L609">            scale = val;</span>
<span class="fc" id="L610">            return this;</span>
        }

        /** Specify the minimum number of decimal places in the fraction part of formatted values.
         *  This method is equivalent to {@link #fractionDigits(int)}, but named appropriately for
         *  the context of generating a fixed-denomination formatter.
         *
         *  &lt;p&gt;If neither this method nor &lt;code&gt;fractionDigits()&lt;/code&gt; is invoked, the default value
         *  will be &lt;code&gt;2&lt;/code&gt;.  */
<span class="fc" id="L619">        public Builder minimumFractionDigits(int val) { minimumFractionDigits = val;  return this; }</span>

        /** Specify the sizes of a variable number of optional decimal-place groups in the
         *  fraction part of formatted values.  A group of each specified size will be used in
         *  addition to all previously applied decimal places only if doing so is useful for
         *  expressing precision.  The size of each group is limited to a maximum precision of
         *  satoshis.
         *
         *  &lt;p&gt;If this method is not invoked, then the number of fractional decimal places will
         *  be limited to the value passed to {@link #minimumFractionDigits}, or &lt;code&gt;2&lt;/code&gt;
         *  if that method is not invoked. */
<span class="fc" id="L630">        public Builder fractionGroups(int... val) { fractionGroups = val; return this; }</span>

        /** Specify the {@link java.util.Locale} for formatting and parsing.
         *  If this method is not invoked, then the runtime default locale will be used. */
<span class="fc" id="L634">        public Builder locale(Locale val) { locale = val; return this; }</span>

        /** Specify a currency symbol to be used in the denomination-unit indicators
         *  of formatted values.  This method only sets the symbol, but does not cause
         *  it to be used.  You must also invoke either &lt;code&gt;style(SYMBOL)&lt;/code&gt;, or else apply
         *  a custom pattern that includes a single currency-sign character by invoking either
         *  {@link #pattern(String)} or {@link #localizedPattern(String)}.
         *
         *  &lt;p&gt;Specify only the base symbol.  The appropriate prefix will be applied according
         *  to the denomination of formatted and parsed values. */
<span class="fc" id="L644">        public Builder symbol(String val) { symbol = val; return this; }</span>

        /** Specify a custom currency code to be used in the denomination-unit indicators
         *  of formatted values.  This method only sets the code, but does not cause
         *  it to be used.  You must also invoke either &lt;code&gt;style(CODE)&lt;/code&gt;, or else apply
         *  a custom pattern that includes a double currency-sign character by invoking either
         *  {@link #pattern(String)} or {@link #localizedPattern(String)}.
         *
         *  &lt;p&gt;Specify only the base code.  The appropriate prefix will be applied according
         *  to the denomination of formatted and parsed values. */
<span class="fc" id="L654">        public Builder code(String val) { code = val; return this; }</span>

        /** Use the given pattern when formatting and parsing.  The format of this pattern is
         *  identical to that used by the {@link java.text.DecimalFormat} class.
         *
         *  &lt;p&gt;If the pattern lacks a negative subpattern, then the formatter will indicate
         *  negative values by placing a minus sign immediately preceding the number part of
         *  formatted values.
         *
         *  &lt;p&gt;Note that while the pattern format specified by the {@link
         *  java.text.DecimalFormat} class includes a mechanism for setting the number of
         *  fractional decimal places, that part of the pattern is ignored.  Instead, use the
         *  {@link #fractionDigits(int)}, {@link #minimumFractionDigits(int)} and {@link
         *  #fractionGroups(int...)} methods.
         *
         *  &lt;p&gt;Warning: if you set a pattern that includes a currency-sign for a
         *  fixed-denomination formatter that uses a non-standard scale, then an exception will
         *  be raised when you try to format a value.  The standard scales include all for
         *  which a metric prefix exists from micro to mega.
         *
         *  &lt;p&gt;Note that by applying a pattern you override the configured formatting style of
         *  {@link BtcAutoFormat} instances.  */
        public Builder pattern(String val) {
<span class="pc bpc" id="L677" title="1 of 2 branches missed.">            if (localizedPattern != &quot;&quot;)</span>
<span class="nc" id="L678">                throw new IllegalStateException(&quot;You cannot invoke both pattern() and localizedPattern()&quot;);</span>
<span class="fc" id="L679">            pattern = val;</span>
<span class="fc" id="L680">            return this;</span>
        } 

        /** Use the given localized-pattern for formatting and parsing.  The format of this
         *  pattern is identical to the patterns used by the {@link java.text.DecimalFormat}
         *  class.
         *
         *  &lt;p&gt;The pattern is localized according to the locale of the &lt;code&gt;BtcFormat&lt;/code&gt;
         *  instance, the symbols for which can be examined by inspecting the {@link
         *  java.text.DecimalFormatSymbols} object returned by {@link BtcFormat#symbols()}.
         *  So, for example, if you are in Germany, then the non-localized pattern of
         *  &lt;pre&gt;&quot;#,##0.###&quot;&lt;/pre&gt; would be localized as &lt;pre&gt;&quot;#.##0,###&quot;&lt;/pre&gt;
         *
         *  &lt;p&gt;If the pattern lacks a negative subpattern, then the formatter will indicate
         *  negative values by placing a minus sign immediately preceding the number part of
         *  formatted values.
         *
         *  &lt;p&gt;Note that while the pattern format specified by the {@link
         *  java.text.DecimalFormat} class includes a mechanism for setting the number of
         *  fractional decimal places, that part of the pattern is ignored.  Instead, use the
         *  {@link #fractionDigits(int)}, {@link #minimumFractionDigits(int)} and {@link
         *  #fractionGroups(int...)} methods.
         *
         *  &lt;p&gt;Warning: if you set a pattern that includes a currency-sign for a
         *  fixed-denomination formatter that uses a non-standard scale, then an exception will
         *  be raised when you try to format a value.  The standard scales include all for
         *  which a metric prefix exists from micro to mega.
         *
         *  &lt;p&gt;Note that by applying a pattern you override the configured formatting style of
         *  {@link BtcAutoFormat} instances.         */
        public Builder localizedPattern(String val) {
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">            if (pattern != &quot;&quot;)</span>
<span class="nc" id="L712">                throw new IllegalStateException(&quot;You cannot invoke both pattern() and localizedPattern().&quot;);</span>
<span class="fc" id="L713">            localizedPattern = val;</span>
<span class="fc" id="L714">            return this;</span>
        }

        /** Return a new {@link BtcFormat} instance.  The object returned will be configured according
         *  to the state of this &lt;code&gt;Builder&lt;/code&gt; instance at the time this method is invoked. */
        public BtcFormat build() {
<span class="fc" id="L720">            BtcFormat f = variant.newInstance(this);</span>
<span class="fc bfc" id="L721" title="All 4 branches covered.">            if (symbol != &quot;&quot; || code != &quot;&quot;) { synchronized(f.numberFormat) {</span>
<span class="fc" id="L722">                DecimalFormatSymbols defaultSigns = f.numberFormat.getDecimalFormatSymbols();</span>
<span class="fc bfc" id="L723" title="All 2 branches covered.">                setSymbolAndCode(f.numberFormat,</span>
<span class="fc bfc" id="L724" title="All 2 branches covered.">                    symbol != &quot;&quot; ? symbol : defaultSigns.getCurrencySymbol(),</span>
<span class="fc" id="L725">                    code != &quot;&quot; ? code : defaultSigns.getInternationalCurrencySymbol()</span>
                );
<span class="pc" id="L727">            }}</span>
<span class="fc bfc" id="L728" title="All 4 branches covered.">            if (localizedPattern != &quot;&quot; || pattern != &quot;&quot;) {</span>
<span class="fc" id="L729">                int places = f.numberFormat.getMinimumFractionDigits();</span>
<span class="fc bfc" id="L730" title="All 2 branches covered.">                if (localizedPattern != &quot;&quot;) f.numberFormat.applyLocalizedPattern(negify(localizedPattern));</span>
<span class="fc" id="L731">                else f.numberFormat.applyPattern(negify(pattern));</span>
<span class="fc" id="L732">                f.numberFormat.setMinimumFractionDigits(places);</span>
<span class="fc" id="L733">                f.numberFormat.setMaximumFractionDigits(places);</span>
            }
<span class="fc" id="L735">            return f;</span>
        }

    }

    /** Return a new {@link Builder} object.  See the documentation of that class for usage details. */
<span class="fc" id="L741">    public static Builder builder() { return new Builder(); }</span>

    /** This single constructor is invoked by the overriding subclass constructors. */
<span class="fc" id="L744">    protected BtcFormat(DecimalFormat numberFormat, int minDecimals, List&lt;Integer&gt; groups) {</span>
<span class="pc bpc" id="L745" title="1 of 2 branches missed.">        checkArgument(minDecimals &gt;= 0, &quot;There can be no fewer than zero fractional decimal places&quot;);</span>
<span class="fc" id="L746">        this.numberFormat = numberFormat;</span>
<span class="fc" id="L747">        this.numberFormat.setParseBigDecimal(true);</span>
<span class="fc" id="L748">        this.numberFormat.setRoundingMode(HALF_UP);</span>
<span class="fc" id="L749">        this.minimumFractionDigits = minDecimals;</span>
<span class="fc" id="L750">        this.numberFormat.setMinimumFractionDigits(this.minimumFractionDigits);</span>
<span class="fc" id="L751">        this.numberFormat.setMaximumFractionDigits(this.minimumFractionDigits);</span>
<span class="fc" id="L752">        this.decimalGroups = groups;</span>
<span class="fc" id="L753">        synchronized (this.numberFormat) { setSymbolAndCode(</span>
            this.numberFormat,
<span class="fc bfc" id="L755" title="All 2 branches covered.">            (this.numberFormat.getDecimalFormatSymbols().getCurrencySymbol().contains(COIN_SYMBOL))</span>
                ? COIN_SYMBOL_ALT
                : COIN_SYMBOL,
            COIN_CODE
<span class="pc" id="L759">        );}</span>
<span class="fc" id="L760">    }</span>

    /**
     * Return a new instance of this class using all defaults.  The returned formatter will
     * auto-denominate values so as to minimize zeros without loss of precision and display a
     * currency code, for example &quot;&lt;code&gt;BTC&lt;/code&gt;&quot;, to indicate that denomination.  The
     * returned object will uses the default locale for formatting the number and placement of
     * the currency-code.  Two fractional decimal places will be displayed in all formatted numbers.
     */
<span class="fc" id="L769">    public static BtcFormat getInstance() { return getInstance(defaultLocale()); }</span>

    /**
     * Return a new auto-denominating instance that will indicate units using a currency
     * symbol, for example, &lt;code&gt;&quot;฿&quot;&lt;/code&gt;.  Formatting and parsing will be done
     * according to the default locale.
     */
<span class="fc" id="L776">    public static BtcFormat getSymbolInstance() { return getSymbolInstance(defaultLocale()); }</span>

    /**
     * Return a new auto-denominating instance that will indicate units using a currency
     * code, for example, &lt;code&gt;&quot;BTC&quot;&lt;/code&gt;.  Formatting and parsing will be done
     * according to the default locale.
     */
<span class="fc" id="L783">    public static BtcFormat getCodeInstance() { return getCodeInstance(defaultLocale()); }</span>

    /**
     * Return a new symbol-style auto-formatter with the given number of fractional decimal
     * places.  Denominational units will be indicated using a currency symbol, for example,
     * &lt;code&gt;&quot;฿&quot;&lt;/code&gt;.  The returned object will format the fraction-part of numbers using
     * the given number of decimal places, or fewer as necessary to avoid giving a place to
     * fractional satoshis.  Formatting and parsing will be done according to the default
     * locale.
     */
    public static BtcFormat getSymbolInstance(int fractionPlaces) {
<span class="fc" id="L794">        return getSymbolInstance(defaultLocale(), fractionPlaces);</span>
    }

    /**
     * Return a new code-style auto-formatter with the given number of fractional decimal
     * places.  Denominational units will be indicated using a currency code, for example,
     * &lt;code&gt;&quot;BTC&quot;&lt;/code&gt;.  The returned object will format the fraction-part of numbers using
     * the given number of decimal places, or fewer as necessary to avoid giving a place to
     * fractional satoshis.  Formatting and parsing will be done according to the default
     * locale.
     */
    public static BtcFormat getCodeInstance(int minDecimals) {
<span class="fc" id="L806">	return getCodeInstance(defaultLocale(), minDecimals);</span>
    }

    /**
     * Return a new code-style auto-formatter for the given locale.  The returned object will
     * select denominational units based on each value being formatted, and will indicate those
     * units using a currency code, for example, &lt;code&gt;&quot;mBTC&quot;&lt;/code&gt;.
     */
<span class="fc" id="L814">    public static BtcFormat getInstance(Locale locale) { return getCodeInstance(locale); }</span>

    /**
     * Return a new code-style auto-formatter for the given locale.  The returned object will
     * select denominational units based on each value being formatted, and will indicate those
     * units using a currency code, for example, &lt;code&gt;&quot;mBTC&quot;&lt;/code&gt;.
     */
<span class="fc" id="L821">    public static BtcFormat getCodeInstance(Locale locale) { return getInstance(CODE, locale); }</span>

    /**
     * Return a new code-style auto-formatter for the given locale with the given number of
     * fraction places.  The returned object will select denominational units based on each
     * value being formatted, and will indicate those units using a currency code, for example,
     * &lt;code&gt;&quot;mBTC&quot;&lt;/code&gt;.  The returned object will format the fraction-part of numbers using
     * the given number of decimal places, or fewer as necessary to avoid giving a place to
     * fractional satoshis.
     */
    public static BtcFormat getInstance(Locale locale, int minDecimals) {
<span class="nc" id="L832">	return getCodeInstance(locale, minDecimals);</span>
    }

    /**
     * Return a new code-style auto-formatter for the given locale with the given number of
     * fraction places.  The returned object will select denominational units based on each
     * value being formatted, and will indicate those units using a currency code, for example,
     * &lt;code&gt;&quot;mBTC&quot;&lt;/code&gt;.  The returned object will format the fraction-part of numbers using
     * the given number of decimal places, or fewer as necessary to avoid giving a place to
     * fractional satoshis.
     */
    public static BtcFormat getCodeInstance(Locale locale, int minDecimals) {
<span class="fc" id="L844">	return getInstance(CODE, locale, minDecimals);</span>
    }

    /**
     * Return a new symbol-style auto-formatter for the given locale.  The returned object will
     * select denominational units based on each value being formatted, and will indicate those
     * units using a currency symbol, for example, &lt;code&gt;&quot;µ฿&quot;&lt;/code&gt;.
     */
    public static BtcFormat getSymbolInstance(Locale locale) {
<span class="fc" id="L853">	return getInstance(SYMBOL, locale);</span>
    }

    /**
     * Return a new symbol-style auto-formatter for the given locale with the given number of
     * fraction places.  The returned object will select denominational units based on each
     * value being formatted, and will indicate those units using a currency symbol, for example,
     * &lt;code&gt;&quot;µ฿&quot;&lt;/code&gt;.  The returned object will format the fraction-part of numbers using
     * the given number of decimal places, or fewer as necessary to avoid giving a place to
     * fractional satoshis.
     */
    public static BtcFormat getSymbolInstance(Locale locale, int fractionPlaces) {
<span class="fc" id="L865">	return getInstance(SYMBOL, locale, fractionPlaces);</span>
    }

    /**
     * Return a new auto-denominating formatter.  The returned object will indicate the
     * denominational units of formatted values using either a currency symbol, such as,
     * &lt;code&gt;&quot;฿&quot;&lt;/code&gt;, or code, such as &lt;code&gt;&quot;mBTC&quot;&lt;/code&gt;, depending on the value of
     * the argument.  Formatting and parsing will be done according to the default locale.
     */
<span class="fc" id="L874">    public static BtcFormat getInstance(Style style) { return getInstance(style, defaultLocale()); }</span>

    /**
     * Return a new auto-denominating formatter with the given number of fractional decimal
     * places.  The returned object will indicate the denominational units of formatted values
     * using either a currency symbol, such as, &lt;code&gt;&quot;฿&quot;&lt;/code&gt;, or code, such as
     * &lt;code&gt;&quot;mBTC&quot;&lt;/code&gt;, depending on the value of the first argument.  The returned object
     * will format the fraction-part of numbers using the given number of decimal places, or
     * fewer as necessary to avoid giving a place to fractional satoshis.  Formatting and
     * parsing will be done according to the default locale.
     */
    public static BtcFormat getInstance(Style style, int fractionPlaces) {
<span class="fc" id="L886">	return getInstance(style, defaultLocale(), fractionPlaces);</span>
    }

    /**
     * Return a new auto-formatter with the given style for the given locale.
     * The returned object that will auto-denominate each formatted value, and
     * will indicate that denomination using either a currency code, such as
     * &quot;&lt;code&gt;BTC&lt;/code&gt;&quot;, or symbol, such as &quot;&lt;code&gt;฿&lt;/code&gt;&quot;, depending on the value
     * of the first argument. 
     * &lt;p&gt;The number of fractional decimal places in formatted number will be two, or fewer
     * as necessary to avoid giving a place to fractional satoshis.
     */
    public static BtcFormat getInstance(Style style, Locale locale) {
<span class="fc" id="L899">	return getInstance(style, locale, 2);</span>
    }

    /**
     * Return a new auto-formatter for the given locale with the given number of fraction places.
     * The returned object will automatically-denominate each formatted
     * value, and will indicate that denomination using either a currency code,
     * such as &lt;code&gt;&quot;mBTC&quot;&lt;/code&gt;, or symbol, such as &quot;&lt;code&gt;฿&lt;/code&gt;&quot;,
     * according to the given style argument.  It will format each number
     * according to the given locale.
     *
     * &lt;p&gt;The third parameter is the number of fractional decimal places to use for each
     * formatted number, reduced as neccesary when formatting to avoid giving a place to
     * fractional satoshis.
     */
    public static BtcFormat getInstance(Style style, Locale locale, int fractionPlaces) {
<span class="fc" id="L915">	return new BtcAutoFormat(locale, style, fractionPlaces);</span>
    }

    /**
     * Return a new coin-denominated formatter.  The returned object will format and parse
     * values according to the default locale, and will format numbers with two fractional
     * decimal places, rounding values as necessary.
     */
<span class="fc" id="L923">    public static BtcFormat getCoinInstance() { return getCoinInstance(defaultLocale()); }</span>

    private static List&lt;Integer&gt; boxAsList(int[] elements) throws IllegalArgumentException {
<span class="fc" id="L926">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;(elements.length);</span>
<span class="fc bfc" id="L927" title="All 2 branches covered.">        for (int e : elements) {</span>
<span class="pc bpc" id="L928" title="1 of 2 branches missed.">            checkArgument(e &gt; 0, &quot;Size of decimal group must be at least one.&quot;);</span>
<span class="fc" id="L929">            list.add(e);</span>
        }
<span class="fc" id="L931">        return list;</span>
    }

    /**
     * Return a new coin-denominated formatter with the specified fraction-places.  The
     * returned object will format and parse values according to the default locale, and will
     * format the fraction part of numbers with at least two decimal places.  The sizes of
     * additional groups of decimal places can be specified by a variable number of
     * &lt;code&gt;int&lt;/code&gt; arguments.  Each optional decimal-place group will be applied only if
     * useful for expressing precision, and will be only partially applied if necessary to
     * avoid giving a place to fractional satoshis.
     */
    public static BtcFormat getCoinInstance(int minFractionPlaces, int... groups) {
<span class="fc" id="L944">        return getInstance(COIN_SCALE, defaultLocale(), minFractionPlaces, boxAsList(groups));</span>
    }

    /**
     * Return a new coin-denominated formatter for the given locale.  The returned object will
     * format the fractional part of numbers with two decimal places, rounding as necessary.
     */
    public static BtcFormat getCoinInstance(Locale locale) {
<span class="fc" id="L952">        return getInstance(COIN_SCALE, locale, 2);</span>
    }

    /**
     * Return a newly-constructed instance for the given locale that will format
     * values in terms of bitcoins, with the given minimum number of fractional
     * decimal places.  Optionally, repeating integer arguments can be passed, each
     * indicating the size of an additional group of fractional decimal places to be
     * used as necessary to avoid rounding, to a limiting precision of satoshis.
     */
    public static BtcFormat getCoinInstance(Locale locale, int scale, int... groups) {
<span class="fc" id="L963">        return getInstance(COIN_SCALE, locale, scale, boxAsList(groups));</span>
    }

    /**
     * Return a new millicoin-denominated formatter.  The returned object will format and
     * parse values for the default locale, and will format the fractional part of numbers with
     * two decimal places, rounding as necessary.
     */
<span class="fc" id="L971">    public static BtcFormat getMilliInstance() { return getMilliInstance(defaultLocale()); }</span>

    /**
     * Return a new millicoin-denominated formatter for the given locale.  The returned object
     * will format the fractional part of numbers with two decimal places, rounding as
     * necessary.
     */
    public static BtcFormat getMilliInstance(Locale locale) {
<span class="fc" id="L979">        return getInstance(MILLICOIN_SCALE, locale, 2);</span>
    }

    /**
     * Return a new millicoin-denominated formatter with the specified fractional decimal
     * placing.  The returned object will format and parse values according to the default
     * locale, and will format the fractional part of numbers with the given minimum number of
     * fractional decimal places.  Optionally, repeating integer arguments can be passed, each
     * indicating the size of an additional group of fractional decimal places to be used as
     * necessary to avoid rounding, to a limiting precision of satoshis.
     */
    public static BtcFormat getMilliInstance(int scale, int... groups) {
<span class="fc" id="L991">        return getInstance(MILLICOIN_SCALE, defaultLocale(), scale, boxAsList(groups));</span>
    }

    /**
     * Return a new millicoin-denominated formatter for the given locale with the specified
     * fractional decimal placing.  The returned object will format the fractional part of
     * numbers with the given minimum number of fractional decimal places.  Optionally,
     * repeating integer arguments can be passed, each indicating the size of an additional
     * group of fractional decimal places to be used as necessary to avoid rounding, to a
     * limiting precision of satoshis.
     */
    public static BtcFormat getMilliInstance(Locale locale, int scale, int... groups) {
<span class="fc" id="L1003">        return getInstance(MILLICOIN_SCALE, locale, scale, boxAsList(groups));</span>
    }

    /**
     * Return a new microcoin-denominated formatter for the default locale.  The returned object
     * will format the fractional part of numbers with two decimal places, rounding as
     * necessary.
     */
<span class="fc" id="L1011">    public static BtcFormat getMicroInstance() { return getMicroInstance(defaultLocale()); }</span>

    /**
     * Return a new microcoin-denominated formatter for the given locale.  The returned object
     * will format the fractional part of numbers with two decimal places, rounding as
     * necessary.
     */
    public static BtcFormat getMicroInstance(Locale locale) {
<span class="fc" id="L1019">        return getInstance(MICROCOIN_SCALE, locale);</span>
    }

    /**
     * Return a new microcoin-denominated formatter with the specified fractional decimal
     * placing.  The returned object will format and parse values according to the default
     * locale, and will format the fractional part of numbers with the given minimum number of
     * fractional decimal places.  Optionally, repeating integer arguments can be passed, each
     * indicating the size of an additional group of fractional decimal places to be used as
     * necessary to avoid rounding, to a limiting precision of satoshis.
     */
    public static BtcFormat getMicroInstance(int scale, int... groups) {
<span class="fc" id="L1031">        return getInstance(MICROCOIN_SCALE, defaultLocale(), scale, boxAsList(groups));</span>
    }

    /**
     * Return a new microcoin-denominated formatter for the given locale with the specified
     * fractional decimal placing.  The returned object will format the fractional part of
     * numbers with the given minimum number of fractional decimal places.  Optionally,
     * repeating integer arguments can be passed, each indicating the size of an additional
     * group of fractional decimal places to be used as necessary to avoid rounding, to a
     * limiting precision of satoshis.
     */
    public static BtcFormat getMicroInstance(Locale locale, int scale, int... groups) {
<span class="fc" id="L1043">        return getInstance(MICROCOIN_SCALE, locale, scale, boxAsList(groups));</span>
    }

    /**
     * Return a new fixeed-denomination formatter with the specified fractional decimal
     * placing.  The first argument specifies the denomination as the size of the
     * shift from coin-denomination in increasingly-precise decimal places.  The returned object will format
     * and parse values according to the default locale, and will format the fractional part of
     * numbers with the given minimum number of fractional decimal places.  Optionally,
     * repeating integer arguments can be passed, each indicating the size of an additional
     * group of fractional decimal places to be used as necessary to avoid rounding, to a
     * limiting precision of satoshis.
     */
    public static BtcFormat getInstance(int scale, int minDecimals, int... groups) {
<span class="fc" id="L1057">        return getInstance(scale, defaultLocale(), minDecimals, boxAsList(groups));</span>
    }

    /**
     * Return a new fixeed-denomination formatter.  The argument specifies the denomination as
     * the size of the shift from coin-denomination in increasingly-precise decimal places.
     * The returned object will format and parse values according to the default locale, and
     * will format the fractional part of numbers with two decimal places, or fewer as
     * necessary to avoid giving a place to fractional satoshis.
     */
    public static BtcFormat getInstance(int scale) {
<span class="fc" id="L1068">        return getInstance(scale, defaultLocale());</span>
    }

    /**
     * Return a new fixeed-denomination formatter for the given locale.  The first argument
     * specifies the denomination as the size of the shift from coin-denomination in
     * increasingly-precise decimal places.  The returned object will format and parse values
     * according to the locale specified by the second argument, and will format the fractional
     * part of numbers with two decimal places, or fewer as necessary to avoid giving a place
     * to fractional satoshis.
     */
    public static BtcFormat getInstance(int scale, Locale locale) {
<span class="fc" id="L1080">        return getInstance(scale, locale, 2);</span>
    }

    /**
     * Return a new fixed-denomination formatter for the given locale, with the specified
     * fractional decimal placing.  The first argument specifies the denomination as the size
     * of the shift from coin-denomination in increasingly-precise decimal places.  The third
     * parameter is the minimum number of fractional decimal places to use, followed by
     * optional repeating integer parameters each specifying the size of an additional group of
     * fractional decimal places to use as necessary to avoid rounding, down to a maximum
     * precision of satoshis.
     */
    public static BtcFormat getInstance(int scale, Locale locale, int minDecimals, int... groups) {
<span class="fc" id="L1093">        return getInstance(scale, locale, minDecimals, boxAsList(groups));</span>
    }

    /**
     * Return a new fixed-denomination formatter for the given locale, with the specified
     * fractional decimal placing.  The first argument specifies the denomination as the size
     * of the shift from coin-denomination in increasingly-precise decimal places.  The third
     * parameter is the minimum number of fractional decimal places to use.  The third argument
     * specifies the minimum number of fractional decimal places in formatted numbers.  The
     * last argument is a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Integer&lt;/code&gt; values, each of which
     * specifies the size of an additional group of fractional decimal places to use as
     * necessary to avoid rounding, down to a maximum precision of satoshis.
     */
    public static BtcFormat getInstance(int scale, Locale locale, int minDecimals, List&lt;Integer&gt; groups) {
<span class="fc" id="L1107">        return new BtcFixedFormat(locale, scale, minDecimals, groups);</span>
    }

    /***********************/
    /****** FORMATTING *****/
    /***********************/

    /**
     * Formats a bitcoin monetary value and returns an {@link java.text.AttributedCharacterIterator}.
     * By iterating, you can examine what fields apply to each character.  This can be useful
     * since a character may be part of more than one field, for example a grouping separator
     * that is also part of the integer field.
     *
     * @see java.text.AttributedCharacterIterator
     */
    @Override
<span class="fc" id="L1123">    public AttributedCharacterIterator formatToCharacterIterator(Object obj) { synchronized(numberFormat) {</span>
<span class="fc" id="L1124">        DecimalFormatSymbols anteSigns = numberFormat.getDecimalFormatSymbols();</span>
<span class="fc" id="L1125">        BigDecimal units = denominateAndRound(inSatoshis(obj), minimumFractionDigits, decimalGroups);</span>
<span class="fc" id="L1126">        List&lt;Integer&gt; anteDigits = setFormatterDigits(numberFormat, units.scale(), units.scale());</span>
<span class="fc" id="L1127">        AttributedCharacterIterator i = numberFormat.formatToCharacterIterator(units);</span>
<span class="fc" id="L1128">        numberFormat.setDecimalFormatSymbols(anteSigns);</span>
<span class="fc" id="L1129">        setFormatterDigits(numberFormat, anteDigits.get(0), anteDigits.get(1));</span>
<span class="fc" id="L1130">	return i;</span>
<span class="nc" id="L1131">    }}</span>

    /**
     * Formats a bitcoin value as a number and possibly a units indicator and appends the
     * resulting text to the given string buffer.  The type of monetary value argument can be
     * any one of any of the following classes: &lt;code&gt;{@link Coin}&lt;/code&gt;,
     * &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;BigInteger&lt;/code&gt;,
     * &lt;code&gt;BigDecimal&lt;/code&gt;.  Numeric types that can represent only an integer are interpreted
     * as that number of satoshis.  The value of a &lt;code&gt;BigDecimal&lt;/code&gt; is interpreted as that
     * number of bitcoins, rounded to the nearest satoshi as necessary.
     *
     * @return the &lt;code&gt;StringBuffer&lt;/code&gt; passed in as &lt;code&gt;toAppendTo&lt;/code&gt;
     */
    @Override
    public StringBuffer format(Object qty, StringBuffer toAppendTo, FieldPosition pos) {
<span class="fc" id="L1146">        return format(qty, toAppendTo, pos, minimumFractionDigits, decimalGroups);</span>
    }

    /**
     * Formats a bitcoin value as a number and possibly a units indicator to a
     * &lt;code&gt;String&lt;/code&gt;.The type of monetary value argument can be any one of any of the
     * following classes: &lt;code&gt;{@link Coin}&lt;/code&gt;, &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Long&lt;/code&gt;,
     * &lt;code&gt;BigInteger&lt;/code&gt;, &lt;code&gt;BigDecimal&lt;/code&gt;.  Numeric types that can represent only
     * an integer are interpreted as that number of satoshis.  The value of a
     * &lt;code&gt;BigDecimal&lt;/code&gt; is interpreted as that number of bitcoins, rounded to the
     * nearest satoshi as necessary.
     *
     * @param minDecimals The minimum number of decimal places in the fractional part of the formatted number
     * @param fractionGroups The sizes of optional additional fractional decimal-place groups
     * @throws IllegalArgumentException if the number of fraction places is negative.
     */
    public String format(Object qty, int minDecimals, int... fractionGroups) {
<span class="fc" id="L1163">        return format(qty, new StringBuffer(), new FieldPosition(0), minDecimals, boxAsList(fractionGroups)).toString();</span>
    }

    /**
     * Formats a bitcoin value as a number and possibly a units indicator and appends the
     * resulting text to the given string buffer.  The type of monetary value argument can be
     * any one of any of the following classes: &lt;code&gt;{@link Coin}&lt;/code&gt;,
     * &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;BigInteger&lt;/code&gt;,
     * &lt;code&gt;BigDecimal&lt;/code&gt;.  Numeric types that can represent only an integer are interpreted
     * as that number of satoshis.  The value of a &lt;code&gt;BigDecimal&lt;/code&gt; is interpreted as that
     * number of bitcoins, rounded to the nearest satoshi as necessary.
     *
     * @param minDecimals The minimum number of decimal places in the fractional part of the formatted number
     * @param fractionGroups The sizes of optional additional fractional decimal-place groups
     * @throws IllegalArgumentException if the number of fraction places is negative.
     */
    public StringBuffer format(Object qty, StringBuffer toAppendTo, FieldPosition pos,
                                            int minDecimals, int... fractionGroups) {
<span class="nc" id="L1181">        return format(qty, toAppendTo, pos, minDecimals, boxAsList(fractionGroups));</span>
    }

    private StringBuffer format(Object qty, StringBuffer toAppendTo, FieldPosition pos,
                                            int minDecimals, List&lt;Integer&gt; fractionGroups) {
<span class="pc bpc" id="L1186" title="1 of 2 branches missed.">        checkArgument(minDecimals &gt;= 0, &quot;There can be no fewer than zero fractional decimal places&quot;);</span>
<span class="fc" id="L1187">        synchronized (numberFormat) {</span>
<span class="fc" id="L1188">            DecimalFormatSymbols anteSigns = numberFormat.getDecimalFormatSymbols();</span>
<span class="fc" id="L1189">            BigDecimal denominatedUnitCount = denominateAndRound(inSatoshis(qty), minDecimals, fractionGroups);</span>
<span class="fc" id="L1190">            List&lt;Integer&gt; antePlaces =</span>
<span class="fc" id="L1191">                setFormatterDigits(numberFormat, denominatedUnitCount.scale(), denominatedUnitCount.scale());</span>
<span class="fc" id="L1192">            StringBuffer s = numberFormat.format(denominatedUnitCount, toAppendTo, pos);</span>
<span class="fc" id="L1193">            numberFormat.setDecimalFormatSymbols(anteSigns);</span>
<span class="fc" id="L1194">            setFormatterDigits(numberFormat, antePlaces.get(0), antePlaces.get(1));</span>
<span class="fc" id="L1195">            return s;</span>
<span class="fc" id="L1196">        }</span>
    }    

    /**
     * Return the denomination for formatting the given value.  The returned &lt;code&gt;int&lt;/code&gt;
     * is the size of the decimal-place shift between the given Bitcoin-value denominated in
     * bitcoins and that same value as formatted.  A fixed-denomination formatter will ignore
     * the arguments.
     *
     * @param satoshis The number of satoshis having the value for which the shift is calculated
     * @param fractionPlaces The number of decimal places available for displaying the
                             fractional part of the denominated value
     * @return The size of the shift in increasingly-precise decimal places
     */
    protected abstract int scale(BigInteger satoshis, int fractionPlaces);

    /** Return the denomination of this object.  Fixed-denomination formatters will override
     *  with their configured denomination, auto-formatters with coin denomination.  This
     *  determines the interpretation of parsed numbers lacking a units-indicator. */
    protected abstract int scale();

    /**
     * Takes a bitcoin monetary value that the client wants to format and returns the number of
     * denominational units having the equal value, rounded to the appropriate number of
     * decimal places.  Calls the scale() method of the subclass, which may have the
     * side-effect of changing the currency symbol and code of the underlying `NumberFormat`
     * object, therefore only invoke this from a synchronized method that resets the NumberFormat.
     */
    private BigDecimal denominateAndRound(BigInteger satoshis, int minDecimals, List&lt;Integer&gt; fractionGroups) {
<span class="fc" id="L1225">        int scale = scale(satoshis, minDecimals);</span>
<span class="fc" id="L1226">        BigDecimal denominatedUnitCount = new BigDecimal(satoshis).movePointLeft(offSatoshis(scale));</span>
<span class="fc" id="L1227">        int places = calculateFractionPlaces(denominatedUnitCount, scale, minDecimals, fractionGroups);</span>
<span class="fc" id="L1228">        return denominatedUnitCount.setScale(places, HALF_UP);</span>
    }

    /** Sets the number of fractional decimal places to be displayed on the given
     *  NumberFormat object to the value of the given integer.
     *  @return The minimum and maximum fractional places settings that the
     *          formatter had before this change, as an ImmutableList. */
    private static ImmutableList&lt;Integer&gt; setFormatterDigits(DecimalFormat formatter, int min, int max) {
<span class="fc" id="L1236">        ImmutableList&lt;Integer&gt; ante = ImmutableList.of(</span>
<span class="fc" id="L1237">            formatter.getMinimumFractionDigits(),</span>
<span class="fc" id="L1238">            formatter.getMaximumFractionDigits()</span>
        );
<span class="fc" id="L1240">        formatter.setMinimumFractionDigits(min);</span>
<span class="fc" id="L1241">        formatter.setMaximumFractionDigits(max);</span>
<span class="fc" id="L1242">        return ante;</span>
    }

    /** Return the number of fractional decimal places to be displayed when formatting
     *  the given number of monetory units of the denomination indicated by the given decimal scale value,
     *  where 0 = coin, 3 = millicoin, and so on.
     *
     *  @param unitCount      the number of monetary units to be formatted
     *  @param scale          the denomination of those units as the decimal-place shift from coins
     *  @param minDecimals    the minimum number of fractional decimal places
     *  @param fractionGroups the sizes of option fractional decimal-place groups
     */
    private static int calculateFractionPlaces(
        BigDecimal unitCount, int scale, int minDecimals, List&lt;Integer&gt; fractionGroups)
    {
        /* Taking into account BOTH the user's preference for decimal-place groups, AND the prohibition
         * against displaying a fractional number of satoshis, determine the maximum possible number of
         * fractional decimal places. */
<span class="fc" id="L1260">        int places = minDecimals;</span>
<span class="fc bfc" id="L1261" title="All 2 branches covered.">        for (int group : fractionGroups) { places += group; }</span>
<span class="fc" id="L1262">        int max = Math.min(places, offSatoshis(scale));</span>

<span class="fc" id="L1264">        places = Math.min(minDecimals,max);</span>
<span class="fc bfc" id="L1265" title="All 2 branches covered.">        for (int group : fractionGroups) {</span>
            /* Compare the value formatted using only this many decimal places to the
             * same value using as many places as possible.  If there's no difference, then
             * there's no reason to continue adding more places.  */
<span class="fc bfc" id="L1269" title="All 2 branches covered.">            if (unitCount.setScale(places, HALF_UP).compareTo(unitCount.setScale(max, HALF_UP)) == 0) break;</span>
<span class="fc" id="L1270">            places += group;</span>
<span class="fc bfc" id="L1271" title="All 2 branches covered.">            if (places &gt; max) places = max;</span>
<span class="fc" id="L1272">        }</span>
<span class="fc" id="L1273">        return places;</span>
    }

    /**
     * Takes an object representing a bitcoin quantity of any type the
     * client is permitted to pass us, and return a BigInteger representing the
     * number of satoshis having the equivalent value. */
    private static BigInteger inSatoshis(Object qty) {
	BigInteger satoshis;
        // the value might be bitcoins or satoshis
<span class="fc bfc" id="L1283" title="All 4 branches covered.">	if (qty instanceof Long || qty instanceof Integer)</span>
<span class="fc" id="L1284">	    satoshis = BigInteger.valueOf(((Number)qty).longValue());</span>
<span class="fc bfc" id="L1285" title="All 2 branches covered.">	else if (qty instanceof BigInteger)</span>
<span class="fc" id="L1286">	    satoshis = (BigInteger)qty;</span>
<span class="fc bfc" id="L1287" title="All 2 branches covered.">	else if (qty instanceof BigDecimal)</span>
<span class="fc" id="L1288">	    satoshis = ((BigDecimal)qty).movePointRight(Coin.SMALLEST_UNIT_EXPONENT).</span>
<span class="fc" id="L1289">                       setScale(0,BigDecimal.ROUND_HALF_UP).unscaledValue();</span>
<span class="fc bfc" id="L1290" title="All 2 branches covered.">	else if (qty instanceof Coin)</span>
<span class="fc" id="L1291">	    satoshis = BigInteger.valueOf(((Coin)qty).value);</span>
	else
<span class="fc" id="L1293">	    throw new IllegalArgumentException(&quot;Cannot format a &quot; + qty.getClass().getSimpleName() +</span>
                                               &quot; as a Bicoin value&quot;);
<span class="fc" id="L1295">        return satoshis;</span>
    }

    /********************/
    /****** PARSING *****/
    /********************/

    /**
      * Parse a &lt;code&gt;String&lt;/code&gt; representation of a Bitcoin monetary value.  Returns a
      * {@link org.bitcoinj.core.Coin} object that represents the parsed value.
      * @see java.text.NumberFormat */
    @Override
<span class="fc" id="L1307">    public final Object parseObject(String source, ParsePosition pos) { return parse(source, pos); }</span>

    private class ScaleMatcher {
        public Pattern pattern;
        public int scale;
<span class="fc" id="L1312">        ScaleMatcher(Pattern p, int s) { pattern = p; scale = s; }</span>
    }

    /* Lazy initialization;  No reason to create all these objects unless needed for parsing */
    // coin indicator regex String; TODO: does this need to be volatile?
<span class="fc" id="L1317">    private volatile String ci = &quot;(&quot; + COIN_SYMBOL + &quot;|&quot; + COIN_SYMBOL_ALT + &quot;|B⃦|&quot; + COIN_CODE + &quot;|XBT)&quot;;</span>
    private Pattern coinPattern;
    private volatile ScaleMatcher[] denoms;
    ScaleMatcher[] denomMatchers() {
<span class="fc" id="L1321">        ScaleMatcher[] result = denoms;</span>
<span class="fc bfc" id="L1322" title="All 2 branches covered.">        if (result == null) { synchronized(this) {</span>
<span class="fc" id="L1323">            result = denoms;</span>
<span class="pc bpc" id="L1324" title="1 of 2 branches missed.">            if (result == null) {</span>
<span class="fc bfc" id="L1325" title="All 2 branches covered.">                if (! coinSymbol().matches(ci)) ci = ci.replaceFirst(&quot;\\(&quot;, &quot;(&quot; + coinSymbol() + &quot;|&quot;);</span>
<span class="fc bfc" id="L1326" title="All 2 branches covered.">                if (! coinCode().matches(ci))  {</span>
<span class="fc" id="L1327">                    ci = ci.replaceFirst(&quot;\\)&quot;, &quot;|&quot; + coinCode() + &quot;)&quot;);</span>
                }
<span class="fc" id="L1329">                coinPattern = Pattern.compile(ci + &quot;?&quot;);</span>
<span class="fc" id="L1330">                result = denoms = new ScaleMatcher[]{</span>
<span class="fc" id="L1331">                    new ScaleMatcher(Pattern.compile(&quot;¢&quot; + ci + &quot;?|c&quot; + ci), 2), // centi </span>
<span class="fc" id="L1332">                    new ScaleMatcher(Pattern.compile(&quot;₥&quot; + ci + &quot;?|m&quot; + ci), MILLICOIN_SCALE),</span>
<span class="fc" id="L1333">                    new ScaleMatcher(Pattern.compile(&quot;([µu]&quot; + ci + &quot;)&quot;),    MICROCOIN_SCALE),</span>
<span class="fc" id="L1334">                    new ScaleMatcher(Pattern.compile(&quot;(da&quot; + ci + &quot;)&quot;),     -1), // deka</span>
<span class="fc" id="L1335">                    new ScaleMatcher(Pattern.compile(&quot;(h&quot; + ci + &quot;)&quot;),      -2), // hekto</span>
<span class="fc" id="L1336">                    new ScaleMatcher(Pattern.compile(&quot;(k&quot; + ci + &quot;)&quot;),      -3), // kilo</span>
<span class="fc" id="L1337">                    new ScaleMatcher(Pattern.compile(&quot;(M&quot; + ci + &quot;)&quot;),      -6)  // mega</span>
                };
            }
<span class="pc" id="L1340">        }}</span>
<span class="fc" id="L1341">        return result;</span>
    }

    /** Set both the currency symbol and international code of the underlying {@link
      * java.text.NumberFormat} object to the value of the given &lt;code&gt;String&lt;/code&gt;.
      * This method is invoked in the process of parsing, not formatting.
      *
      * Only invoke this from code synchronized on the value of the first argument, and don't
      * forget to put the symbols back otherwise equals(), hashCode() and immutability will
      * break.  */
    private static DecimalFormatSymbols setSymbolAndCode(DecimalFormat numberFormat, String sign) {
<span class="fc" id="L1352">        return setSymbolAndCode(numberFormat, sign, sign);</span>
    }

    /** Set the currency symbol and international code of the underlying {@link
      * java.text.NumberFormat} object to the values of the last two arguments, respectively.
      * This method is invoked in the process of parsing, not formatting.
      *
      * Only invoke this from code synchronized on value of the first argument, and don't
      * forget to put the symbols back otherwise equals(), hashCode() and immutability will
      * break.  */
    private static DecimalFormatSymbols setSymbolAndCode(DecimalFormat numberFormat, String symbol, String code) {
<span class="fc" id="L1363">        checkState(Thread.holdsLock(numberFormat));</span>
<span class="fc" id="L1364">        DecimalFormatSymbols fs = numberFormat.getDecimalFormatSymbols();</span>
<span class="fc" id="L1365">        DecimalFormatSymbols ante = (DecimalFormatSymbols)fs.clone();</span>
<span class="fc" id="L1366">        fs.setInternationalCurrencySymbol(code);</span>
<span class="fc" id="L1367">        fs.setCurrencySymbol(symbol);</span>
<span class="fc" id="L1368">        numberFormat.setDecimalFormatSymbols(fs);</span>
<span class="fc" id="L1369">        return ante;</span>
    }

    /**
     * Set both the currency symbol and code of the underlying, mutable NumberFormat object
     * according to the given denominational units scale factor.  This is for formatting, not parsing.
     *
     * &lt;p&gt;Set back to zero when you're done formatting otherwise immutability, equals() and
     * hashCode() will break!
     *
     * @param scale Number of places the decimal point will be shifted when formatting
     *              a quantity of satoshis.
     */
    protected static void prefixUnitsIndicator(DecimalFormat numberFormat, int scale) {
<span class="fc" id="L1383">        checkState(Thread.holdsLock(numberFormat)); // make sure caller intends to reset before changing</span>
<span class="fc" id="L1384">        DecimalFormatSymbols fs = numberFormat.getDecimalFormatSymbols();</span>
<span class="fc" id="L1385">        setSymbolAndCode(numberFormat,</span>
<span class="fc" id="L1386">            prefixSymbol(fs.getCurrencySymbol(), scale), prefixCode(fs.getInternationalCurrencySymbol(), scale)</span>
        );
<span class="fc" id="L1388">    }</span>

    /** Parse a &lt;code&gt;String&lt;/code&gt; representation of a Bitcoin monetary value.  If this
     * object's pattern includes a currency sign, either symbol or code, as by default is true
     * for instances of {@link BtcAutoFormat} and false for instances of {@link
     * BtcFixedFormat}, then denominated (i.e., prefixed) currency signs in the parsed String
     * will be recognized, and the parsed number will be interpreted as a quantity of units
     * having that recognized denomination.
     * &lt;p&gt;If the pattern includes a currency sign but no currency sign is detected in the parsed
     * String, then the number is interpreted as a quatity of bitcoins.
     * &lt;p&gt;If the pattern contains neither a currency symbol nor sign, then instances of {@link
     * BtcAutoFormat} will interpret the parsed number as a quantity of bitcoins, and instances
     * of {@link BtcAutoFormat} will interpret the number as a quantity of that instance's
     * configured denomination, which can be ascertained by invoking the {@link
     * BtcFixedFormat#symbol()} or {@link BtcFixedFormat#code()} method.
     *
     * &lt;p&gt;Consider using the single-argument version of this overloaded method unless you need to
     * keep track of the current parse position.
     *
     * @return a Coin object representing the parsed value
     * @see java.text.ParsePosition
     */
    public Coin parse(String source, ParsePosition pos) {
<span class="fc" id="L1411">        DecimalFormatSymbols anteSigns = null;</span>
<span class="fc" id="L1412">        int parseScale = COIN_SCALE; // default</span>
<span class="fc" id="L1413">        Coin coin = null;</span>
<span class="fc" id="L1414">        synchronized (numberFormat) {</span>
<span class="fc bfc" id="L1415" title="All 2 branches covered.">            if (numberFormat.toPattern().contains(&quot;¤&quot;)) {</span>
<span class="fc bfc" id="L1416" title="All 2 branches covered.">                for(ScaleMatcher d : denomMatchers()) {</span>
<span class="fc" id="L1417">                    Matcher matcher = d.pattern.matcher(source);</span>
<span class="fc bfc" id="L1418" title="All 2 branches covered.">                    if (matcher.find()) {</span>
<span class="fc" id="L1419">                        anteSigns = setSymbolAndCode(numberFormat, matcher.group());</span>
<span class="fc" id="L1420">                        parseScale = d.scale;</span>
<span class="fc" id="L1421">                        break;</span>
                    }
                }
<span class="fc bfc" id="L1424" title="All 2 branches covered.">                if (parseScale == COIN_SCALE) {</span>
<span class="fc" id="L1425">                    Matcher matcher = coinPattern.matcher(source);</span>
<span class="fc" id="L1426">                    matcher.find();</span>
<span class="fc" id="L1427">                    anteSigns = setSymbolAndCode(numberFormat, matcher.group());</span>
<span class="fc" id="L1428">                }</span>
<span class="fc" id="L1429">            } else parseScale = scale();</span>

<span class="fc" id="L1431">            Number number = numberFormat.parse(source, pos);</span>
<span class="fc bfc" id="L1432" title="All 2 branches covered.">            if (number != null) try {</span>
<span class="fc" id="L1433">                    coin = Coin.valueOf(</span>
<span class="fc" id="L1434">                        ((BigDecimal)number).movePointRight(offSatoshis(parseScale)).setScale(0, HALF_UP).longValue()</span>
                    );
<span class="nc" id="L1436">                } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1437">                    pos.setIndex(0);</span>
<span class="fc" id="L1438">                }</span>
<span class="fc bfc" id="L1439" title="All 2 branches covered.">            if (anteSigns != null) numberFormat.setDecimalFormatSymbols(anteSigns);</span>
<span class="pc" id="L1440">        }</span>
<span class="fc" id="L1441">        return coin;</span>
    }

    /** Parse a &lt;code&gt;String&lt;/code&gt; representation of a Bitcoin monetary value.  If this
     * object's pattern includes a currency sign, either symbol or code, as by default is true
     * for instances of {@link BtcAutoFormat} and false for instances of {@link
     * BtcFixedFormat}, then denominated (i.e., prefixed) currency signs in the parsed String
     * will be recognized, and the parsed number will be interpreted as a quantity of units
     * having that recognized denomination.
     * &lt;p&gt;If the pattern includes a currency sign but no currency sign is detected in the parsed
     * String, then the number is interpreted as a quatity of bitcoins.
     * &lt;p&gt;If the pattern contains neither a currency symbol nor sign, then instances of {@link
     * BtcAutoFormat} will interpret the parsed number as a quantity of bitcoins, and instances
     * of {@link BtcAutoFormat} will interpret the number as a quantity of that instance's
     * configured denomination, which can be ascertained by invoking the {@link
     * BtcFixedFormat#symbol()} or {@link BtcFixedFormat#code()} method.
     *
     * @return a Coin object representing the parsed value
     */
    public Coin parse(String source) throws ParseException {
<span class="nc" id="L1461">        return (Coin)parseObject(source);</span>
    }

    /*********************************/
    /****** END OF PARSING STUFF *****/
    /*********************************/

    protected static String prefixCode(String code, int scale) {
<span class="pc bpc" id="L1469" title="1 of 10 branches missed.">        switch (scale) {</span>
<span class="fc" id="L1470">        case COIN_SCALE:      return code;</span>
<span class="nc" id="L1471">        case 1:               return &quot;d&quot; + code;</span>
<span class="fc" id="L1472">        case 2:               return &quot;c&quot; + code;</span>
<span class="fc" id="L1473">        case MILLICOIN_SCALE: return &quot;m&quot; + code;</span>
<span class="fc" id="L1474">        case MICROCOIN_SCALE: return &quot;µ&quot; + code;</span>
<span class="fc" id="L1475">        case -1:              return &quot;da&quot; + code;</span>
<span class="fc" id="L1476">        case -2:              return &quot;h&quot; + code;</span>
<span class="fc" id="L1477">        case -3:              return &quot;k&quot; + code;</span>
<span class="fc" id="L1478">        case -6:              return &quot;M&quot; + code;</span>
<span class="fc" id="L1479">        default: throw new IllegalStateException(&quot;No known prefix for scale &quot; + String.valueOf(scale));</span>
        }
    }

    protected static String prefixSymbol(String symbol, int scale) {
<span class="pc bpc" id="L1484" title="1 of 10 branches missed.">        switch (scale) {</span>
<span class="fc" id="L1485">        case COIN_SCALE:      return symbol;</span>
<span class="nc" id="L1486">        case 1:               return &quot;d&quot; + symbol;</span>
<span class="fc" id="L1487">        case 2:               return &quot;¢&quot; + symbol;</span>
<span class="fc" id="L1488">        case MILLICOIN_SCALE: return &quot;₥&quot; + symbol;</span>
<span class="fc" id="L1489">        case MICROCOIN_SCALE: return &quot;µ&quot; + symbol;</span>
<span class="fc" id="L1490">        case -1:              return &quot;da&quot; + symbol;</span>
<span class="fc" id="L1491">        case -2:              return &quot;h&quot; + symbol;</span>
<span class="fc" id="L1492">        case -3:              return &quot;k&quot; + symbol;</span>
<span class="fc" id="L1493">        case -6:              return &quot;M&quot; + symbol;</span>
<span class="fc" id="L1494">        default: throw new IllegalStateException(&quot;No known prefix for scale &quot; + String.valueOf(scale));</span>
        }
    }

    /** Guarantee a formatting pattern has a subpattern for negative values.  This method takes
     *  a pattern that may be missing a negative subpattern, and returns the same pattern with
     *  a negative subpattern appended as needed.
     *
     *  &lt;p&gt;This method accommodates an imperfection in the Java formatting code and distributed
     *  locale data.  To wit: the subpattern for negative numbers is optional and not all
     *  locales have one. In those cases, {@link java.text.DecimalFormat} will indicate numbers
     *  less than zero by adding a negative sign as the first character of the prefix of the
     *  positive subpattern.
     *
     *  &lt;p&gt;We don't like this, since we claim the negative sign applies to the number not the
     *  units, and therefore it ought to be adjacent to the number, displacing the
     *  currency-units indicator if necessary.
     */
    protected static String negify(String pattern) {
<span class="fc bfc" id="L1513" title="All 2 branches covered.">        if (pattern.contains(&quot;;&quot;)) return pattern;</span>
        else {
<span class="pc bpc" id="L1515" title="1 of 2 branches missed.">            if (pattern.contains(&quot;-&quot;))</span>
<span class="nc" id="L1516">                throw new IllegalStateException(&quot;Positive pattern contains negative sign&quot;);</span>
            // the regex matches everything until the first non-quoted number character
<span class="fc" id="L1518">            return pattern + &quot;;&quot; + pattern.replaceFirst(&quot;^([^#0,.']*('[^']*')?)*&quot;, &quot;$0-&quot;);</span>
        }
    }

    /**
     * Return an array of all locales for which the getInstance() method of this class can
     * return localized instances.  See {@link java.text.NumberFormat#getAvailableLocales()}
     */
<span class="fc" id="L1526">    public static Locale[] getAvailableLocales() { return NumberFormat.getAvailableLocales(); }</span>

    /** Return the unprefixed currency symbol for bitcoins configured for this object.  The
     *  return value of this method is constant throughough the life of an instance.  */
<span class="fc" id="L1530">    public String coinSymbol() { synchronized(numberFormat) {</span>
<span class="fc" id="L1531">        return numberFormat.getDecimalFormatSymbols().getCurrencySymbol();</span>
<span class="nc" id="L1532">    }}</span>

    /** Return the unprefixed international currency code for bitcoins configured for this
     * object.  The return value of this method is constant throughough the life of an instance.  */
<span class="fc" id="L1536">    public String coinCode() { synchronized(numberFormat) {</span>
<span class="fc" id="L1537">        return numberFormat.getDecimalFormatSymbols().getInternationalCurrencySymbol();</span>
<span class="nc" id="L1538">    }}</span>

    /** Return a representation of the pattern used by this instance for formatting and
     *  parsing.  The format is similar to, but not the same as the format recognized by the
     *  {@link Builder#pattern} and {@link Builder#localizedPattern} methods.  The pattern
     *  returned by this method is localized, any currency signs expressed are literally, and
     *  optional fractional decimal places are shown grouped in parentheses. */
<span class="fc" id="L1545">    public String pattern() { synchronized(numberFormat) {</span>
<span class="fc" id="L1546">        StringBuilder groups = new StringBuilder();</span>
<span class="fc bfc" id="L1547" title="All 2 branches covered.">        for (int group : decimalGroups) {</span>
<span class="fc" id="L1548">            groups.append(&quot;(&quot;).append(Strings.repeat(&quot;#&quot;, group)).append(&quot;)&quot;);</span>
<span class="fc" id="L1549">        }</span>
<span class="fc" id="L1550">        DecimalFormatSymbols s = numberFormat.getDecimalFormatSymbols();</span>
<span class="fc" id="L1551">        String digit = String.valueOf(s.getDigit());</span>
<span class="fc" id="L1552">        String exp = s.getExponentSeparator();</span>
<span class="fc" id="L1553">        String groupSep = String.valueOf(s.getGroupingSeparator());</span>
<span class="fc" id="L1554">        String moneySep = String.valueOf(s.getMonetaryDecimalSeparator());</span>
<span class="fc" id="L1555">        String zero = String.valueOf(s.getZeroDigit());</span>
<span class="fc" id="L1556">        String boundary = String.valueOf(s.getPatternSeparator());</span>
<span class="fc" id="L1557">        String minus = String.valueOf(s.getMinusSign());</span>
<span class="fc" id="L1558">        String decSep = String.valueOf(s.getDecimalSeparator());</span>

<span class="fc" id="L1560">        String prefixAndNumber = &quot;(^|&quot; + boundary+ &quot;)&quot; +</span>
<span class="fc" id="L1561">            &quot;([^&quot; + Matcher.quoteReplacement(digit + zero + groupSep + decSep + moneySep) + &quot;']*('[^']*')?)*&quot; +</span>
<span class="fc" id="L1562">            &quot;[&quot; + Matcher.quoteReplacement(digit + zero + groupSep + decSep + moneySep + exp) + &quot;]+&quot;;</span>

<span class="fc" id="L1564">        return numberFormat.toLocalizedPattern().</span>
<span class="fc" id="L1565">            replaceAll(prefixAndNumber, &quot;$0&quot; + groups.toString()).</span>
<span class="fc" id="L1566">               replaceAll(&quot;¤¤&quot;, Matcher.quoteReplacement(coinCode())).</span>
<span class="fc" id="L1567">               replaceAll(&quot;¤&quot;, Matcher.quoteReplacement(coinSymbol()));</span>
<span class="nc" id="L1568">    }}</span>

    /** Return a copy of the localized symbols used by this instance for formatting and parsing.  */
<span class="fc" id="L1571">    public DecimalFormatSymbols symbols() { synchronized(numberFormat) {</span>
<span class="fc" id="L1572">        return numberFormat.getDecimalFormatSymbols();</span>
<span class="nc" id="L1573">    }}</span>

    /** Return true if the given object is equivalent to this one.
      * Formatters for different locales will never be equal, even
      * if they behave identically. */
    @Override public boolean equals(Object o) {
<span class="pc bpc" id="L1579" title="1 of 2 branches missed.">        if (o == this) return true;</span>
<span class="pc bpc" id="L1580" title="1 of 2 branches missed.">        if (!(o instanceof BtcFormat)) return false;</span>
<span class="fc" id="L1581">        BtcFormat other = (BtcFormat)o;</span>
<span class="fc bfc" id="L1582" title="All 2 branches covered.">        return other.pattern().equals(pattern()) &amp;&amp;</span>
<span class="pc bpc" id="L1583" title="1 of 4 branches missed.">               other.symbols().equals(symbols()) &amp;&amp;</span>
               other.minimumFractionDigits == minimumFractionDigits;
    }

    /** Return a hash code value for this instance.
     *  @see java.lang.Object#hashCode
     */
    @Override public int hashCode() {
<span class="fc" id="L1591">        return Objects.hashCode(pattern(), symbols(), minimumFractionDigits, decimalGroups);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>