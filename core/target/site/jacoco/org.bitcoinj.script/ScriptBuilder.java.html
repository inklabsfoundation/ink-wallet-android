<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ScriptBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bitcoinj</a> &gt; <a href="index.source.html" class="el_package">org.bitcoinj.script</a> &gt; <span class="el_source">ScriptBuilder.java</span></div><h1>ScriptBuilder.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013 Google Inc.
 * Copyright 2018 Nicola Atzei
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bitcoinj.script;

import com.google.common.collect.Lists;
import org.bitcoinj.core.Address;
import org.bitcoinj.core.ECKey;
import org.bitcoinj.core.Utils;
import org.bitcoinj.crypto.TransactionSignature;

import javax.annotation.Nullable;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Stack;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkState;
import static org.bitcoinj.script.ScriptOpCodes.*;

/**
 * &lt;p&gt;Tools for the construction of commonly used script types. You don't normally need this as it's hidden behind
 * convenience methods on {@link org.bitcoinj.core.Transaction}, but they are useful when working with the
 * protocol at a lower level.&lt;/p&gt;
 */
public class ScriptBuilder {
    private List&lt;ScriptChunk&gt; chunks;

    /** Creates a fresh ScriptBuilder with an empty program. */
<span class="fc" id="L47">    public ScriptBuilder() {</span>
<span class="fc" id="L48">        chunks = Lists.newLinkedList();</span>
<span class="fc" id="L49">    }</span>

    /** Creates a fresh ScriptBuilder with the given program as the starting point. */
<span class="nc" id="L52">    public ScriptBuilder(Script template) {</span>
<span class="nc" id="L53">        chunks = new ArrayList&lt;&gt;(template.getChunks());</span>
<span class="nc" id="L54">    }</span>

    /** Adds the given chunk to the end of the program */
    public ScriptBuilder addChunk(ScriptChunk chunk) {
<span class="fc" id="L58">        return addChunk(chunks.size(), chunk);</span>
    }

    /** Adds the given chunk at the given index in the program */
    public ScriptBuilder addChunk(int index, ScriptChunk chunk) {
<span class="fc" id="L63">        chunks.add(index, chunk);</span>
<span class="fc" id="L64">        return this;</span>
    }

    /** Adds the given opcode to the end of the program. */
    public ScriptBuilder op(int opcode) {
<span class="fc" id="L69">        return op(chunks.size(), opcode);</span>
    }

    /** Adds the given opcode to the given index in the program */
    public ScriptBuilder op(int index, int opcode) {
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">        checkArgument(opcode &gt; OP_PUSHDATA4);</span>
<span class="fc" id="L75">        return addChunk(index, new ScriptChunk(opcode, null));</span>
    }

    /** Adds a copy of the given byte array as a data element (i.e. PUSHDATA) at the end of the program. */
    public ScriptBuilder data(byte[] data) {
<span class="fc bfc" id="L80" title="All 2 branches covered.">        if (data.length == 0)</span>
<span class="fc" id="L81">            return smallNum(0);</span>
        else
<span class="fc" id="L83">            return data(chunks.size(), data);</span>
    }

    /** Adds a copy of the given byte array as a data element (i.e. PUSHDATA) at the given index in the program. */
    public ScriptBuilder data(int index, byte[] data) {
        // implements BIP62
<span class="fc" id="L89">        byte[] copy = Arrays.copyOf(data, data.length);</span>
        int opcode;
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">        if (data.length == 0) {</span>
<span class="nc" id="L92">            opcode = OP_0;</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">        } else if (data.length == 1) {</span>
<span class="fc" id="L94">            byte b = data[0];</span>
<span class="fc bfc" id="L95" title="All 4 branches covered.">            if (b &gt;= 1 &amp;&amp; b &lt;= 16)</span>
<span class="fc" id="L96">                opcode = Script.encodeToOpN(b);</span>
            else
<span class="fc" id="L98">                opcode = 1;</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">        } else if (data.length &lt; OP_PUSHDATA1) {</span>
<span class="fc" id="L100">            opcode = data.length;</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">        } else if (data.length &lt; 256) {</span>
<span class="fc" id="L102">            opcode = OP_PUSHDATA1;</span>
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">        } else if (data.length &lt; 65536) {</span>
<span class="fc" id="L104">            opcode = OP_PUSHDATA2;</span>
        } else {
<span class="nc" id="L106">            throw new RuntimeException(&quot;Unimplemented&quot;);</span>
        }
<span class="fc" id="L108">        return addChunk(index, new ScriptChunk(opcode, copy));</span>
    }

    /**
     * Adds the given number to the end of the program. Automatically uses
     * shortest encoding possible.
     */
    public ScriptBuilder number(long num) {
<span class="fc" id="L116">        return number(chunks.size(), num);</span>
    }

    /**
     * Adds the given number to the given index in the program. Automatically
     * uses shortest encoding possible.
     */
    public ScriptBuilder number(int index, long num) {
<span class="fc bfc" id="L124" title="All 2 branches covered.">        if (num == -1) {</span>
<span class="fc" id="L125">            return op(index, OP_1NEGATE);</span>
<span class="fc bfc" id="L126" title="All 4 branches covered.">        } else if (num &gt;= 0 &amp;&amp; num &lt;= 16) {</span>
<span class="fc" id="L127">            return smallNum(index, (int) num);</span>
        } else {
<span class="fc" id="L129">            return bigNum(index, num);</span>
        }
    }

    /**
     * Adds the given number as a OP_N opcode to the end of the program.
     * Only handles values 0-16 inclusive.
     * 
     * @see #number(long)
     */
    public ScriptBuilder smallNum(int num) {
<span class="fc" id="L140">        return smallNum(chunks.size(), num);</span>
    }

    /** Adds the given number as a push data chunk.
     * This is intended to use for negative numbers or values &gt; 16, and although
     * it will accept numbers in the range 0-16 inclusive, the encoding would be
     * considered non-standard.
     * 
     * @see #number(long)
     */
    protected ScriptBuilder bigNum(long num) {
<span class="nc" id="L151">        return bigNum(chunks.size(), num);</span>
    }

    /**
     * Adds the given number as a OP_N opcode to the given index in the program.
     * Only handles values 0-16 inclusive.
     * 
     * @see #number(long)
     */
    public ScriptBuilder smallNum(int index, int num) {
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">        checkArgument(num &gt;= 0, &quot;Cannot encode negative numbers with smallNum&quot;);</span>
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">        checkArgument(num &lt;= 16, &quot;Cannot encode numbers larger than 16 with smallNum&quot;);</span>
<span class="fc" id="L163">        return addChunk(index, new ScriptChunk(Script.encodeToOpN(num), null));</span>
    }

    /**
     * Adds the given number as a push data chunk to the given index in the program.
     * This is intended to use for negative numbers or values &gt; 16, and although
     * it will accept numbers in the range 0-16 inclusive, the encoding would be
     * considered non-standard.
     * 
     * @see #number(long)
     */
    protected ScriptBuilder bigNum(int index, long num) {
        final byte[] data;

<span class="pc bpc" id="L177" title="1 of 2 branches missed.">        if (num == 0) {</span>
<span class="nc" id="L178">            data = new byte[0];</span>
        } else {
<span class="fc" id="L180">            Stack&lt;Byte&gt; result = new Stack&lt;&gt;();</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">            final boolean neg = num &lt; 0;</span>
<span class="fc" id="L182">            long absvalue = Math.abs(num);</span>

<span class="fc bfc" id="L184" title="All 2 branches covered.">            while (absvalue != 0) {</span>
<span class="fc" id="L185">                result.push((byte) (absvalue &amp; 0xff));</span>
<span class="fc" id="L186">                absvalue &gt;&gt;= 8;</span>
            }

<span class="fc bfc" id="L189" title="All 2 branches covered.">            if ((result.peek() &amp; 0x80) != 0) {</span>
                // The most significant byte is &gt;= 0x80, so push an extra byte that
                // contains just the sign of the value.
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">                result.push((byte) (neg ? 0x80 : 0));</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">            } else if (neg) {</span>
                // The most significant byte is &lt; 0x80 and the value is negative,
                // set the sign bit so it is subtracted and interpreted as a
                // negative when converting back to an integral.
<span class="fc" id="L197">                result.push((byte) (result.pop() | 0x80));</span>
            }

<span class="fc" id="L200">            data = new byte[result.size()];</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">            for (int byteIdx = 0; byteIdx &lt; data.length; byteIdx++) {</span>
<span class="fc" id="L202">                data[byteIdx] = result.get(byteIdx);</span>
            }
        }

        // At most the encoded value could take up to 8 bytes, so we don't need
        // to use OP_PUSHDATA opcodes
<span class="fc" id="L208">        return addChunk(index, new ScriptChunk(data.length, data));</span>
    }

    /**
     * Adds true to the end of the program.
     * @return this
     */
    public ScriptBuilder opTrue() {
<span class="fc" id="L216">        return number(1); // it push OP_1/OP_TRUE</span>
    }

    /**
     * Adds true to the given index in the program.
     * @param index at which insert true
     * @return this
     */
    public ScriptBuilder opTrue(int index) {
<span class="nc" id="L225">        return number(index, 1); // push OP_1/OP_TRUE</span>
    }

    /**
     * Adds false to the end of the program.
     * @return this
     */
    public ScriptBuilder opFalse() {
<span class="fc" id="L233">        return number(0); // push OP_0/OP_FALSE</span>
    }

    /**
     * Adds false to the given index in the program.
     * @param index at which insert true
     * @return this
     */
    public ScriptBuilder opFalse(int index) {
<span class="nc" id="L242">        return number(index, 0); // push OP_0/OP_FALSE</span>
    }

    /** Creates a new immutable Script based on the state of the builder. */
    public Script build() {
<span class="fc" id="L247">        return new Script(chunks);</span>
    }

    /** Creates a scriptPubKey that encodes payment to the given address. */
    public static Script createOutputScript(Address to) {
<span class="fc bfc" id="L252" title="All 2 branches covered.">        if (to.isP2SHAddress()) {</span>
            // OP_HASH160 &lt;scriptHash&gt; OP_EQUAL
<span class="fc" id="L254">            return new ScriptBuilder()</span>
<span class="fc" id="L255">                .op(OP_HASH160)</span>
<span class="fc" id="L256">                .data(to.getHash160())</span>
<span class="fc" id="L257">                .op(OP_EQUAL)</span>
<span class="fc" id="L258">                .build();</span>
        } else {
            // OP_DUP OP_HASH160 &lt;pubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG
<span class="fc" id="L261">            return new ScriptBuilder()</span>
<span class="fc" id="L262">                .op(OP_DUP)</span>
<span class="fc" id="L263">                .op(OP_HASH160)</span>
<span class="fc" id="L264">                .data(to.getHash160())</span>
<span class="fc" id="L265">                .op(OP_EQUALVERIFY)</span>
<span class="fc" id="L266">                .op(OP_CHECKSIG)</span>
<span class="fc" id="L267">                .build();</span>
        }
    }

    /** Creates a scriptPubKey that encodes payment to the given raw public key. */
    public static Script createOutputScript(ECKey key) {
<span class="fc" id="L273">        return new ScriptBuilder().data(key.getPubKey()).op(OP_CHECKSIG).build();</span>
    }

    /**
     * Creates a scriptSig that can redeem a pay-to-address output.
     * If given signature is null, incomplete scriptSig will be created with OP_0 instead of signature
     */
    public static Script createInputScript(@Nullable TransactionSignature signature, ECKey pubKey) {
<span class="fc" id="L281">        byte[] pubkeyBytes = pubKey.getPubKey();</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">        byte[] sigBytes = signature != null ? signature.encodeToBitcoin() : new byte[]{};</span>
<span class="fc" id="L283">        return new ScriptBuilder().data(sigBytes).data(pubkeyBytes).build();</span>
    }

    /**
     * Creates a scriptSig that can redeem a pay-to-pubkey output.
     * If given signature is null, incomplete scriptSig will be created with OP_0 instead of signature
     */
    public static Script createInputScript(@Nullable TransactionSignature signature) {
<span class="fc bfc" id="L291" title="All 2 branches covered.">        byte[] sigBytes = signature != null ? signature.encodeToBitcoin() : new byte[]{};</span>
<span class="fc" id="L292">        return new ScriptBuilder().data(sigBytes).build();</span>
    }

    /** Creates a program that requires at least N of the given keys to sign, using OP_CHECKMULTISIG. */
    public static Script createMultiSigOutputScript(int threshold, List&lt;ECKey&gt; pubkeys) {
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">        checkArgument(threshold &gt; 0);</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">        checkArgument(threshold &lt;= pubkeys.size());</span>
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        checkArgument(pubkeys.size() &lt;= 16);  // That's the max we can represent with a single opcode.</span>
<span class="fc" id="L300">        ScriptBuilder builder = new ScriptBuilder();</span>
<span class="fc" id="L301">        builder.smallNum(threshold);</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">        for (ECKey key : pubkeys) {</span>
<span class="fc" id="L303">            builder.data(key.getPubKey());</span>
<span class="fc" id="L304">        }</span>
<span class="fc" id="L305">        builder.smallNum(pubkeys.size());</span>
<span class="fc" id="L306">        builder.op(OP_CHECKMULTISIG);</span>
<span class="fc" id="L307">        return builder.build();</span>
    }

    /** Create a program that satisfies an OP_CHECKMULTISIG program. */
    public static Script createMultiSigInputScript(List&lt;TransactionSignature&gt; signatures) {
<span class="fc" id="L312">        List&lt;byte[]&gt; sigs = new ArrayList&lt;&gt;(signatures.size());</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">        for (TransactionSignature signature : signatures) {</span>
<span class="fc" id="L314">            sigs.add(signature.encodeToBitcoin());</span>
<span class="fc" id="L315">        }</span>

<span class="fc" id="L317">        return createMultiSigInputScriptBytes(sigs, null);</span>
    }

    /** Create a program that satisfies an OP_CHECKMULTISIG program. */
    public static Script createMultiSigInputScript(TransactionSignature... signatures) {
<span class="fc" id="L322">        return createMultiSigInputScript(Arrays.asList(signatures));</span>
    }

    /** Create a program that satisfies an OP_CHECKMULTISIG program, using pre-encoded signatures. */
    public static Script createMultiSigInputScriptBytes(List&lt;byte[]&gt; signatures) {
<span class="fc" id="L327">    	return createMultiSigInputScriptBytes(signatures, null);</span>
    }

    /**
     * Create a program that satisfies a pay-to-script hashed OP_CHECKMULTISIG program.
     * If given signature list is null, incomplete scriptSig will be created with OP_0 instead of signatures
     */
    public static Script createP2SHMultiSigInputScript(@Nullable List&lt;TransactionSignature&gt; signatures,
                                                       Script multisigProgram) {
<span class="fc" id="L336">        List&lt;byte[]&gt; sigs = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">        if (signatures == null) {</span>
            // create correct number of empty signatures
<span class="fc" id="L339">            int numSigs = multisigProgram.getNumberOfSignaturesRequiredToSpend();</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">            for (int i = 0; i &lt; numSigs; i++)</span>
<span class="fc" id="L341">                sigs.add(new byte[]{});</span>
<span class="fc" id="L342">        } else {</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">            for (TransactionSignature signature : signatures) {</span>
<span class="fc" id="L344">                sigs.add(signature.encodeToBitcoin());</span>
<span class="fc" id="L345">            }</span>
        }
<span class="fc" id="L347">        return createMultiSigInputScriptBytes(sigs, multisigProgram.getProgram());</span>
    }

    /**
     * Create a program that satisfies an OP_CHECKMULTISIG program, using pre-encoded signatures. 
     * Optionally, appends the script program bytes if spending a P2SH output.
     */
    public static Script createMultiSigInputScriptBytes(List&lt;byte[]&gt; signatures, @Nullable byte[] multisigProgramBytes) {
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">        checkArgument(signatures.size() &lt;= 16);</span>
<span class="fc" id="L356">        ScriptBuilder builder = new ScriptBuilder();</span>
<span class="fc" id="L357">        builder.smallNum(0);  // Work around a bug in CHECKMULTISIG that is now a required part of the protocol.</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">        for (byte[] signature : signatures)</span>
<span class="fc" id="L359">            builder.data(signature);</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">        if (multisigProgramBytes!= null)</span>
<span class="fc" id="L361">        	builder.data(multisigProgramBytes);</span>
<span class="fc" id="L362">        return builder.build();</span>
    }

    /**
     * Returns a copy of the given scriptSig with the signature inserted in the given position.
     *
     * This function assumes that any missing sigs have OP_0 placeholders. If given scriptSig already has all the signatures
     * in place, IllegalArgumentException will be thrown.
     *
     * @param targetIndex where to insert the signature
     * @param sigsPrefixCount how many items to copy verbatim (e.g. initial OP_0 for multisig)
     * @param sigsSuffixCount how many items to copy verbatim at end (e.g. redeemScript for P2SH)
     */
    public static Script updateScriptWithSignature(Script scriptSig, byte[] signature, int targetIndex,
                                                   int sigsPrefixCount, int sigsSuffixCount) {
<span class="fc" id="L377">        ScriptBuilder builder = new ScriptBuilder();</span>
<span class="fc" id="L378">        List&lt;ScriptChunk&gt; inputChunks = scriptSig.getChunks();</span>
<span class="fc" id="L379">        int totalChunks = inputChunks.size();</span>

        // Check if we have a place to insert, otherwise just return given scriptSig unchanged.
        // We assume here that OP_0 placeholders always go after the sigs, so
        // to find if we have sigs missing, we can just check the chunk in latest sig position
<span class="fc" id="L384">        boolean hasMissingSigs = inputChunks.get(totalChunks - sigsSuffixCount - 1).equalsOpCode(OP_0);</span>
<span class="fc" id="L385">        checkArgument(hasMissingSigs, &quot;ScriptSig is already filled with signatures&quot;);</span>

        // copy the prefix
<span class="fc bfc" id="L388" title="All 2 branches covered.">        for (ScriptChunk chunk: inputChunks.subList(0, sigsPrefixCount))</span>
<span class="fc" id="L389">            builder.addChunk(chunk);</span>

        // copy the sigs
<span class="fc" id="L392">        int pos = 0;</span>
<span class="fc" id="L393">        boolean inserted = false;</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">        for (ScriptChunk chunk: inputChunks.subList(sigsPrefixCount, totalChunks - sigsSuffixCount)) {</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">            if (pos == targetIndex) {</span>
<span class="fc" id="L396">                inserted = true;</span>
<span class="fc" id="L397">                builder.data(signature);</span>
<span class="fc" id="L398">                pos++;</span>
            }
<span class="fc bfc" id="L400" title="All 2 branches covered.">            if (!chunk.equalsOpCode(OP_0)) {</span>
<span class="fc" id="L401">                builder.addChunk(chunk);</span>
<span class="fc" id="L402">                pos++;</span>
            }
<span class="fc" id="L404">        }</span>

        // add OP_0's if needed, since we skipped them in the previous loop
<span class="fc bfc" id="L407" title="All 2 branches covered.">        while (pos &lt; totalChunks - sigsPrefixCount - sigsSuffixCount) {</span>
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">            if (pos == targetIndex) {</span>
<span class="nc" id="L409">                inserted = true;</span>
<span class="nc" id="L410">                builder.data(signature);</span>
            }
            else {
<span class="fc" id="L413">                builder.addChunk(new ScriptChunk(OP_0, null));</span>
            }
<span class="fc" id="L415">            pos++;</span>
        }

        // copy the suffix
<span class="fc bfc" id="L419" title="All 2 branches covered.">        for (ScriptChunk chunk: inputChunks.subList(totalChunks - sigsSuffixCount, totalChunks))</span>
<span class="fc" id="L420">            builder.addChunk(chunk);</span>

<span class="fc" id="L422">        checkState(inserted);</span>
<span class="fc" id="L423">        return builder.build();</span>
    }

    /**
     * Creates a scriptPubKey that sends to the given script hash. Read
     * &lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki&quot;&gt;BIP 16&lt;/a&gt; to learn more about this
     * kind of script.
     */
    public static Script createP2SHOutputScript(byte[] hash) {
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">        checkArgument(hash.length == 20);</span>
<span class="fc" id="L433">        return new ScriptBuilder().op(OP_HASH160).data(hash).op(OP_EQUAL).build();</span>
    }

    /**
     * Creates a scriptPubKey for the given redeem script.
     */
    public static Script createP2SHOutputScript(Script redeemScript) {
<span class="fc" id="L440">        byte[] hash = Utils.sha256hash160(redeemScript.getProgram());</span>
<span class="fc" id="L441">        return ScriptBuilder.createP2SHOutputScript(hash);</span>
    }

    /**
     * Creates a P2SH output script with given public keys and threshold. Given public keys will be placed in
     * redeem script in the lexicographical sorting order.
     */
    public static Script createP2SHOutputScript(int threshold, List&lt;ECKey&gt; pubkeys) {
<span class="fc" id="L449">        Script redeemScript = createRedeemScript(threshold, pubkeys);</span>
<span class="fc" id="L450">        return createP2SHOutputScript(redeemScript);</span>
    }

    /**
     * Creates redeem script with given public keys and threshold. Given public keys will be placed in
     * redeem script in the lexicographical sorting order.
     */
    public static Script createRedeemScript(int threshold, List&lt;ECKey&gt; pubkeys) {
<span class="fc" id="L458">        pubkeys = new ArrayList&lt;&gt;(pubkeys);</span>
<span class="fc" id="L459">        Collections.sort(pubkeys, ECKey.PUBKEY_COMPARATOR);</span>
<span class="fc" id="L460">        return ScriptBuilder.createMultiSigOutputScript(threshold, pubkeys);</span>
    }

    /**
     * Creates a script of the form OP_RETURN [data]. This feature allows you to attach a small piece of data (like
     * a hash of something stored elsewhere) to a zero valued output which can never be spent and thus does not pollute
     * the ledger.
     */
    public static Script createOpReturnScript(byte[] data) {
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">        checkArgument(data.length &lt;= 80);</span>
<span class="fc" id="L470">        return new ScriptBuilder().op(OP_RETURN).data(data).build();</span>
    }

    public static Script createCLTVPaymentChannelOutput(BigInteger time, ECKey from, ECKey to) {
<span class="fc" id="L474">        byte[] timeBytes = Utils.reverseBytes(Utils.encodeMPI(time, false));</span>
<span class="pc bpc" id="L475" title="1 of 2 branches missed.">        if (timeBytes.length &gt; 5) {</span>
<span class="nc" id="L476">            throw new RuntimeException(&quot;Time too large to encode as 5-byte int&quot;);</span>
        }
<span class="fc" id="L478">        return new ScriptBuilder().op(OP_IF)</span>
<span class="fc" id="L479">                .data(to.getPubKey()).op(OP_CHECKSIGVERIFY)</span>
<span class="fc" id="L480">                .op(OP_ELSE)</span>
<span class="fc" id="L481">                .data(timeBytes).op(OP_CHECKLOCKTIMEVERIFY).op(OP_DROP)</span>
<span class="fc" id="L482">                .op(OP_ENDIF)</span>
<span class="fc" id="L483">                .data(from.getPubKey()).op(OP_CHECKSIG).build();</span>
    }

    public static Script createCLTVPaymentChannelRefund(TransactionSignature signature) {
<span class="fc" id="L487">        ScriptBuilder builder = new ScriptBuilder();</span>
<span class="fc" id="L488">        builder.data(signature.encodeToBitcoin());</span>
<span class="fc" id="L489">        builder.data(new byte[] { 0 }); // Use the CHECKLOCKTIMEVERIFY if branch</span>
<span class="fc" id="L490">        return builder.build();</span>
    }

    public static Script createCLTVPaymentChannelP2SHRefund(TransactionSignature signature, Script redeemScript) {
<span class="fc" id="L494">        ScriptBuilder builder = new ScriptBuilder();</span>
<span class="fc" id="L495">        builder.data(signature.encodeToBitcoin());</span>
<span class="fc" id="L496">        builder.data(new byte[] { 0 }); // Use the CHECKLOCKTIMEVERIFY if branch</span>
<span class="fc" id="L497">        builder.data(redeemScript.getProgram());</span>
<span class="fc" id="L498">        return builder.build();</span>
    }

    public static Script createCLTVPaymentChannelP2SHInput(byte[] from, byte[] to, Script redeemScript) {
<span class="fc" id="L502">        ScriptBuilder builder = new ScriptBuilder();</span>
<span class="fc" id="L503">        builder.data(from);</span>
<span class="fc" id="L504">        builder.data(to);</span>
<span class="fc" id="L505">        builder.smallNum(1); // Use the CHECKLOCKTIMEVERIFY if branch</span>
<span class="fc" id="L506">        builder.data(redeemScript.getProgram());</span>
<span class="fc" id="L507">        return builder.build();</span>
    }

    public static Script createCLTVPaymentChannelInput(TransactionSignature from, TransactionSignature to) {
<span class="fc" id="L511">        return createCLTVPaymentChannelInput(from.encodeToBitcoin(), to.encodeToBitcoin());</span>
    }

    public static Script createCLTVPaymentChannelInput(byte[] from, byte[] to) {
<span class="fc" id="L515">        ScriptBuilder builder = new ScriptBuilder();</span>
<span class="fc" id="L516">        builder.data(from);</span>
<span class="fc" id="L517">        builder.data(to);</span>
<span class="fc" id="L518">        builder.smallNum(1); // Use the CHECKLOCKTIMEVERIFY if branch</span>
<span class="fc" id="L519">        return builder.build();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>