<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Script.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bitcoinj</a> &gt; <a href="index.source.html" class="el_package">org.bitcoinj.script</a> &gt; <span class="el_source">Script.java</span></div><h1>Script.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2011 Google Inc.
 * Copyright 2012 Matt Corallo.
 * Copyright 2014 Andreas Schildbach
 * Copyright 2017 Nicola Atzei
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bitcoinj.script;

import org.bitcoinj.core.*;
import org.bitcoinj.crypto.TransactionSignature;
import com.google.common.collect.Lists;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.spongycastle.crypto.digests.RIPEMD160Digest;

import javax.annotation.Nullable;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;

import static org.bitcoinj.script.ScriptOpCodes.*;
import static com.google.common.base.Preconditions.*;

// TODO: Redesign this entire API to be more type safe and organised.

/**
 * &lt;p&gt;Programs embedded inside transactions that control redemption of payments.&lt;/p&gt;
 *
 * &lt;p&gt;Bitcoin transactions don't specify what they do directly. Instead &lt;a href=&quot;https://en.bitcoin.it/wiki/Script&quot;&gt;a
 * small binary stack language&lt;/a&gt; is used to define programs that when evaluated return whether the transaction
 * &quot;accepts&quot; or rejects the other transactions connected to it.&lt;/p&gt;
 *
 * &lt;p&gt;In SPV mode, scripts are not run, because that would require all transactions to be available and lightweight
 * clients don't have that data. In full mode, this class is used to run the interpreted language. It also has
 * static methods for building scripts.&lt;/p&gt;
 */
public class Script {

    /** Enumeration to encapsulate the type of this script. */
<span class="pc" id="L58">    public enum ScriptType {</span>
        // Do NOT change the ordering of the following definitions because their ordinals are stored in databases.
<span class="fc" id="L60">        NO_TYPE,</span>
<span class="fc" id="L61">        P2PKH,</span>
<span class="fc" id="L62">        PUB_KEY,</span>
<span class="fc" id="L63">        P2SH</span>
    }

    /** Flags to pass to {@link Script#correctlySpends(Transaction, long, Script, Set)}.
     * Note currently only P2SH, DERSIG and NULLDUMMY are actually supported.
     */
<span class="fc" id="L69">    public enum VerifyFlag {</span>
<span class="fc" id="L70">        P2SH, // Enable BIP16-style subscript evaluation.</span>
<span class="fc" id="L71">        STRICTENC, // Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.</span>
<span class="fc" id="L72">        DERSIG, // Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP66 rule 1)</span>
<span class="fc" id="L73">        LOW_S, // Passing a non-strict-DER signature or one with S &gt; order/2 to a checksig operation causes script failure</span>
<span class="fc" id="L74">        NULLDUMMY, // Verify dummy stack item consumed by CHECKMULTISIG is of zero-length.</span>
<span class="fc" id="L75">        SIGPUSHONLY, // Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).</span>
<span class="fc" id="L76">        MINIMALDATA, // Require minimal encodings for all push operations</span>
<span class="fc" id="L77">        DISCOURAGE_UPGRADABLE_NOPS, // Discourage use of NOPs reserved for upgrades (NOP1-10)</span>
<span class="fc" id="L78">        CLEANSTACK, // Require that only a single stack element remains after evaluation.</span>
<span class="fc" id="L79">        CHECKLOCKTIMEVERIFY, // Enable CHECKLOCKTIMEVERIFY operation</span>
<span class="fc" id="L80">        CHECKSEQUENCEVERIFY // Enable CHECKSEQUENCEVERIFY operation</span>
    }
<span class="fc" id="L82">    public static final EnumSet&lt;VerifyFlag&gt; ALL_VERIFY_FLAGS = EnumSet.allOf(VerifyFlag.class);</span>

<span class="fc" id="L84">    private static final Logger log = LoggerFactory.getLogger(Script.class);</span>
    public static final long MAX_SCRIPT_ELEMENT_SIZE = 520;  // bytes
    private static final int MAX_OPS_PER_SCRIPT = 201;
    private static final int MAX_STACK_SIZE = 1000;
    private static final int MAX_PUBKEYS_PER_MULTISIG = 20;
    private static final int MAX_SCRIPT_SIZE = 10000;
    public static final int SIG_SIZE = 75;
    /** Max number of sigops allowed in a standard p2sh redeem script */
    public static final int MAX_P2SH_SIGOPS = 15;

    // The program is a set of chunks where each element is either [opcode] or [data, data, data ...]
    protected List&lt;ScriptChunk&gt; chunks;
    // Unfortunately, scripts are not ever re-serialized or canonicalized when used in signature hashing. Thus we
    // must preserve the exact bytes that we read off the wire, along with the parsed form.
    protected byte[] program;

    // Creation time of the associated keys in seconds since the epoch.
    private long creationTimeSeconds;

    /** Creates an empty script that serializes to nothing. */
<span class="fc" id="L104">    private Script() {</span>
<span class="fc" id="L105">        chunks = Lists.newArrayList();</span>
<span class="fc" id="L106">    }</span>

    // Used from ScriptBuilder.
<span class="fc" id="L109">    Script(List&lt;ScriptChunk&gt; chunks) {</span>
<span class="fc" id="L110">        this.chunks = Collections.unmodifiableList(new ArrayList&lt;&gt;(chunks));</span>
<span class="fc" id="L111">        creationTimeSeconds = Utils.currentTimeSeconds();</span>
<span class="fc" id="L112">    }</span>

    /**
     * Construct a Script that copies and wraps the programBytes array. The array is parsed and checked for syntactic
     * validity.
     * @param programBytes Array of program bytes from a transaction.
     */
<span class="fc" id="L119">    public Script(byte[] programBytes) throws ScriptException {</span>
<span class="fc" id="L120">        program = programBytes;</span>
<span class="fc" id="L121">        parse(programBytes);</span>
<span class="fc" id="L122">        creationTimeSeconds = 0;</span>
<span class="fc" id="L123">    }</span>

<span class="fc" id="L125">    public Script(byte[] programBytes, long creationTimeSeconds) throws ScriptException {</span>
<span class="fc" id="L126">        program = programBytes;</span>
<span class="fc" id="L127">        parse(programBytes);</span>
<span class="fc" id="L128">        this.creationTimeSeconds = creationTimeSeconds;</span>
<span class="fc" id="L129">    }</span>

    public long getCreationTimeSeconds() {
<span class="fc" id="L132">        return creationTimeSeconds;</span>
    }

    public void setCreationTimeSeconds(long creationTimeSeconds) {
<span class="fc" id="L136">        this.creationTimeSeconds = creationTimeSeconds;</span>
<span class="fc" id="L137">    }</span>

    /**
     * Returns the program opcodes as a string, for example &quot;[1234] DUP HASH160&quot;
     */
    @Override
    public String toString() {
<span class="fc" id="L144">        return Utils.SPACE_JOINER.join(chunks);</span>
    }

    /** Returns the serialized program as a newly created byte array. */
    public byte[] getProgram() {
        try {
            // Don't round-trip as Bitcoin Core doesn't and it would introduce a mismatch.
<span class="fc bfc" id="L151" title="All 2 branches covered.">            if (program != null)</span>
<span class="fc" id="L152">                return Arrays.copyOf(program, program.length);</span>
<span class="fc" id="L153">            ByteArrayOutputStream bos = new ByteArrayOutputStream();</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">            for (ScriptChunk chunk : chunks) {</span>
<span class="fc" id="L155">                chunk.write(bos);</span>
<span class="fc" id="L156">            }</span>
<span class="fc" id="L157">            program = bos.toByteArray();</span>
<span class="fc" id="L158">            return program;</span>
<span class="nc" id="L159">        } catch (IOException e) {</span>
<span class="nc" id="L160">            throw new RuntimeException(e);  // Cannot happen.</span>
        }
    }

    /** Returns an immutable list of the scripts parsed form. Each chunk is either an opcode or data element. */
    public List&lt;ScriptChunk&gt; getChunks() {
<span class="fc" id="L166">        return Collections.unmodifiableList(chunks);</span>
    }

<span class="fc" id="L169">    private static final ScriptChunk[] STANDARD_TRANSACTION_SCRIPT_CHUNKS = {</span>
        new ScriptChunk(ScriptOpCodes.OP_DUP, null, 0),
        new ScriptChunk(ScriptOpCodes.OP_HASH160, null, 1),
        new ScriptChunk(ScriptOpCodes.OP_EQUALVERIFY, null, 23),
        new ScriptChunk(ScriptOpCodes.OP_CHECKSIG, null, 24),
    };

    /**
     * &lt;p&gt;To run a script, first we parse it which breaks it up into chunks representing pushes of data or logical
     * opcodes. Then we can run the parsed chunks.&lt;/p&gt;
     *
     * &lt;p&gt;The reason for this split, instead of just interpreting directly, is to make it easier
     * to reach into a programs structure and pull out bits of data without having to run it.
     * This is necessary to render the to/from addresses of transactions in a user interface.
     * Bitcoin Core does something similar.&lt;/p&gt;
     */
    private void parse(byte[] program) throws ScriptException {
<span class="fc" id="L186">        chunks = new ArrayList&lt;&gt;(5);   // Common size.</span>
<span class="fc" id="L187">        ByteArrayInputStream bis = new ByteArrayInputStream(program);</span>
<span class="fc" id="L188">        int initialSize = bis.available();</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">        while (bis.available() &gt; 0) {</span>
<span class="fc" id="L190">            int startLocationInProgram = initialSize - bis.available();</span>
<span class="fc" id="L191">            int opcode = bis.read();</span>

<span class="fc" id="L193">            long dataToRead = -1;</span>
<span class="pc bpc" id="L194" title="1 of 4 branches missed.">            if (opcode &gt;= 0 &amp;&amp; opcode &lt; OP_PUSHDATA1) {</span>
                // Read some bytes of data, where how many is the opcode value itself.
<span class="fc" id="L196">                dataToRead = opcode;</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">            } else if (opcode == OP_PUSHDATA1) {</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">                if (bis.available() &lt; 1) throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, &quot;Unexpected end of script&quot;);</span>
<span class="fc" id="L199">                dataToRead = bis.read();</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">            } else if (opcode == OP_PUSHDATA2) {</span>
                // Read a short, then read that many bytes of data.
<span class="fc bfc" id="L202" title="All 2 branches covered.">                if (bis.available() &lt; 2) throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, &quot;Unexpected end of script&quot;);</span>
<span class="fc" id="L203">                dataToRead = bis.read() | (bis.read() &lt;&lt; 8);</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">            } else if (opcode == OP_PUSHDATA4) {</span>
                // Read a uint32, then read that many bytes of data.
                // Though this is allowed, because its value cannot be &gt; 520, it should never actually be used
<span class="fc bfc" id="L207" title="All 2 branches covered.">                if (bis.available() &lt; 4) throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, &quot;Unexpected end of script&quot;);</span>
<span class="fc" id="L208">                dataToRead = ((long)bis.read()) | (((long)bis.read()) &lt;&lt; 8) | (((long)bis.read()) &lt;&lt; 16) | (((long)bis.read()) &lt;&lt; 24);</span>
            }

            ScriptChunk chunk;
<span class="fc bfc" id="L212" title="All 2 branches covered.">            if (dataToRead == -1) {</span>
<span class="fc" id="L213">                chunk = new ScriptChunk(opcode, null, startLocationInProgram);</span>
            } else {
<span class="fc bfc" id="L215" title="All 2 branches covered.">                if (dataToRead &gt; bis.available())</span>
<span class="fc" id="L216">                    throw new ScriptException(ScriptError.SCRIPT_ERR_BAD_OPCODE, &quot;Push of data element that is larger than remaining data&quot;);</span>
<span class="fc" id="L217">                byte[] data = new byte[(int)dataToRead];</span>
<span class="pc bpc" id="L218" title="1 of 4 branches missed.">                checkState(dataToRead == 0 || bis.read(data, 0, (int)dataToRead) == dataToRead);</span>
<span class="fc" id="L219">                chunk = new ScriptChunk(opcode, data, startLocationInProgram);</span>
            }
            // Save some memory by eliminating redundant copies of the same chunk objects.
<span class="fc bfc" id="L222" title="All 2 branches covered.">            for (ScriptChunk c : STANDARD_TRANSACTION_SCRIPT_CHUNKS) {</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">                if (c.equals(chunk)) chunk = c;</span>
            }
<span class="fc" id="L225">            chunks.add(chunk);</span>
<span class="fc" id="L226">        }</span>
<span class="fc" id="L227">    }</span>

    /**
     * Returns true if this script is of the form &lt;pubkey&gt; OP_CHECKSIG. This form was originally intended for transactions
     * where the peers talked to each other directly via TCP/IP, but has fallen out of favor with time due to that mode
     * of operation being susceptible to man-in-the-middle attacks. It is still used in coinbase outputs and can be
     * useful more exotic types of transaction, but today most payments are to addresses.
     */
    public boolean isSentToRawPubKey() {
<span class="fc bfc" id="L236" title="All 4 branches covered.">        return chunks.size() == 2 &amp;&amp; chunks.get(1).equalsOpCode(OP_CHECKSIG) &amp;&amp;</span>
<span class="pc bpc" id="L237" title="2 of 4 branches missed.">               !chunks.get(0).isOpCode() &amp;&amp; chunks.get(0).data.length &gt; 1;</span>
    }

    /**
     * Returns true if this script is of the form DUP HASH160 &lt;pubkey hash&gt; EQUALVERIFY CHECKSIG, ie, payment to an
     * address like 1VayNert3x1KzbpzMGt2qdqrAThiRovi8. This form was originally intended for the case where you wish
     * to send somebody money with a written code because their node is offline, but over time has become the standard
     * way to make payments due to the short and recognizable base58 form addresses come in.
     */
    public boolean isSentToAddress() {
<span class="fc bfc" id="L247" title="All 2 branches covered.">        return chunks.size() == 5 &amp;&amp;</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">               chunks.get(0).equalsOpCode(OP_DUP) &amp;&amp;</span>
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">               chunks.get(1).equalsOpCode(OP_HASH160) &amp;&amp;</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">               chunks.get(2).data.length == Address.LENGTH &amp;&amp;</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">               chunks.get(3).equalsOpCode(OP_EQUALVERIFY) &amp;&amp;</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">               chunks.get(4).equalsOpCode(OP_CHECKSIG);</span>
    }

    /**
     * An alias for isPayToScriptHash.
     */
    @Deprecated
    public boolean isSentToP2SH() {
<span class="nc" id="L260">        return isPayToScriptHash();</span>
    }

    /**
     * &lt;p&gt;If a program matches the standard template DUP HASH160 &amp;lt;pubkey hash&amp;gt; EQUALVERIFY CHECKSIG
     * then this function retrieves the third element.
     * In this case, this is useful for fetching the destination address of a transaction.&lt;/p&gt;
     * 
     * &lt;p&gt;If a program matches the standard template HASH160 &amp;lt;script hash&amp;gt; EQUAL
     * then this function retrieves the second element.
     * In this case, this is useful for fetching the hash of the redeem script of a transaction.&lt;/p&gt;
     * 
     * &lt;p&gt;Otherwise it throws a ScriptException.&lt;/p&gt;
     *
     */
    public byte[] getPubKeyHash() throws ScriptException {
<span class="fc bfc" id="L276" title="All 2 branches covered.">        if (isSentToAddress())</span>
<span class="fc" id="L277">            return chunks.get(2).data;</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">        else if (isPayToScriptHash())</span>
<span class="fc" id="L279">            return chunks.get(1).data;</span>
        else
<span class="fc" id="L281">            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, &quot;Script not in the standard scriptPubKey form&quot;);</span>
    }

    /**
     * Returns the public key in this script. If a script contains two constants and nothing else, it is assumed to
     * be a scriptSig (input) for a pay-to-address output and the second constant is returned (the first is the
     * signature). If a script contains a constant and an OP_CHECKSIG opcode, the constant is returned as it is
     * assumed to be a direct pay-to-key scriptPubKey (output) and the first constant is the public key.
     *
     * @throws ScriptException if the script is none of the named forms.
     */
    public byte[] getPubKey() throws ScriptException {
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">        if (chunks.size() != 2) {</span>
<span class="nc" id="L294">            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, &quot;Script not of right size, expecting 2 but got &quot; + chunks.size());</span>
        }
<span class="fc" id="L296">        final ScriptChunk chunk0 = chunks.get(0);</span>
<span class="fc" id="L297">        final byte[] chunk0data = chunk0.data;</span>
<span class="fc" id="L298">        final ScriptChunk chunk1 = chunks.get(1);</span>
<span class="fc" id="L299">        final byte[] chunk1data = chunk1.data;</span>
<span class="pc bpc" id="L300" title="3 of 8 branches missed.">        if (chunk0data != null &amp;&amp; chunk0data.length &gt; 2 &amp;&amp; chunk1data != null &amp;&amp; chunk1data.length &gt; 2) {</span>
            // If we have two large constants assume the input to a pay-to-address output.
<span class="fc" id="L302">            return chunk1data;</span>
<span class="pc bpc" id="L303" title="3 of 6 branches missed.">        } else if (chunk1.equalsOpCode(OP_CHECKSIG) &amp;&amp; chunk0data != null &amp;&amp; chunk0data.length &gt; 2) {</span>
            // A large constant followed by an OP_CHECKSIG is the key.
<span class="fc" id="L305">            return chunk0data;</span>
        } else {
<span class="nc" id="L307">            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, &quot;Script did not match expected form: &quot; + this);</span>
        }
    }

    /**
     * Retrieves the sender public key from a LOCKTIMEVERIFY transaction
     * @return the sender public key
     * @throws ScriptException
     */
    public byte[] getCLTVPaymentChannelSenderPubKey() throws ScriptException {
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (!isSentToCLTVPaymentChannel()) {</span>
<span class="nc" id="L318">            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, &quot;Script not a standard CHECKLOCKTIMVERIFY transaction: &quot; + this);</span>
        }
<span class="nc" id="L320">        return chunks.get(8).data;</span>
    }

    /**
     * Retrieves the recipient public key from a LOCKTIMEVERIFY transaction
     * @return the recipient public key
     * @throws ScriptException
     */
    public byte[] getCLTVPaymentChannelRecipientPubKey() throws ScriptException {
<span class="nc bnc" id="L329" title="All 2 branches missed.">        if (!isSentToCLTVPaymentChannel()) {</span>
<span class="nc" id="L330">            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, &quot;Script not a standard CHECKLOCKTIMVERIFY transaction: &quot; + this);</span>
        }
<span class="nc" id="L332">        return chunks.get(1).data;</span>
    }

    public BigInteger getCLTVPaymentChannelExpiry() {
<span class="nc bnc" id="L336" title="All 2 branches missed.">        if (!isSentToCLTVPaymentChannel()) {</span>
<span class="nc" id="L337">            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, &quot;Script not a standard CHECKLOCKTIMEVERIFY transaction: &quot; + this);</span>
        }
<span class="nc" id="L339">        return castToBigInteger(chunks.get(4).data, 5, false);</span>
    }

    /**
     * For 2-element [input] scripts assumes that the paid-to-address can be derived from the public key.
     * The concept of a &quot;from address&quot; isn't well defined in Bitcoin and you should not assume the sender of a
     * transaction can actually receive coins on it. This method may be removed in future.
     */
    @Deprecated
    public Address getFromAddress(NetworkParameters params) throws ScriptException {
<span class="fc" id="L349">        return new Address(params, Utils.sha256hash160(getPubKey()));</span>
    }

    /**
     * Gets the destination address from this script, if it's in the required form (see getPubKey).
     */
    public Address getToAddress(NetworkParameters params) throws ScriptException {
<span class="fc" id="L356">        return getToAddress(params, false);</span>
    }

    /**
     * Gets the destination address from this script, if it's in the required form (see getPubKey).
     * 
     * @param forcePayToPubKey
     *            If true, allow payToPubKey to be casted to the corresponding address. This is useful if you prefer
     *            showing addresses rather than pubkeys.
     */
    public Address getToAddress(NetworkParameters params, boolean forcePayToPubKey) throws ScriptException {
<span class="fc bfc" id="L367" title="All 2 branches covered.">        if (isSentToAddress())</span>
<span class="fc" id="L368">            return new Address(params, getPubKeyHash());</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">        else if (isPayToScriptHash())</span>
<span class="fc" id="L370">            return Address.fromP2SHScript(params, this);</span>
<span class="fc bfc" id="L371" title="All 4 branches covered.">        else if (forcePayToPubKey &amp;&amp; isSentToRawPubKey())</span>
<span class="fc" id="L372">            return ECKey.fromPublicOnly(getPubKey()).toAddress(params);</span>
        else
<span class="fc" id="L374">            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, &quot;Cannot cast this script to a pay-to-address type&quot;);</span>
    }

    ////////////////////// Interface for writing scripts from scratch ////////////////////////////////

    /**
     * Writes out the given byte buffer to the output stream with the correct opcode prefix
     * To write an integer call writeBytes(out, Utils.reverseBytes(Utils.encodeMPI(val, false)));
     */
    public static void writeBytes(OutputStream os, byte[] buf) throws IOException {
<span class="fc bfc" id="L384" title="All 2 branches covered.">        if (buf.length &lt; OP_PUSHDATA1) {</span>
<span class="fc" id="L385">            os.write(buf.length);</span>
<span class="fc" id="L386">            os.write(buf);</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">        } else if (buf.length &lt; 256) {</span>
<span class="nc" id="L388">            os.write(OP_PUSHDATA1);</span>
<span class="nc" id="L389">            os.write(buf.length);</span>
<span class="nc" id="L390">            os.write(buf);</span>
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">        } else if (buf.length &lt; 65536) {</span>
<span class="fc" id="L392">            os.write(OP_PUSHDATA2);</span>
<span class="fc" id="L393">            os.write(0xFF &amp; (buf.length));</span>
<span class="fc" id="L394">            os.write(0xFF &amp; (buf.length &gt;&gt; 8));</span>
<span class="fc" id="L395">            os.write(buf);</span>
        } else {
<span class="nc" id="L397">            throw new RuntimeException(&quot;Unimplemented&quot;);</span>
        }
<span class="fc" id="L399">    }</span>

    /** Creates a program that requires at least N of the given keys to sign, using OP_CHECKMULTISIG. */
    public static byte[] createMultiSigOutputScript(int threshold, List&lt;ECKey&gt; pubkeys) {
<span class="fc bfc" id="L403" title="All 2 branches covered.">        checkArgument(threshold &gt; 0);</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">        checkArgument(threshold &lt;= pubkeys.size());</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">        checkArgument(pubkeys.size() &lt;= 16);  // That's the max we can represent with a single opcode.</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">        if (pubkeys.size() &gt; 3) {</span>
<span class="nc" id="L407">            log.warn(&quot;Creating a multi-signature output that is non-standard: {} pubkeys, should be &lt;= 3&quot;, pubkeys.size());</span>
        }
        try {
<span class="nc" id="L410">            ByteArrayOutputStream bits = new ByteArrayOutputStream();</span>
<span class="nc" id="L411">            bits.write(encodeToOpN(threshold));</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">            for (ECKey key : pubkeys) {</span>
<span class="nc" id="L413">                writeBytes(bits, key.getPubKey());</span>
<span class="nc" id="L414">            }</span>
<span class="nc" id="L415">            bits.write(encodeToOpN(pubkeys.size()));</span>
<span class="nc" id="L416">            bits.write(OP_CHECKMULTISIG);</span>
<span class="nc" id="L417">            return bits.toByteArray();</span>
<span class="nc" id="L418">        } catch (IOException e) {</span>
<span class="nc" id="L419">            throw new RuntimeException(e);  // Cannot happen.</span>
        }
    }

    public static byte[] createInputScript(byte[] signature, byte[] pubkey) {
        try {
            // TODO: Do this by creating a Script *first* then having the script reassemble itself into bytes.
<span class="fc" id="L426">            ByteArrayOutputStream bits = new UnsafeByteArrayOutputStream(signature.length + pubkey.length + 2);</span>
<span class="fc" id="L427">            writeBytes(bits, signature);</span>
<span class="fc" id="L428">            writeBytes(bits, pubkey);</span>
<span class="fc" id="L429">            return bits.toByteArray();</span>
<span class="nc" id="L430">        } catch (IOException e) {</span>
<span class="nc" id="L431">            throw new RuntimeException(e);</span>
        }
    }

    public static byte[] createInputScript(byte[] signature) {
        try {
            // TODO: Do this by creating a Script *first* then having the script reassemble itself into bytes.
<span class="fc" id="L438">            ByteArrayOutputStream bits = new UnsafeByteArrayOutputStream(signature.length + 2);</span>
<span class="fc" id="L439">            writeBytes(bits, signature);</span>
<span class="fc" id="L440">            return bits.toByteArray();</span>
<span class="nc" id="L441">        } catch (IOException e) {</span>
<span class="nc" id="L442">            throw new RuntimeException(e);</span>
        }
    }

    /**
     * Creates an incomplete scriptSig that, once filled with signatures, can redeem output containing this scriptPubKey.
     * Instead of the signatures resulting script has OP_0.
     * Having incomplete input script allows to pass around partially signed tx.
     * It is expected that this program later on will be updated with proper signatures.
     */
    public Script createEmptyInputScript(@Nullable ECKey key, @Nullable Script redeemScript) {
<span class="fc bfc" id="L453" title="All 2 branches covered.">        if (isSentToAddress()) {</span>
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">            checkArgument(key != null, &quot;Key required to create pay-to-address input script&quot;);</span>
<span class="fc" id="L455">            return ScriptBuilder.createInputScript(null, key);</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">        } else if (isSentToRawPubKey()) {</span>
<span class="fc" id="L457">            return ScriptBuilder.createInputScript(null);</span>
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">        } else if (isPayToScriptHash()) {</span>
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">            checkArgument(redeemScript != null, &quot;Redeem script required to create P2SH input script&quot;);</span>
<span class="fc" id="L460">            return ScriptBuilder.createP2SHMultiSigInputScript(null, redeemScript);</span>
        } else {
<span class="nc" id="L462">            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, &quot;Do not understand script type: &quot; + this);</span>
        }
    }

    /**
     * Returns a copy of the given scriptSig with the signature inserted in the given position.
     */
    public Script getScriptSigWithSignature(Script scriptSig, byte[] sigBytes, int index) {
<span class="fc" id="L470">        int sigsPrefixCount = 0;</span>
<span class="fc" id="L471">        int sigsSuffixCount = 0;</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">        if (isPayToScriptHash()) {</span>
<span class="fc" id="L473">            sigsPrefixCount = 1; // OP_0 &lt;sig&gt;* &lt;redeemScript&gt;</span>
<span class="fc" id="L474">            sigsSuffixCount = 1;</span>
<span class="pc bpc" id="L475" title="1 of 2 branches missed.">        } else if (isSentToMultiSig()) {</span>
<span class="nc" id="L476">            sigsPrefixCount = 1; // OP_0 &lt;sig&gt;*</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">        } else if (isSentToAddress()) {</span>
<span class="fc" id="L478">            sigsSuffixCount = 1; // &lt;sig&gt; &lt;pubkey&gt;</span>
        }
<span class="fc" id="L480">        return ScriptBuilder.updateScriptWithSignature(scriptSig, sigBytes, index, sigsPrefixCount, sigsSuffixCount);</span>
    }


    /**
     * Returns the index where a signature by the key should be inserted.  Only applicable to
     * a P2SH scriptSig.
     */
    public int getSigInsertionIndex(Sha256Hash hash, ECKey signingKey) {
        // Iterate over existing signatures, skipping the initial OP_0, the final redeem script
        // and any placeholder OP_0 sigs.
<span class="fc" id="L491">        List&lt;ScriptChunk&gt; existingChunks = chunks.subList(1, chunks.size() - 1);</span>
<span class="fc" id="L492">        ScriptChunk redeemScriptChunk = chunks.get(chunks.size() - 1);</span>
<span class="fc" id="L493">        checkNotNull(redeemScriptChunk.data);</span>
<span class="fc" id="L494">        Script redeemScript = new Script(redeemScriptChunk.data);</span>

<span class="fc" id="L496">        int sigCount = 0;</span>
<span class="fc" id="L497">        int myIndex = redeemScript.findKeyInRedeem(signingKey);</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">        for (ScriptChunk chunk : existingChunks) {</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">            if (chunk.opcode == OP_0) {</span>
                // OP_0, skip
            } else {
<span class="fc" id="L502">                checkNotNull(chunk.data);</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">                if (myIndex &lt; redeemScript.findSigInRedeem(chunk.data, hash))</span>
<span class="fc" id="L504">                    return sigCount;</span>
<span class="fc" id="L505">                sigCount++;</span>
            }
<span class="fc" id="L507">        }</span>
<span class="fc" id="L508">        return sigCount;</span>
    }

    private int findKeyInRedeem(ECKey key) {
<span class="fc" id="L512">        checkArgument(chunks.get(0).isOpCode()); // P2SH scriptSig</span>
<span class="fc" id="L513">        int numKeys = Script.decodeFromOpN(chunks.get(chunks.size() - 2).opcode);</span>
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">        for (int i = 0 ; i &lt; numKeys ; i++) {</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">            if (Arrays.equals(chunks.get(1 + i).data, key.getPubKey())) {</span>
<span class="fc" id="L516">                return i;</span>
            }
        }

<span class="nc" id="L520">        throw new IllegalStateException(&quot;Could not find matching key &quot; + key.toString() + &quot; in script &quot; + this);</span>
    }

    /**
     * Returns a list of the keys required by this script, assuming a multi-sig script.
     *
     * @throws ScriptException if the script type is not understood or is pay to address or is P2SH (run this method on the &quot;Redeem script&quot; instead).
     */
    public List&lt;ECKey&gt; getPubKeys() {
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">        if (!isSentToMultiSig())</span>
<span class="nc" id="L530">            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, &quot;Only usable for multisig scripts.&quot;);</span>

<span class="fc" id="L532">        ArrayList&lt;ECKey&gt; result = Lists.newArrayList();</span>
<span class="fc" id="L533">        int numKeys = Script.decodeFromOpN(chunks.get(chunks.size() - 2).opcode);</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">        for (int i = 0 ; i &lt; numKeys ; i++)</span>
<span class="fc" id="L535">            result.add(ECKey.fromPublicOnly(chunks.get(1 + i).data));</span>
<span class="fc" id="L536">        return result;</span>
    }

    private int findSigInRedeem(byte[] signatureBytes, Sha256Hash hash) {
<span class="fc" id="L540">        checkArgument(chunks.get(0).isOpCode()); // P2SH scriptSig</span>
<span class="fc" id="L541">        int numKeys = Script.decodeFromOpN(chunks.get(chunks.size() - 2).opcode);</span>
<span class="fc" id="L542">        TransactionSignature signature = TransactionSignature.decodeFromBitcoin(signatureBytes, true);</span>
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">        for (int i = 0 ; i &lt; numKeys ; i++) {</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">            if (ECKey.fromPublicOnly(chunks.get(i + 1).data).verify(hash, signature)) {</span>
<span class="fc" id="L545">                return i;</span>
            }
        }

<span class="nc" id="L549">        throw new IllegalStateException(&quot;Could not find matching key for signature on &quot; + hash.toString() + &quot; sig &quot; + Utils.HEX.encode(signatureBytes));</span>
    }



    ////////////////////// Interface used during verification of transactions/blocks ////////////////////////////////

    private static int getSigOpCount(List&lt;ScriptChunk&gt; chunks, boolean accurate) throws ScriptException {
<span class="fc" id="L557">        int sigOps = 0;</span>
<span class="fc" id="L558">        int lastOpCode = OP_INVALIDOPCODE;</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">        for (ScriptChunk chunk : chunks) {</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">            if (chunk.isOpCode()) {</span>
<span class="fc bfc" id="L561" title="All 3 branches covered.">                switch (chunk.opcode) {</span>
                case OP_CHECKSIG:
                case OP_CHECKSIGVERIFY:
<span class="fc" id="L564">                    sigOps++;</span>
<span class="fc" id="L565">                    break;</span>
                case OP_CHECKMULTISIG:
                case OP_CHECKMULTISIGVERIFY:
<span class="pc bpc" id="L568" title="5 of 6 branches missed.">                    if (accurate &amp;&amp; lastOpCode &gt;= OP_1 &amp;&amp; lastOpCode &lt;= OP_16)</span>
<span class="nc" id="L569">                        sigOps += decodeFromOpN(lastOpCode);</span>
                    else
<span class="fc" id="L571">                        sigOps += 20;</span>
<span class="fc" id="L572">                    break;</span>
                default:
                    break;
                }
<span class="fc" id="L576">                lastOpCode = chunk.opcode;</span>
            }
<span class="fc" id="L578">        }</span>
<span class="fc" id="L579">        return sigOps;</span>
    }

    static int decodeFromOpN(int opcode) {
<span class="pc bpc" id="L583" title="3 of 8 branches missed.">        checkArgument((opcode == OP_0 || opcode == OP_1NEGATE) || (opcode &gt;= OP_1 &amp;&amp; opcode &lt;= OP_16), &quot;decodeFromOpN called on non OP_N opcode&quot;);</span>
<span class="fc bfc" id="L584" title="All 2 branches covered.">        if (opcode == OP_0)</span>
<span class="fc" id="L585">            return 0;</span>
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">        else if (opcode == OP_1NEGATE)</span>
<span class="nc" id="L587">            return -1;</span>
        else
<span class="fc" id="L589">            return opcode + 1 - OP_1;</span>
    }

    static int encodeToOpN(int value) {
<span class="pc bpc" id="L593" title="2 of 4 branches missed.">        checkArgument(value &gt;= -1 &amp;&amp; value &lt;= 16, &quot;encodeToOpN called for &quot; + value + &quot; which we cannot encode in an opcode.&quot;);</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">        if (value == 0)</span>
<span class="fc" id="L595">            return OP_0;</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">        else if (value == -1)</span>
<span class="fc" id="L597">            return OP_1NEGATE;</span>
        else
<span class="fc" id="L599">            return value - 1 + OP_1;</span>
    }

    /**
     * Gets the count of regular SigOps in the script program (counting multisig ops as 20)
     */
    public static int getSigOpCount(byte[] program) throws ScriptException {
<span class="fc" id="L606">        Script script = new Script();</span>
        try {
<span class="fc" id="L608">            script.parse(program);</span>
<span class="fc" id="L609">        } catch (ScriptException e) {</span>
            // Ignore errors and count up to the parse-able length
<span class="fc" id="L611">        }</span>
<span class="fc" id="L612">        return getSigOpCount(script.chunks, false);</span>
    }
    
    /**
     * Gets the count of P2SH Sig Ops in the Script scriptSig
     */
    public static long getP2SHSigOpCount(byte[] scriptSig) throws ScriptException {
<span class="fc" id="L619">        Script script = new Script();</span>
        try {
<span class="fc" id="L621">            script.parse(scriptSig);</span>
<span class="nc" id="L622">        } catch (ScriptException e) {</span>
            // Ignore errors and count up to the parse-able length
<span class="fc" id="L624">        }</span>
<span class="pc bpc" id="L625" title="1 of 2 branches missed.">        for (int i = script.chunks.size() - 1; i &gt;= 0; i--)</span>
<span class="pc bpc" id="L626" title="1 of 2 branches missed.">            if (!script.chunks.get(i).isOpCode()) {</span>
<span class="fc" id="L627">                Script subScript =  new Script();</span>
<span class="fc" id="L628">                subScript.parse(script.chunks.get(i).data);</span>
<span class="fc" id="L629">                return getSigOpCount(subScript.chunks, true);</span>
            }
<span class="nc" id="L631">        return 0;</span>
    }

    /**
     * Returns number of signatures required to satisfy this script.
     */
    public int getNumberOfSignaturesRequiredToSpend() {
<span class="pc bpc" id="L638" title="1 of 2 branches missed.">        if (isSentToMultiSig()) {</span>
            // for N of M CHECKMULTISIG script we will need N signatures to spend
<span class="fc" id="L640">            ScriptChunk nChunk = chunks.get(0);</span>
<span class="fc" id="L641">            return Script.decodeFromOpN(nChunk.opcode);</span>
<span class="nc bnc" id="L642" title="All 4 branches missed.">        } else if (isSentToAddress() || isSentToRawPubKey()) {</span>
            // pay-to-address and pay-to-pubkey require single sig
<span class="nc" id="L644">            return 1;</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">        } else if (isPayToScriptHash()) {</span>
<span class="nc" id="L646">            throw new IllegalStateException(&quot;For P2SH number of signatures depends on redeem script&quot;);</span>
        } else {
<span class="nc" id="L648">            throw new IllegalStateException(&quot;Unsupported script type&quot;);</span>
        }
    }

    /**
     * Returns number of bytes required to spend this script. It accepts optional ECKey and redeemScript that may
     * be required for certain types of script to estimate target size.
     */
    public int getNumberOfBytesRequiredToSpend(@Nullable ECKey pubKey, @Nullable Script redeemScript) {
<span class="fc bfc" id="L657" title="All 2 branches covered.">        if (isPayToScriptHash()) {</span>
            // scriptSig: &lt;sig&gt; [sig] [sig...] &lt;redeemscript&gt;
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">            checkArgument(redeemScript != null, &quot;P2SH script requires redeemScript to be spent&quot;);</span>
<span class="fc" id="L660">            return redeemScript.getNumberOfSignaturesRequiredToSpend() * SIG_SIZE + redeemScript.getProgram().length;</span>
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">        } else if (isSentToMultiSig()) {</span>
            // scriptSig: OP_0 &lt;sig&gt; [sig] [sig...]
<span class="nc" id="L663">            return getNumberOfSignaturesRequiredToSpend() * SIG_SIZE + 1;</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">        } else if (isSentToRawPubKey()) {</span>
            // scriptSig: &lt;sig&gt;
<span class="fc" id="L666">            return SIG_SIZE;</span>
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">        } else if (isSentToAddress()) {</span>
            // scriptSig: &lt;sig&gt; &lt;pubkey&gt;
<span class="fc" id="L669">            int uncompressedPubKeySize = 65;</span>
<span class="pc bpc" id="L670" title="1 of 2 branches missed.">            return SIG_SIZE + (pubKey != null ? pubKey.getPubKey().length : uncompressedPubKeySize);</span>
        } else {
<span class="nc" id="L672">            throw new IllegalStateException(&quot;Unsupported script type&quot;);</span>
        }
    }

    /**
     * &lt;p&gt;Whether or not this is a scriptPubKey representing a pay-to-script-hash output. In such outputs, the logic that
     * controls reclamation is not actually in the output at all. Instead there's just a hash, and it's up to the
     * spending input to provide a program matching that hash. This rule is &quot;soft enforced&quot; by the network as it does
     * not exist in Bitcoin Core. It means blocks containing P2SH transactions that don't match
     * correctly are considered valid, but won't be mined upon, so they'll be rapidly re-orgd out of the chain. This
     * logic is defined by &lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki&quot;&gt;BIP 16&lt;/a&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;bitcoinj does not support creation of P2SH transactions today. The goal of P2SH is to allow short addresses
     * even for complex scripts (eg, multi-sig outputs) so they are convenient to work with in things like QRcodes or
     * with copy/paste, and also to minimize the size of the unspent output set (which improves performance of the
     * Bitcoin system).&lt;/p&gt;
     */
    public boolean isPayToScriptHash() {
        // We have to check against the serialized form because BIP16 defines a P2SH output using an exact byte
        // template, not the logical program structure. Thus you can have two programs that look identical when
        // printed out but one is a P2SH script and the other isn't! :(
<span class="fc" id="L693">        byte[] program = getProgram();</span>
<span class="pc bpc" id="L694" title="2 of 8 branches missed.">        return program.length == 23 &amp;&amp;</span>
               (program[0] &amp; 0xff) == OP_HASH160 &amp;&amp;
               (program[1] &amp; 0xff) == 0x14 &amp;&amp;
               (program[22] &amp; 0xff) == OP_EQUAL;
    }

    /**
     * Returns whether this script matches the format used for multisig outputs: [n] [keys...] [m] CHECKMULTISIG
     */
    public boolean isSentToMultiSig() {
<span class="fc bfc" id="L704" title="All 2 branches covered.">        if (chunks.size() &lt; 4) return false;</span>
<span class="fc" id="L705">        ScriptChunk chunk = chunks.get(chunks.size() - 1);</span>
        // Must end in OP_CHECKMULTISIG[VERIFY].
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">        if (!chunk.isOpCode()) return false;</span>
<span class="pc bpc" id="L708" title="1 of 4 branches missed.">        if (!(chunk.equalsOpCode(OP_CHECKMULTISIG) || chunk.equalsOpCode(OP_CHECKMULTISIGVERIFY))) return false;</span>
        try {
            // Second to last chunk must be an OP_N opcode and there should be that many data chunks (keys).
<span class="fc" id="L711">            ScriptChunk m = chunks.get(chunks.size() - 2);</span>
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">            if (!m.isOpCode()) return false;</span>
<span class="fc" id="L713">            int numKeys = decodeFromOpN(m.opcode);</span>
<span class="pc bpc" id="L714" title="2 of 4 branches missed.">            if (numKeys &lt; 1 || chunks.size() != 3 + numKeys) return false;</span>
<span class="fc bfc" id="L715" title="All 2 branches covered.">            for (int i = 1; i &lt; chunks.size() - 2; i++) {</span>
<span class="pc bpc" id="L716" title="1 of 2 branches missed.">                if (chunks.get(i).isOpCode()) return false;</span>
            }
            // First chunk must be an OP_N opcode too.
<span class="pc bpc" id="L719" title="1 of 2 branches missed.">            if (decodeFromOpN(chunks.get(0).opcode) &lt; 1) return false;</span>
<span class="nc" id="L720">        } catch (IllegalArgumentException e) { // thrown by decodeFromOpN()</span>
<span class="nc" id="L721">            return false;   // Not an OP_N opcode.</span>
<span class="fc" id="L722">        }</span>
<span class="fc" id="L723">        return true;</span>
    }

    public boolean isSentToCLTVPaymentChannel() {
<span class="pc bpc" id="L727" title="1 of 2 branches missed.">        if (chunks.size() != 10) return false;</span>
        // Check that opcodes match the pre-determined format.
<span class="pc bpc" id="L729" title="1 of 2 branches missed.">        if (!chunks.get(0).equalsOpCode(OP_IF)) return false;</span>
        // chunk[1] = recipient pubkey
<span class="pc bpc" id="L731" title="1 of 2 branches missed.">        if (!chunks.get(2).equalsOpCode(OP_CHECKSIGVERIFY)) return false;</span>
<span class="pc bpc" id="L732" title="1 of 2 branches missed.">        if (!chunks.get(3).equalsOpCode(OP_ELSE)) return false;</span>
        // chunk[4] = locktime
<span class="pc bpc" id="L734" title="1 of 2 branches missed.">        if (!chunks.get(5).equalsOpCode(OP_CHECKLOCKTIMEVERIFY)) return false;</span>
<span class="pc bpc" id="L735" title="1 of 2 branches missed.">        if (!chunks.get(6).equalsOpCode(OP_DROP)) return false;</span>
<span class="pc bpc" id="L736" title="1 of 2 branches missed.">        if (!chunks.get(7).equalsOpCode(OP_ENDIF)) return false;</span>
        // chunk[8] = sender pubkey
<span class="pc bpc" id="L738" title="1 of 2 branches missed.">        if (!chunks.get(9).equalsOpCode(OP_CHECKSIG)) return false;</span>
<span class="fc" id="L739">        return true;</span>
    }

    private static boolean equalsRange(byte[] a, int start, byte[] b) {
<span class="fc bfc" id="L743" title="All 2 branches covered.">        if (start + b.length &gt; a.length)</span>
<span class="fc" id="L744">            return false;</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">        for (int i = 0; i &lt; b.length; i++)</span>
<span class="fc bfc" id="L746" title="All 2 branches covered.">            if (a[i + start] != b[i])</span>
<span class="fc" id="L747">                return false;</span>
<span class="fc" id="L748">        return true;</span>
    }
    
    /**
     * Returns the script bytes of inputScript with all instances of the specified script object removed
     */
    public static byte[] removeAllInstancesOf(byte[] inputScript, byte[] chunkToRemove) {
        // We usually don't end up removing anything
<span class="fc" id="L756">        UnsafeByteArrayOutputStream bos = new UnsafeByteArrayOutputStream(inputScript.length);</span>

<span class="fc" id="L758">        int cursor = 0;</span>
<span class="fc bfc" id="L759" title="All 2 branches covered.">        while (cursor &lt; inputScript.length) {</span>
<span class="fc" id="L760">            boolean skip = equalsRange(inputScript, cursor, chunkToRemove);</span>
            
<span class="fc" id="L762">            int opcode = inputScript[cursor++] &amp; 0xFF;</span>
<span class="fc" id="L763">            int additionalBytes = 0;</span>
<span class="pc bpc" id="L764" title="1 of 4 branches missed.">            if (opcode &gt;= 0 &amp;&amp; opcode &lt; OP_PUSHDATA1) {</span>
<span class="fc" id="L765">                additionalBytes = opcode;</span>
<span class="fc bfc" id="L766" title="All 2 branches covered.">            } else if (opcode == OP_PUSHDATA1) {</span>
<span class="fc" id="L767">                additionalBytes = (0xFF &amp; inputScript[cursor]) + 1;</span>
<span class="pc bpc" id="L768" title="1 of 2 branches missed.">            } else if (opcode == OP_PUSHDATA2) {</span>
<span class="nc" id="L769">                additionalBytes = ((0xFF &amp; inputScript[cursor]) |</span>
                                  ((0xFF &amp; inputScript[cursor+1]) &lt;&lt; 8)) + 2;
<span class="pc bpc" id="L771" title="1 of 2 branches missed.">            } else if (opcode == OP_PUSHDATA4) {</span>
<span class="nc" id="L772">                additionalBytes = ((0xFF &amp; inputScript[cursor]) |</span>
                                  ((0xFF &amp; inputScript[cursor+1]) &lt;&lt; 8) |
                                  ((0xFF &amp; inputScript[cursor+1]) &lt;&lt; 16) |
                                  ((0xFF &amp; inputScript[cursor+1]) &lt;&lt; 24)) + 4;
            }
<span class="fc bfc" id="L777" title="All 2 branches covered.">            if (!skip) {</span>
                try {
<span class="fc" id="L779">                    bos.write(opcode);</span>
<span class="fc" id="L780">                    bos.write(Arrays.copyOfRange(inputScript, cursor, cursor + additionalBytes));</span>
<span class="nc" id="L781">                } catch (IOException e) {</span>
<span class="nc" id="L782">                    throw new RuntimeException(e);</span>
<span class="fc" id="L783">                }</span>
            }
<span class="fc" id="L785">            cursor += additionalBytes;</span>
<span class="fc" id="L786">        }</span>
<span class="fc" id="L787">        return bos.toByteArray();</span>
    }
    
    /**
     * Returns the script bytes of inputScript with all instances of the given op code removed
     */
    public static byte[] removeAllInstancesOfOp(byte[] inputScript, int opCode) {
<span class="fc" id="L794">        return removeAllInstancesOf(inputScript, new byte[] {(byte)opCode});</span>
    }
    
    ////////////////////// Script verification and helpers ////////////////////////////////
    
    private static boolean castToBool(byte[] data) {
<span class="fc bfc" id="L800" title="All 2 branches covered.">        for (int i = 0; i &lt; data.length; i++)</span>
        {
            // &quot;Can be negative zero&quot; - Bitcoin Core (see OpenSSL's BN_bn2mpi)
<span class="fc bfc" id="L803" title="All 2 branches covered.">            if (data[i] != 0)</span>
<span class="fc bfc" id="L804" title="All 4 branches covered.">                return !(i == data.length - 1 &amp;&amp; (data[i] &amp; 0xFF) == 0x80);</span>
        }
<span class="fc" id="L806">        return false;</span>
    }

    /**
     * Cast a script chunk to a BigInteger.
     *
     * @see #castToBigInteger(byte[], int) for values with different maximum
     * sizes.
     * @throws ScriptException if the chunk is longer than 4 bytes.
     */
    private static BigInteger castToBigInteger(byte[] chunk, final boolean requireMinimal) throws ScriptException {
<span class="fc" id="L817">        return castToBigInteger(chunk, 4, requireMinimal);</span>
    }

    /**
     * Cast a script chunk to a BigInteger. Normally you would want
     * {@link #castToBigInteger(byte[])} instead, this is only for cases where
     * the normal maximum length does not apply (i.e. CHECKLOCKTIMEVERIFY, CHECKSEQUENCEVERIFY).
     *
     * @param maxLength the maximum length in bytes.
     * @param requireMinimal check if the number is encoded with the minimum possible number of bytes
     * @throws ScriptException if the chunk is longer than the specified maximum.
     */
    private static BigInteger castToBigInteger(final byte[] chunk, final int maxLength, final boolean requireMinimal) throws ScriptException {
<span class="fc bfc" id="L830" title="All 2 branches covered.">        if (chunk.length &gt; maxLength)</span>
<span class="fc" id="L831">            throw new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, &quot;Script attempted to use an integer larger than &quot; + maxLength + &quot; bytes&quot;);</span>

<span class="fc bfc" id="L833" title="All 4 branches covered.">        if (requireMinimal &amp;&amp; chunk.length &gt; 0) {</span>
            // Check that the number is encoded with the minimum possible
            // number of bytes.
            //
            // If the most-significant-byte - excluding the sign bit - is zero
            // then we're not minimal. Note how this test also rejects the
            // negative-zero encoding, 0x80.
<span class="fc bfc" id="L840" title="All 2 branches covered.">            if ((chunk[chunk.length - 1] &amp; 0x7f) == 0) {</span>
                // One exception: if there's more than one byte and the most
                // significant bit of the second-most-significant-byte is set
                // it would conflict with the sign bit. An example of this case
                // is +-255, which encode to 0xff00 and 0xff80 respectively.
                // (big-endian).
<span class="pc bpc" id="L846" title="1 of 4 branches missed.">                if (chunk.length &lt;= 1 || (chunk[chunk.length - 2] &amp; 0x80) == 0) {</span>
<span class="fc" id="L847">                    throw  new ScriptException(ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, &quot;non-minimally encoded script number&quot;);</span>
                }
            }
        }

<span class="fc" id="L852">        return Utils.decodeMPI(Utils.reverseBytes(chunk), false);</span>
    }

    public boolean isOpReturn() {
<span class="pc bpc" id="L856" title="1 of 4 branches missed.">        return chunks.size() &gt; 0 &amp;&amp; chunks.get(0).equalsOpCode(OP_RETURN);</span>
    }

    /**
     * Exposes the script interpreter. Normally you should not use this directly, instead use
     * {@link org.bitcoinj.core.TransactionInput#verify(org.bitcoinj.core.TransactionOutput)} or
     * {@link org.bitcoinj.script.Script#correctlySpends(org.bitcoinj.core.Transaction, long, Script)}. This method
     * is useful if you need more precise control or access to the final state of the stack. This interface is very
     * likely to change in future.
     *
     * @deprecated Use {@link #executeScript(org.bitcoinj.core.Transaction, long, org.bitcoinj.script.Script, java.util.LinkedList, java.util.Set)}
     * instead.
     */
    @Deprecated
    public static void executeScript(@Nullable Transaction txContainingThis, long index,
                                     Script script, LinkedList&lt;byte[]&gt; stack, boolean enforceNullDummy) throws ScriptException {
<span class="nc bnc" id="L872" title="All 2 branches missed.">        final EnumSet&lt;VerifyFlag&gt; flags = enforceNullDummy</span>
<span class="nc" id="L873">            ? EnumSet.of(VerifyFlag.NULLDUMMY)</span>
<span class="nc" id="L874">            : EnumSet.noneOf(VerifyFlag.class);</span>

<span class="nc" id="L876">        executeScript(txContainingThis, index, script, stack, flags);</span>
<span class="nc" id="L877">    }</span>

    /**
     * Exposes the script interpreter. Normally you should not use this directly, instead use
     * {@link org.bitcoinj.core.TransactionInput#verify(org.bitcoinj.core.TransactionOutput)} or
     * {@link org.bitcoinj.script.Script#correctlySpends(org.bitcoinj.core.Transaction, long, Script)}. This method
     * is useful if you need more precise control or access to the final state of the stack. This interface is very
     * likely to change in future.
     */
    public static void executeScript(@Nullable Transaction txContainingThis, long index,
                                     Script script, LinkedList&lt;byte[]&gt; stack, Set&lt;VerifyFlag&gt; verifyFlags) throws ScriptException {
<span class="fc" id="L888">        int opCount = 0;</span>
<span class="fc" id="L889">        int lastCodeSepLocation = 0;</span>
        
<span class="fc" id="L891">        LinkedList&lt;byte[]&gt; altstack = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L892">        LinkedList&lt;Boolean&gt; ifStack = new LinkedList&lt;&gt;();</span>
        
<span class="fc bfc" id="L894" title="All 2 branches covered.">        for (ScriptChunk chunk : script.chunks) {</span>
<span class="fc bfc" id="L895" title="All 2 branches covered.">            boolean shouldExecute = !ifStack.contains(false);</span>
<span class="fc" id="L896">            int opcode = chunk.opcode;</span>

            // Check stack element size
<span class="fc bfc" id="L899" title="All 4 branches covered.">            if (chunk.data != null &amp;&amp; chunk.data.length &gt; MAX_SCRIPT_ELEMENT_SIZE)</span>
<span class="fc" id="L900">                throw new ScriptException(ScriptError.SCRIPT_ERR_PUSH_SIZE, &quot;Attempted to push a data string larger than 520 bytes&quot;);</span>

            // Note how OP_RESERVED does not count towards the opcode limit.
<span class="fc bfc" id="L903" title="All 2 branches covered.">            if (opcode &gt; OP_16) {</span>
<span class="fc" id="L904">                opCount++;</span>
<span class="fc bfc" id="L905" title="All 2 branches covered.">                if (opCount &gt; MAX_OPS_PER_SCRIPT)</span>
<span class="fc" id="L906">                    throw new ScriptException(ScriptError.SCRIPT_ERR_OP_COUNT, &quot;More script operations than is allowed&quot;);</span>
            }

            // Disabled opcodes.
<span class="fc bfc" id="L910" title="All 30 branches covered.">            if (opcode == OP_CAT || opcode == OP_SUBSTR || opcode == OP_LEFT || opcode == OP_RIGHT ||</span>
                    opcode == OP_INVERT || opcode == OP_AND || opcode == OP_OR || opcode == OP_XOR ||
                    opcode == OP_2MUL || opcode == OP_2DIV || opcode == OP_MUL || opcode == OP_DIV ||
                    opcode == OP_MOD || opcode == OP_LSHIFT || opcode == OP_RSHIFT)
<span class="fc" id="L914">                throw new ScriptException(ScriptError.SCRIPT_ERR_DISABLED_OPCODE, &quot;Script included a disabled Script Op.&quot;);</span>

<span class="pc bpc" id="L916" title="1 of 6 branches missed.">            if (shouldExecute &amp;&amp; OP_0 &lt;= opcode &amp;&amp; opcode &lt;= OP_PUSHDATA4) {</span>
                // Check minimal push
<span class="fc bfc" id="L918" title="All 4 branches covered.">                if (verifyFlags.contains(VerifyFlag.MINIMALDATA) &amp;&amp; !chunk.isShortestPossiblePushData())</span>
<span class="fc" id="L919">                    throw new ScriptException(ScriptError.SCRIPT_ERR_MINIMALDATA, &quot;Script included a not minimal push operation.&quot;);</span>

<span class="fc bfc" id="L921" title="All 2 branches covered.">                if (opcode == OP_0)</span>
<span class="fc" id="L922">                    stack.add(new byte[]{});</span>
                else
<span class="fc" id="L924">                    stack.add(chunk.data);</span>
<span class="fc bfc" id="L925" title="All 6 branches covered.">            } else if (shouldExecute || (OP_IF &lt;= opcode &amp;&amp; opcode &lt;= OP_ENDIF)){</span>

<span class="fc bfc" id="L927" title="All 45 branches covered.">                switch (opcode) {</span>
                case OP_IF:
<span class="fc bfc" id="L929" title="All 2 branches covered.">                    if (!shouldExecute) {</span>
<span class="fc" id="L930">                        ifStack.add(false);</span>
<span class="fc" id="L931">                        continue;</span>
                    }
<span class="fc bfc" id="L933" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L934">                        throw new ScriptException(ScriptError.SCRIPT_ERR_UNBALANCED_CONDITIONAL, &quot;Attempted OP_IF on an empty stack&quot;);</span>
<span class="fc" id="L935">                    ifStack.add(castToBool(stack.pollLast()));</span>
<span class="fc" id="L936">                    continue;</span>
                case OP_NOTIF:
<span class="fc bfc" id="L938" title="All 2 branches covered.">                    if (!shouldExecute) {</span>
<span class="fc" id="L939">                        ifStack.add(false);</span>
<span class="fc" id="L940">                        continue;</span>
                    }
<span class="fc bfc" id="L942" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L943">                        throw new ScriptException(ScriptError.SCRIPT_ERR_UNBALANCED_CONDITIONAL, &quot;Attempted OP_NOTIF on an empty stack&quot;);</span>
<span class="fc bfc" id="L944" title="All 2 branches covered.">                    ifStack.add(!castToBool(stack.pollLast()));</span>
<span class="fc" id="L945">                    continue;</span>
                case OP_ELSE:
<span class="fc bfc" id="L947" title="All 2 branches covered.">                    if (ifStack.isEmpty())</span>
<span class="fc" id="L948">                        throw new ScriptException(ScriptError.SCRIPT_ERR_UNBALANCED_CONDITIONAL, &quot;Attempted OP_ELSE without OP_IF/NOTIF&quot;);</span>
<span class="fc bfc" id="L949" title="All 2 branches covered.">                    ifStack.add(!ifStack.pollLast());</span>
<span class="fc" id="L950">                    continue;</span>
                case OP_ENDIF:
<span class="fc bfc" id="L952" title="All 2 branches covered.">                    if (ifStack.isEmpty())</span>
<span class="fc" id="L953">                        throw new ScriptException(ScriptError.SCRIPT_ERR_UNBALANCED_CONDITIONAL, &quot;Attempted OP_ENDIF without OP_IF/NOTIF&quot;);</span>
<span class="fc" id="L954">                    ifStack.pollLast();</span>
<span class="fc" id="L955">                    continue;</span>

                // OP_0 is no opcode
                case OP_1NEGATE:
<span class="fc" id="L959">                    stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ONE.negate(), false)));</span>
<span class="fc" id="L960">                    break;</span>
                case OP_1:
                case OP_2:
                case OP_3:
                case OP_4:
                case OP_5:
                case OP_6:
                case OP_7:
                case OP_8:
                case OP_9:
                case OP_10:
                case OP_11:
                case OP_12:
                case OP_13:
                case OP_14:
                case OP_15:
                case OP_16:
<span class="fc" id="L977">                    stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(decodeFromOpN(opcode)), false)));</span>
<span class="fc" id="L978">                    break;</span>
                case OP_NOP:
<span class="fc" id="L980">                    break;</span>
                case OP_VERIFY:
<span class="fc bfc" id="L982" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L983">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_VERIFY on an empty stack&quot;);</span>
<span class="fc bfc" id="L984" title="All 2 branches covered.">                    if (!castToBool(stack.pollLast()))</span>
<span class="fc" id="L985">                        throw new ScriptException(ScriptError.SCRIPT_ERR_VERIFY, &quot;OP_VERIFY failed&quot;);</span>
                    break;
                case OP_RETURN:
<span class="fc" id="L988">                    throw new ScriptException(ScriptError.SCRIPT_ERR_OP_RETURN, &quot;Script called OP_RETURN&quot;);</span>
                case OP_TOALTSTACK:
<span class="fc bfc" id="L990" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L991">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_TOALTSTACK on an empty stack&quot;);</span>
<span class="fc" id="L992">                    altstack.add(stack.pollLast());</span>
<span class="fc" id="L993">                    break;</span>
                case OP_FROMALTSTACK:
<span class="fc bfc" id="L995" title="All 2 branches covered.">                    if (altstack.size() &lt; 1)</span>
<span class="fc" id="L996">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_ALTSTACK_OPERATION, &quot;Attempted OP_FROMALTSTACK on an empty altstack&quot;);</span>
<span class="fc" id="L997">                    stack.add(altstack.pollLast());</span>
<span class="fc" id="L998">                    break;</span>
                case OP_2DROP:
<span class="fc bfc" id="L1000" title="All 2 branches covered.">                    if (stack.size() &lt; 2)</span>
<span class="fc" id="L1001">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_2DROP on a stack with size &lt; 2&quot;);</span>
<span class="fc" id="L1002">                    stack.pollLast();</span>
<span class="fc" id="L1003">                    stack.pollLast();</span>
<span class="fc" id="L1004">                    break;</span>
                case OP_2DUP:
<span class="fc bfc" id="L1006" title="All 2 branches covered.">                    if (stack.size() &lt; 2)</span>
<span class="fc" id="L1007">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_2DUP on a stack with size &lt; 2&quot;);</span>
<span class="fc" id="L1008">                    Iterator&lt;byte[]&gt; it2DUP = stack.descendingIterator();</span>
<span class="fc" id="L1009">                    byte[] OP2DUPtmpChunk2 = it2DUP.next();</span>
<span class="fc" id="L1010">                    stack.add(it2DUP.next());</span>
<span class="fc" id="L1011">                    stack.add(OP2DUPtmpChunk2);</span>
<span class="fc" id="L1012">                    break;</span>
                case OP_3DUP:
<span class="fc bfc" id="L1014" title="All 2 branches covered.">                    if (stack.size() &lt; 3)</span>
<span class="fc" id="L1015">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_3DUP on a stack with size &lt; 3&quot;);</span>
<span class="fc" id="L1016">                    Iterator&lt;byte[]&gt; it3DUP = stack.descendingIterator();</span>
<span class="fc" id="L1017">                    byte[] OP3DUPtmpChunk3 = it3DUP.next();</span>
<span class="fc" id="L1018">                    byte[] OP3DUPtmpChunk2 = it3DUP.next();</span>
<span class="fc" id="L1019">                    stack.add(it3DUP.next());</span>
<span class="fc" id="L1020">                    stack.add(OP3DUPtmpChunk2);</span>
<span class="fc" id="L1021">                    stack.add(OP3DUPtmpChunk3);</span>
<span class="fc" id="L1022">                    break;</span>
                case OP_2OVER:
<span class="fc bfc" id="L1024" title="All 2 branches covered.">                    if (stack.size() &lt; 4)</span>
<span class="fc" id="L1025">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_2OVER on a stack with size &lt; 4&quot;);</span>
<span class="fc" id="L1026">                    Iterator&lt;byte[]&gt; it2OVER = stack.descendingIterator();</span>
<span class="fc" id="L1027">                    it2OVER.next();</span>
<span class="fc" id="L1028">                    it2OVER.next();</span>
<span class="fc" id="L1029">                    byte[] OP2OVERtmpChunk2 = it2OVER.next();</span>
<span class="fc" id="L1030">                    stack.add(it2OVER.next());</span>
<span class="fc" id="L1031">                    stack.add(OP2OVERtmpChunk2);</span>
<span class="fc" id="L1032">                    break;</span>
                case OP_2ROT:
<span class="fc bfc" id="L1034" title="All 2 branches covered.">                    if (stack.size() &lt; 6)</span>
<span class="fc" id="L1035">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_2ROT on a stack with size &lt; 6&quot;);</span>
<span class="fc" id="L1036">                    byte[] OP2ROTtmpChunk6 = stack.pollLast();</span>
<span class="fc" id="L1037">                    byte[] OP2ROTtmpChunk5 = stack.pollLast();</span>
<span class="fc" id="L1038">                    byte[] OP2ROTtmpChunk4 = stack.pollLast();</span>
<span class="fc" id="L1039">                    byte[] OP2ROTtmpChunk3 = stack.pollLast();</span>
<span class="fc" id="L1040">                    byte[] OP2ROTtmpChunk2 = stack.pollLast();</span>
<span class="fc" id="L1041">                    byte[] OP2ROTtmpChunk1 = stack.pollLast();</span>
<span class="fc" id="L1042">                    stack.add(OP2ROTtmpChunk3);</span>
<span class="fc" id="L1043">                    stack.add(OP2ROTtmpChunk4);</span>
<span class="fc" id="L1044">                    stack.add(OP2ROTtmpChunk5);</span>
<span class="fc" id="L1045">                    stack.add(OP2ROTtmpChunk6);</span>
<span class="fc" id="L1046">                    stack.add(OP2ROTtmpChunk1);</span>
<span class="fc" id="L1047">                    stack.add(OP2ROTtmpChunk2);</span>
<span class="fc" id="L1048">                    break;</span>
                case OP_2SWAP:
<span class="fc bfc" id="L1050" title="All 2 branches covered.">                    if (stack.size() &lt; 4)</span>
<span class="fc" id="L1051">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_2SWAP on a stack with size &lt; 4&quot;);</span>
<span class="fc" id="L1052">                    byte[] OP2SWAPtmpChunk4 = stack.pollLast();</span>
<span class="fc" id="L1053">                    byte[] OP2SWAPtmpChunk3 = stack.pollLast();</span>
<span class="fc" id="L1054">                    byte[] OP2SWAPtmpChunk2 = stack.pollLast();</span>
<span class="fc" id="L1055">                    byte[] OP2SWAPtmpChunk1 = stack.pollLast();</span>
<span class="fc" id="L1056">                    stack.add(OP2SWAPtmpChunk3);</span>
<span class="fc" id="L1057">                    stack.add(OP2SWAPtmpChunk4);</span>
<span class="fc" id="L1058">                    stack.add(OP2SWAPtmpChunk1);</span>
<span class="fc" id="L1059">                    stack.add(OP2SWAPtmpChunk2);</span>
<span class="fc" id="L1060">                    break;</span>
                case OP_IFDUP:
<span class="fc bfc" id="L1062" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L1063">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_IFDUP on an empty stack&quot;);</span>
<span class="fc bfc" id="L1064" title="All 2 branches covered.">                    if (castToBool(stack.getLast()))</span>
<span class="fc" id="L1065">                        stack.add(stack.getLast());</span>
                    break;
                case OP_DEPTH:
<span class="fc" id="L1068">                    stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(stack.size()), false)));</span>
<span class="fc" id="L1069">                    break;</span>
                case OP_DROP:
<span class="fc bfc" id="L1071" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L1072">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_DROP on an empty stack&quot;);</span>
<span class="fc" id="L1073">                    stack.pollLast();</span>
<span class="fc" id="L1074">                    break;</span>
                case OP_DUP:
<span class="fc bfc" id="L1076" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L1077">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_DUP on an empty stack&quot;);</span>
<span class="fc" id="L1078">                    stack.add(stack.getLast());</span>
<span class="fc" id="L1079">                    break;</span>
                case OP_NIP:
<span class="fc bfc" id="L1081" title="All 2 branches covered.">                    if (stack.size() &lt; 2)</span>
<span class="fc" id="L1082">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_NIP on a stack with size &lt; 2&quot;);</span>
<span class="fc" id="L1083">                    byte[] OPNIPtmpChunk = stack.pollLast();</span>
<span class="fc" id="L1084">                    stack.pollLast();</span>
<span class="fc" id="L1085">                    stack.add(OPNIPtmpChunk);</span>
<span class="fc" id="L1086">                    break;</span>
                case OP_OVER:
<span class="fc bfc" id="L1088" title="All 2 branches covered.">                    if (stack.size() &lt; 2)</span>
<span class="fc" id="L1089">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_OVER on a stack with size &lt; 2&quot;);</span>
<span class="fc" id="L1090">                    Iterator&lt;byte[]&gt; itOVER = stack.descendingIterator();</span>
<span class="fc" id="L1091">                    itOVER.next();</span>
<span class="fc" id="L1092">                    stack.add(itOVER.next());</span>
<span class="fc" id="L1093">                    break;</span>
                case OP_PICK:
                case OP_ROLL:
<span class="pc bpc" id="L1096" title="1 of 2 branches missed.">                    if (stack.size() &lt; 1)</span>
<span class="nc" id="L1097">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_PICK/OP_ROLL on an empty stack&quot;);</span>
<span class="fc" id="L1098">                    long val = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA)).longValue();</span>
<span class="fc bfc" id="L1099" title="All 4 branches covered.">                    if (val &lt; 0 || val &gt;= stack.size())</span>
<span class="fc" id="L1100">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;OP_PICK/OP_ROLL attempted to get data deeper than stack size&quot;);</span>
<span class="fc" id="L1101">                    Iterator&lt;byte[]&gt; itPICK = stack.descendingIterator();</span>
<span class="fc bfc" id="L1102" title="All 2 branches covered.">                    for (long i = 0; i &lt; val; i++)</span>
<span class="fc" id="L1103">                        itPICK.next();</span>
<span class="fc" id="L1104">                    byte[] OPROLLtmpChunk = itPICK.next();</span>
<span class="fc bfc" id="L1105" title="All 2 branches covered.">                    if (opcode == OP_ROLL)</span>
<span class="fc" id="L1106">                        itPICK.remove();</span>
<span class="fc" id="L1107">                    stack.add(OPROLLtmpChunk);</span>
<span class="fc" id="L1108">                    break;</span>
                case OP_ROT:
<span class="fc bfc" id="L1110" title="All 2 branches covered.">                    if (stack.size() &lt; 3)</span>
<span class="fc" id="L1111">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_ROT on a stack with size &lt; 3&quot;);</span>
<span class="fc" id="L1112">                    byte[] OPROTtmpChunk3 = stack.pollLast();</span>
<span class="fc" id="L1113">                    byte[] OPROTtmpChunk2 = stack.pollLast();</span>
<span class="fc" id="L1114">                    byte[] OPROTtmpChunk1 = stack.pollLast();</span>
<span class="fc" id="L1115">                    stack.add(OPROTtmpChunk2);</span>
<span class="fc" id="L1116">                    stack.add(OPROTtmpChunk3);</span>
<span class="fc" id="L1117">                    stack.add(OPROTtmpChunk1);</span>
<span class="fc" id="L1118">                    break;</span>
                case OP_SWAP:
                case OP_TUCK:
<span class="fc bfc" id="L1121" title="All 2 branches covered.">                    if (stack.size() &lt; 2)</span>
<span class="fc" id="L1122">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_SWAP on a stack with size &lt; 2&quot;);</span>
<span class="fc" id="L1123">                    byte[] OPSWAPtmpChunk2 = stack.pollLast();</span>
<span class="fc" id="L1124">                    byte[] OPSWAPtmpChunk1 = stack.pollLast();</span>
<span class="fc" id="L1125">                    stack.add(OPSWAPtmpChunk2);</span>
<span class="fc" id="L1126">                    stack.add(OPSWAPtmpChunk1);</span>
<span class="fc bfc" id="L1127" title="All 2 branches covered.">                    if (opcode == OP_TUCK)</span>
<span class="fc" id="L1128">                        stack.add(OPSWAPtmpChunk2);</span>
                    break;
                case OP_SIZE:
<span class="fc bfc" id="L1131" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L1132">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_SIZE on an empty stack&quot;);</span>
<span class="fc" id="L1133">                    stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(stack.getLast().length), false)));</span>
<span class="fc" id="L1134">                    break;</span>
                case OP_EQUAL:
<span class="fc bfc" id="L1136" title="All 2 branches covered.">                    if (stack.size() &lt; 2)</span>
<span class="fc" id="L1137">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_EQUAL on a stack with size &lt; 2&quot;);</span>
<span class="fc bfc" id="L1138" title="All 2 branches covered.">                    stack.add(Arrays.equals(stack.pollLast(), stack.pollLast()) ? new byte[] {1} : new byte[] {});</span>
<span class="fc" id="L1139">                    break;</span>
                case OP_EQUALVERIFY:
<span class="fc bfc" id="L1141" title="All 2 branches covered.">                    if (stack.size() &lt; 2)</span>
<span class="fc" id="L1142">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_EQUALVERIFY on a stack with size &lt; 2&quot;);</span>
<span class="fc bfc" id="L1143" title="All 2 branches covered.">                    if (!Arrays.equals(stack.pollLast(), stack.pollLast()))</span>
<span class="fc" id="L1144">                        throw new ScriptException(ScriptError.SCRIPT_ERR_EQUALVERIFY, &quot;OP_EQUALVERIFY: non-equal data&quot;);</span>
                    break;
                case OP_1ADD:
                case OP_1SUB:
                case OP_NEGATE:
                case OP_ABS:
                case OP_NOT:
                case OP_0NOTEQUAL:
<span class="fc bfc" id="L1152" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L1153">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted a numeric op on an empty stack&quot;);</span>
<span class="fc" id="L1154">                    BigInteger numericOPnum = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA));</span>
                                        
<span class="pc bpc" id="L1156" title="1 of 7 branches missed.">                    switch (opcode) {</span>
                    case OP_1ADD:
<span class="fc" id="L1158">                        numericOPnum = numericOPnum.add(BigInteger.ONE);</span>
<span class="fc" id="L1159">                        break;</span>
                    case OP_1SUB:
<span class="fc" id="L1161">                        numericOPnum = numericOPnum.subtract(BigInteger.ONE);</span>
<span class="fc" id="L1162">                        break;</span>
                    case OP_NEGATE:
<span class="fc" id="L1164">                        numericOPnum = numericOPnum.negate();</span>
<span class="fc" id="L1165">                        break;</span>
                    case OP_ABS:
<span class="fc bfc" id="L1167" title="All 2 branches covered.">                        if (numericOPnum.signum() &lt; 0)</span>
<span class="fc" id="L1168">                            numericOPnum = numericOPnum.negate();</span>
                        break;
                    case OP_NOT:
<span class="fc bfc" id="L1171" title="All 2 branches covered.">                        if (numericOPnum.equals(BigInteger.ZERO))</span>
<span class="fc" id="L1172">                            numericOPnum = BigInteger.ONE;</span>
                        else
<span class="fc" id="L1174">                            numericOPnum = BigInteger.ZERO;</span>
<span class="fc" id="L1175">                        break;</span>
                    case OP_0NOTEQUAL:
<span class="fc bfc" id="L1177" title="All 2 branches covered.">                        if (numericOPnum.equals(BigInteger.ZERO))</span>
<span class="fc" id="L1178">                            numericOPnum = BigInteger.ZERO;</span>
                        else
<span class="fc" id="L1180">                            numericOPnum = BigInteger.ONE;</span>
<span class="fc" id="L1181">                        break;</span>
                    default:
<span class="nc" id="L1183">                        throw new AssertionError(&quot;Unreachable&quot;);</span>
                    }
                    
<span class="fc" id="L1186">                    stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPnum, false)));</span>
<span class="fc" id="L1187">                    break;</span>
                case OP_ADD:
                case OP_SUB:
                case OP_BOOLAND:
                case OP_BOOLOR:
                case OP_NUMEQUAL:
                case OP_NUMNOTEQUAL:
                case OP_LESSTHAN:
                case OP_GREATERTHAN:
                case OP_LESSTHANOREQUAL:
                case OP_GREATERTHANOREQUAL:
                case OP_MIN:
                case OP_MAX:
<span class="fc bfc" id="L1200" title="All 2 branches covered.">                    if (stack.size() &lt; 2)</span>
<span class="fc" id="L1201">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted a numeric op on a stack with size &lt; 2&quot;);</span>
<span class="fc" id="L1202">                    BigInteger numericOPnum2 = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA));</span>
<span class="fc" id="L1203">                    BigInteger numericOPnum1 = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA));</span>

                    BigInteger numericOPresult;
<span class="pc bpc" id="L1206" title="1 of 13 branches missed.">                    switch (opcode) {</span>
                    case OP_ADD:
<span class="fc" id="L1208">                        numericOPresult = numericOPnum1.add(numericOPnum2);</span>
<span class="fc" id="L1209">                        break;</span>
                    case OP_SUB:
<span class="fc" id="L1211">                        numericOPresult = numericOPnum1.subtract(numericOPnum2);</span>
<span class="fc" id="L1212">                        break;</span>
                    case OP_BOOLAND:
<span class="fc bfc" id="L1214" title="All 4 branches covered.">                        if (!numericOPnum1.equals(BigInteger.ZERO) &amp;&amp; !numericOPnum2.equals(BigInteger.ZERO))</span>
<span class="fc" id="L1215">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="fc" id="L1217">                            numericOPresult = BigInteger.ZERO;</span>
<span class="fc" id="L1218">                        break;</span>
                    case OP_BOOLOR:
<span class="fc bfc" id="L1220" title="All 4 branches covered.">                        if (!numericOPnum1.equals(BigInteger.ZERO) || !numericOPnum2.equals(BigInteger.ZERO))</span>
<span class="fc" id="L1221">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="fc" id="L1223">                            numericOPresult = BigInteger.ZERO;</span>
<span class="fc" id="L1224">                        break;</span>
                    case OP_NUMEQUAL:
<span class="fc bfc" id="L1226" title="All 2 branches covered.">                        if (numericOPnum1.equals(numericOPnum2))</span>
<span class="fc" id="L1227">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="fc" id="L1229">                            numericOPresult = BigInteger.ZERO;</span>
<span class="fc" id="L1230">                        break;</span>
                    case OP_NUMNOTEQUAL:
<span class="fc bfc" id="L1232" title="All 2 branches covered.">                        if (!numericOPnum1.equals(numericOPnum2))</span>
<span class="fc" id="L1233">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="fc" id="L1235">                            numericOPresult = BigInteger.ZERO;</span>
<span class="fc" id="L1236">                        break;</span>
                    case OP_LESSTHAN:
<span class="fc bfc" id="L1238" title="All 2 branches covered.">                        if (numericOPnum1.compareTo(numericOPnum2) &lt; 0)</span>
<span class="fc" id="L1239">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="fc" id="L1241">                            numericOPresult = BigInteger.ZERO;</span>
<span class="fc" id="L1242">                        break;</span>
                    case OP_GREATERTHAN:
<span class="fc bfc" id="L1244" title="All 2 branches covered.">                        if (numericOPnum1.compareTo(numericOPnum2) &gt; 0)</span>
<span class="fc" id="L1245">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="fc" id="L1247">                            numericOPresult = BigInteger.ZERO;</span>
<span class="fc" id="L1248">                        break;</span>
                    case OP_LESSTHANOREQUAL:
<span class="fc bfc" id="L1250" title="All 2 branches covered.">                        if (numericOPnum1.compareTo(numericOPnum2) &lt;= 0)</span>
<span class="fc" id="L1251">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="fc" id="L1253">                            numericOPresult = BigInteger.ZERO;</span>
<span class="fc" id="L1254">                        break;</span>
                    case OP_GREATERTHANOREQUAL:
<span class="fc bfc" id="L1256" title="All 2 branches covered.">                        if (numericOPnum1.compareTo(numericOPnum2) &gt;= 0)</span>
<span class="fc" id="L1257">                            numericOPresult = BigInteger.ONE;</span>
                        else
<span class="fc" id="L1259">                            numericOPresult = BigInteger.ZERO;</span>
<span class="fc" id="L1260">                        break;</span>
                    case OP_MIN:
<span class="fc bfc" id="L1262" title="All 2 branches covered.">                        if (numericOPnum1.compareTo(numericOPnum2) &lt; 0)</span>
<span class="fc" id="L1263">                            numericOPresult = numericOPnum1;</span>
                        else
<span class="fc" id="L1265">                            numericOPresult = numericOPnum2;</span>
<span class="fc" id="L1266">                        break;</span>
                    case OP_MAX:
<span class="fc bfc" id="L1268" title="All 2 branches covered.">                        if (numericOPnum1.compareTo(numericOPnum2) &gt; 0)</span>
<span class="fc" id="L1269">                            numericOPresult = numericOPnum1;</span>
                        else
<span class="fc" id="L1271">                            numericOPresult = numericOPnum2;</span>
<span class="fc" id="L1272">                        break;</span>
                    default:
<span class="nc" id="L1274">                        throw new RuntimeException(&quot;Opcode switched at runtime?&quot;);</span>
                    }
                    
<span class="fc" id="L1277">                    stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPresult, false)));</span>
<span class="fc" id="L1278">                    break;</span>
                case OP_NUMEQUALVERIFY:
<span class="fc bfc" id="L1280" title="All 2 branches covered.">                    if (stack.size() &lt; 2)</span>
<span class="fc" id="L1281">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_NUMEQUALVERIFY on a stack with size &lt; 2&quot;);</span>
<span class="fc" id="L1282">                    BigInteger OPNUMEQUALVERIFYnum2 = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA));</span>
<span class="fc" id="L1283">                    BigInteger OPNUMEQUALVERIFYnum1 = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA));</span>
                    
<span class="pc bpc" id="L1285" title="1 of 2 branches missed.">                    if (!OPNUMEQUALVERIFYnum1.equals(OPNUMEQUALVERIFYnum2))</span>
<span class="nc" id="L1286">                        throw new ScriptException(ScriptError.SCRIPT_ERR_NUMEQUALVERIFY, &quot;OP_NUMEQUALVERIFY failed&quot;);</span>
                    break;
                case OP_WITHIN:
<span class="fc bfc" id="L1289" title="All 2 branches covered.">                    if (stack.size() &lt; 3)</span>
<span class="fc" id="L1290">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_WITHIN on a stack with size &lt; 3&quot;);</span>
<span class="fc" id="L1291">                    BigInteger OPWITHINnum3 = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA));</span>
<span class="fc" id="L1292">                    BigInteger OPWITHINnum2 = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA));</span>
<span class="fc" id="L1293">                    BigInteger OPWITHINnum1 = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA));</span>
<span class="fc bfc" id="L1294" title="All 4 branches covered.">                    if (OPWITHINnum2.compareTo(OPWITHINnum1) &lt;= 0 &amp;&amp; OPWITHINnum1.compareTo(OPWITHINnum3) &lt; 0)</span>
<span class="fc" id="L1295">                        stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ONE, false)));</span>
                    else
<span class="fc" id="L1297">                        stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ZERO, false)));</span>
<span class="fc" id="L1298">                    break;</span>
                case OP_RIPEMD160:
<span class="fc bfc" id="L1300" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L1301">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_RIPEMD160 on an empty stack&quot;);</span>
<span class="fc" id="L1302">                    RIPEMD160Digest digest = new RIPEMD160Digest();</span>
<span class="fc" id="L1303">                    byte[] dataToHash = stack.pollLast();</span>
<span class="fc" id="L1304">                    digest.update(dataToHash, 0, dataToHash.length);</span>
<span class="fc" id="L1305">                    byte[] ripmemdHash = new byte[20];</span>
<span class="fc" id="L1306">                    digest.doFinal(ripmemdHash, 0);</span>
<span class="fc" id="L1307">                    stack.add(ripmemdHash);</span>
<span class="fc" id="L1308">                    break;</span>
                case OP_SHA1:
<span class="fc bfc" id="L1310" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L1311">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_SHA1 on an empty stack&quot;);</span>
                    try {
<span class="fc" id="L1313">                        stack.add(MessageDigest.getInstance(&quot;SHA-1&quot;).digest(stack.pollLast()));</span>
<span class="nc" id="L1314">                    } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L1315">                        throw new RuntimeException(e);  // Cannot happen.</span>
<span class="fc" id="L1316">                    }</span>
                    break;
                case OP_SHA256:
<span class="fc bfc" id="L1319" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L1320">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_SHA256 on an empty stack&quot;);</span>
<span class="fc" id="L1321">                    stack.add(Sha256Hash.hash(stack.pollLast()));</span>
<span class="fc" id="L1322">                    break;</span>
                case OP_HASH160:
<span class="fc bfc" id="L1324" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L1325">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_HASH160 on an empty stack&quot;);</span>
<span class="fc" id="L1326">                    stack.add(Utils.sha256hash160(stack.pollLast()));</span>
<span class="fc" id="L1327">                    break;</span>
                case OP_HASH256:
<span class="fc bfc" id="L1329" title="All 2 branches covered.">                    if (stack.size() &lt; 1)</span>
<span class="fc" id="L1330">                        throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_SHA256 on an empty stack&quot;);</span>
<span class="fc" id="L1331">                    stack.add(Sha256Hash.hashTwice(stack.pollLast()));</span>
<span class="fc" id="L1332">                    break;</span>
                case OP_CODESEPARATOR:
<span class="fc" id="L1334">                    lastCodeSepLocation = chunk.getStartLocationInProgram() + 1;</span>
<span class="fc" id="L1335">                    break;</span>
                case OP_CHECKSIG:
                case OP_CHECKSIGVERIFY:
<span class="pc bpc" id="L1338" title="1 of 2 branches missed.">                    if (txContainingThis == null)</span>
<span class="nc" id="L1339">                        throw new IllegalStateException(&quot;Script attempted signature check but no tx was provided&quot;);</span>
<span class="fc" id="L1340">                    executeCheckSig(txContainingThis, (int) index, script, stack, lastCodeSepLocation, opcode, verifyFlags);</span>
<span class="fc" id="L1341">                    break;</span>
                case OP_CHECKMULTISIG:
                case OP_CHECKMULTISIGVERIFY:
<span class="pc bpc" id="L1344" title="1 of 2 branches missed.">                    if (txContainingThis == null)</span>
<span class="nc" id="L1345">                        throw new IllegalStateException(&quot;Script attempted signature check but no tx was provided&quot;);</span>
<span class="fc" id="L1346">                    opCount = executeMultiSig(txContainingThis, (int) index, script, stack, opCount, lastCodeSepLocation, opcode, verifyFlags);</span>
<span class="fc" id="L1347">                    break;</span>
                case OP_CHECKLOCKTIMEVERIFY:
<span class="fc bfc" id="L1349" title="All 2 branches covered.">                    if (!verifyFlags.contains(VerifyFlag.CHECKLOCKTIMEVERIFY)) {</span>
                        // not enabled; treat as a NOP2
<span class="fc bfc" id="L1351" title="All 2 branches covered.">                        if (verifyFlags.contains(VerifyFlag.DISCOURAGE_UPGRADABLE_NOPS)) {</span>
<span class="fc" id="L1352">                            throw new ScriptException(ScriptError.SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, &quot;Script used a reserved opcode &quot; + opcode);</span>
                        }
                        break;
                    }
<span class="fc" id="L1356">                    executeCheckLockTimeVerify(txContainingThis, (int) index, stack, verifyFlags);</span>
<span class="fc" id="L1357">                    break;</span>
                case OP_CHECKSEQUENCEVERIFY:
<span class="fc bfc" id="L1359" title="All 2 branches covered.">                    if (!verifyFlags.contains(VerifyFlag.CHECKSEQUENCEVERIFY)) {</span>
                        // not enabled; treat as a NOP3
<span class="fc bfc" id="L1361" title="All 2 branches covered.">                        if (verifyFlags.contains(VerifyFlag.DISCOURAGE_UPGRADABLE_NOPS)) {</span>
<span class="fc" id="L1362">                            throw new ScriptException(ScriptError.SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, &quot;Script used a reserved opcode &quot; + opcode);</span>
                        }
                        break;
                    }
<span class="fc" id="L1366">                    executeCheckSequenceVerify(txContainingThis, (int) index, stack, verifyFlags);</span>
<span class="fc" id="L1367">                    break;</span>
                case OP_NOP1:
                case OP_NOP4:
                case OP_NOP5:
                case OP_NOP6:
                case OP_NOP7:
                case OP_NOP8:
                case OP_NOP9:
                case OP_NOP10:
<span class="fc bfc" id="L1376" title="All 2 branches covered.">                    if (verifyFlags.contains(VerifyFlag.DISCOURAGE_UPGRADABLE_NOPS)) {</span>
<span class="fc" id="L1377">                        throw new ScriptException(ScriptError.SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, &quot;Script used a reserved opcode &quot; + opcode);</span>
                    }
                    break;
                    
                default:
<span class="fc" id="L1382">                    throw new ScriptException(ScriptError.SCRIPT_ERR_BAD_OPCODE, &quot;Script used a reserved or disabled opcode: &quot; + opcode);</span>
                }
            }
            
<span class="pc bpc" id="L1386" title="1 of 4 branches missed.">            if (stack.size() + altstack.size() &gt; MAX_STACK_SIZE || stack.size() + altstack.size() &lt; 0)</span>
<span class="fc" id="L1387">                throw new ScriptException(ScriptError.SCRIPT_ERR_STACK_SIZE, &quot;Stack size exceeded range&quot;);</span>
<span class="fc" id="L1388">        }</span>
        
<span class="fc bfc" id="L1390" title="All 2 branches covered.">        if (!ifStack.isEmpty())</span>
<span class="fc" id="L1391">            throw new ScriptException(ScriptError.SCRIPT_ERR_UNBALANCED_CONDITIONAL, &quot;OP_IF/OP_NOTIF without OP_ENDIF&quot;);</span>
<span class="fc" id="L1392">    }</span>

    // This is more or less a direct translation of the code in Bitcoin Core
    private static void executeCheckLockTimeVerify(Transaction txContainingThis, int index, LinkedList&lt;byte[]&gt; stack, Set&lt;VerifyFlag&gt; verifyFlags) throws ScriptException {
<span class="fc bfc" id="L1396" title="All 2 branches covered.">        if (stack.size() &lt; 1)</span>
<span class="fc" id="L1397">            throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_CHECKLOCKTIMEVERIFY on a stack with size &lt; 1&quot;);</span>

        // Thus as a special case we tell CScriptNum to accept up
        // to 5-byte bignums to avoid year 2038 issue.
<span class="fc" id="L1401">        final BigInteger nLockTime = castToBigInteger(stack.getLast(), 5, verifyFlags.contains(VerifyFlag.MINIMALDATA));</span>

<span class="fc bfc" id="L1403" title="All 2 branches covered.">        if (nLockTime.compareTo(BigInteger.ZERO) &lt; 0)</span>
<span class="fc" id="L1404">            throw new ScriptException(ScriptError.SCRIPT_ERR_NEGATIVE_LOCKTIME, &quot;Negative locktime&quot;);</span>

        // There are two kinds of nLockTime, need to ensure we're comparing apples-to-apples
<span class="fc" id="L1407">        if (!(</span>
<span class="fc bfc" id="L1408" title="All 4 branches covered.">            ((txContainingThis.getLockTime() &lt;  Transaction.LOCKTIME_THRESHOLD) &amp;&amp; (nLockTime.compareTo(Transaction.LOCKTIME_THRESHOLD_BIG)) &lt; 0) ||</span>
<span class="fc bfc" id="L1409" title="All 4 branches covered.">            ((txContainingThis.getLockTime() &gt;= Transaction.LOCKTIME_THRESHOLD) &amp;&amp; (nLockTime.compareTo(Transaction.LOCKTIME_THRESHOLD_BIG)) &gt;= 0))</span>
        )
<span class="fc" id="L1411">            throw new ScriptException(ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, &quot;Locktime requirement type mismatch&quot;);</span>

        // Now that we know we're comparing apples-to-apples, the
        // comparison is a simple numeric one.
<span class="fc bfc" id="L1415" title="All 2 branches covered.">        if (nLockTime.compareTo(BigInteger.valueOf(txContainingThis.getLockTime())) &gt; 0)</span>
<span class="fc" id="L1416">            throw new ScriptException(ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, &quot;Locktime requirement not satisfied&quot;);</span>

        // Finally the nLockTime feature can be disabled and thus
        // CHECKLOCKTIMEVERIFY bypassed if every txin has been
        // finalized by setting nSequence to maxint. The
        // transaction would be allowed into the blockchain, making
        // the opcode ineffective.
        //
        // Testing if this vin is not final is sufficient to
        // prevent this condition. Alternatively we could test all
        // inputs, but testing just this input minimizes the data
        // required to prove correct CHECKLOCKTIMEVERIFY execution.
<span class="fc bfc" id="L1428" title="All 2 branches covered.">        if (!txContainingThis.getInput(index).hasSequence())</span>
<span class="fc" id="L1429">            throw new ScriptException(ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, &quot;Transaction contains a final transaction input for a CHECKLOCKTIMEVERIFY script.&quot;);</span>
<span class="fc" id="L1430">    }</span>

    private static void executeCheckSequenceVerify(Transaction txContainingThis, int index, LinkedList&lt;byte[]&gt; stack, Set&lt;VerifyFlag&gt; verifyFlags) throws ScriptException {
<span class="fc bfc" id="L1433" title="All 2 branches covered.">        if (stack.size() &lt; 1)</span>
<span class="fc" id="L1434">            throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_CHECKSEQUENCEVERIFY on a stack with size &lt; 1&quot;);</span>

        // Note that elsewhere numeric opcodes are limited to
        // operands in the range -2**31+1 to 2**31-1, however it is
        // legal for opcodes to produce results exceeding that
        // range. This limitation is implemented by CScriptNum's
        // default 4-byte limit.
        //
        // Thus as a special case we tell CScriptNum to accept up
        // to 5-byte bignums, which are good until 2**39-1, well
        // beyond the 2**32-1 limit of the nSequence field itself.
<span class="fc" id="L1445">        final long nSequence = castToBigInteger(stack.getLast(), 5, verifyFlags.contains(VerifyFlag.MINIMALDATA)).longValue();</span>

        // In the rare event that the argument may be &lt; 0 due to
        // some arithmetic being done first, you can always use
        // 0 MAX CHECKSEQUENCEVERIFY.
<span class="fc bfc" id="L1450" title="All 2 branches covered.">        if (nSequence &lt; 0)</span>
<span class="fc" id="L1451">            throw new ScriptException(ScriptError.SCRIPT_ERR_NEGATIVE_LOCKTIME, &quot;Negative sequence&quot;);</span>

        // To provide for future soft-fork extensibility, if the
        // operand has the disabled lock-time flag set,
        // CHECKSEQUENCEVERIFY behaves as a NOP.
<span class="fc bfc" id="L1456" title="All 2 branches covered.">        if ((nSequence &amp; TransactionInput.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0)</span>
<span class="fc" id="L1457">            return;</span>

        // Compare the specified sequence number with the input.
<span class="fc" id="L1460">        checkSequence(nSequence, txContainingThis, index);</span>
<span class="fc" id="L1461">    }</span>

    private static void checkSequence(long nSequence, Transaction txContainingThis, int index) {
        // Relative lock times are supported by comparing the passed
        // in operand to the sequence number of the input.
<span class="fc" id="L1466">        long txToSequence = txContainingThis.getInput(index).getSequenceNumber();</span>

        // Fail if the transaction's version number is not set high
        // enough to trigger BIP 68 rules.
<span class="fc bfc" id="L1470" title="All 2 branches covered.">        if (txContainingThis.getVersion() &lt; 2)</span>
<span class="fc" id="L1471">            throw new ScriptException(ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, &quot;Transaction version is &lt; 2&quot;);</span>

        // Sequence numbers with their most significant bit set are not
        // consensus constrained. Testing that the transaction's sequence
        // number do not have this bit set prevents using this property
        // to get around a CHECKSEQUENCEVERIFY check.
<span class="pc bpc" id="L1477" title="1 of 2 branches missed.">        if ((txToSequence &amp; TransactionInput.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0)</span>
<span class="nc" id="L1478">            throw new ScriptException(ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, &quot;Sequence disable flag is set&quot;);</span>

        // Mask off any bits that do not have consensus-enforced meaning
        // before doing the integer comparisons
<span class="fc" id="L1482">        long nLockTimeMask =  TransactionInput.SEQUENCE_LOCKTIME_TYPE_FLAG | TransactionInput.SEQUENCE_LOCKTIME_MASK;</span>
<span class="fc" id="L1483">        long txToSequenceMasked = txToSequence &amp; nLockTimeMask;</span>
<span class="fc" id="L1484">        long nSequenceMasked = nSequence &amp; nLockTimeMask;</span>

        // There are two kinds of nSequence: lock-by-blockheight
        // and lock-by-blocktime, distinguished by whether
        // nSequenceMasked &lt; CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.
        //
        // We want to compare apples to apples, so fail the script
        // unless the type of nSequenceMasked being tested is the same as
        // the nSequenceMasked in the transaction.
<span class="fc bfc" id="L1493" title="All 8 branches covered.">        if (!((txToSequenceMasked &lt; TransactionInput.SEQUENCE_LOCKTIME_TYPE_FLAG &amp;&amp; nSequenceMasked &lt; TransactionInput.SEQUENCE_LOCKTIME_TYPE_FLAG) ||</span>
              (txToSequenceMasked &gt;= TransactionInput.SEQUENCE_LOCKTIME_TYPE_FLAG &amp;&amp; nSequenceMasked &gt;= TransactionInput.SEQUENCE_LOCKTIME_TYPE_FLAG))) {
<span class="fc" id="L1495">            throw new ScriptException(ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, &quot;Relative locktime requirement type mismatch&quot;);</span>
        }

        // Now that we know we're comparing apples-to-apples, the
        // comparison is a simple numeric one.
<span class="fc bfc" id="L1500" title="All 2 branches covered.">        if (nSequenceMasked &gt; txToSequenceMasked)</span>
<span class="fc" id="L1501">            throw new ScriptException(ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, &quot;Relative locktime requirement not satisfied&quot;);</span>
<span class="fc" id="L1502">    }</span>

    private static void executeCheckSig(Transaction txContainingThis, int index, Script script, LinkedList&lt;byte[]&gt; stack,
                                        int lastCodeSepLocation, int opcode, 
                                        Set&lt;VerifyFlag&gt; verifyFlags) throws ScriptException {
<span class="fc bfc" id="L1507" title="All 2 branches covered.">        final boolean requireCanonical = verifyFlags.contains(VerifyFlag.STRICTENC)</span>
<span class="fc bfc" id="L1508" title="All 2 branches covered.">            || verifyFlags.contains(VerifyFlag.DERSIG)</span>
<span class="fc bfc" id="L1509" title="All 2 branches covered.">            || verifyFlags.contains(VerifyFlag.LOW_S);</span>
<span class="fc bfc" id="L1510" title="All 2 branches covered.">        if (stack.size() &lt; 2)</span>
<span class="fc" id="L1511">            throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_CHECKSIG(VERIFY) on a stack with size &lt; 2&quot;);</span>
<span class="fc" id="L1512">        byte[] pubKey = stack.pollLast();</span>
<span class="fc" id="L1513">        byte[] sigBytes = stack.pollLast();</span>

<span class="fc" id="L1515">        byte[] prog = script.getProgram();</span>
<span class="fc" id="L1516">        byte[] connectedScript = Arrays.copyOfRange(prog, lastCodeSepLocation, prog.length);</span>

<span class="fc" id="L1518">        UnsafeByteArrayOutputStream outStream = new UnsafeByteArrayOutputStream(sigBytes.length + 1);</span>
        try {
<span class="fc" id="L1520">            writeBytes(outStream, sigBytes);</span>
<span class="nc" id="L1521">        } catch (IOException e) {</span>
<span class="nc" id="L1522">            throw new RuntimeException(e); // Cannot happen</span>
<span class="fc" id="L1523">        }</span>
<span class="fc" id="L1524">        connectedScript = removeAllInstancesOf(connectedScript, outStream.toByteArray());</span>

        // TODO: Use int for indexes everywhere, we can't have that many inputs/outputs
<span class="fc" id="L1527">        boolean sigValid = false;</span>
        try {
<span class="fc" id="L1529">            TransactionSignature sig  = TransactionSignature.decodeFromBitcoin(sigBytes, requireCanonical,</span>
<span class="fc" id="L1530">                verifyFlags.contains(VerifyFlag.LOW_S));</span>

            // TODO: Should check hash type is known
<span class="fc" id="L1533">            Sha256Hash hash = txContainingThis.hashForSignature(index, connectedScript, (byte) sig.sighashFlags);</span>
<span class="fc" id="L1534">            sigValid = ECKey.verify(hash.getBytes(), sig, pubKey);</span>
<span class="fc" id="L1535">        } catch (Exception e1) {</span>
            // There is (at least) one exception that could be hit here (EOFException, if the sig is too short)
            // Because I can't verify there aren't more, we use a very generic Exception catch

            // This RuntimeException occurs when signing as we run partial/invalid scripts to see if they need more
            // signing work to be done inside LocalTransactionSigner.signInputs.
            // FIXME don't rely on exception message
<span class="pc bpc" id="L1542" title="2 of 4 branches missed.">            if (e1.getMessage() != null &amp;&amp; !e1.getMessage().contains(&quot;Reached past end of ASN.1 stream&quot;))</span>
                // Don't put critical code here; the above check is not reliable on HotSpot due to optimization:
                // http://jawspeak.com/2010/05/26/hotspot-caused-exceptions-to-lose-their-stack-traces-in-production-and-the-fix/
<span class="fc" id="L1545">                log.warn(&quot;Signature checking failed!&quot;, e1);</span>
<span class="fc" id="L1546">        }</span>

<span class="fc bfc" id="L1548" title="All 2 branches covered.">        if (opcode == OP_CHECKSIG)</span>
<span class="fc bfc" id="L1549" title="All 2 branches covered.">            stack.add(sigValid ? new byte[] {1} : new byte[] {});</span>
<span class="pc bpc" id="L1550" title="1 of 2 branches missed.">        else if (opcode == OP_CHECKSIGVERIFY)</span>
<span class="fc bfc" id="L1551" title="All 2 branches covered.">            if (!sigValid)</span>
<span class="fc" id="L1552">                throw new ScriptException(ScriptError.SCRIPT_ERR_CHECKSIGVERIFY, &quot;Script failed OP_CHECKSIGVERIFY&quot;);</span>
<span class="fc" id="L1553">    }</span>

    private static int executeMultiSig(Transaction txContainingThis, int index, Script script, LinkedList&lt;byte[]&gt; stack,
                                       int opCount, int lastCodeSepLocation, int opcode, 
                                       Set&lt;VerifyFlag&gt; verifyFlags) throws ScriptException {
<span class="fc bfc" id="L1558" title="All 2 branches covered.">        final boolean requireCanonical = verifyFlags.contains(VerifyFlag.STRICTENC)</span>
<span class="pc bpc" id="L1559" title="1 of 2 branches missed.">            || verifyFlags.contains(VerifyFlag.DERSIG)</span>
<span class="pc bpc" id="L1560" title="1 of 2 branches missed.">            || verifyFlags.contains(VerifyFlag.LOW_S);</span>
<span class="fc bfc" id="L1561" title="All 2 branches covered.">        if (stack.size() &lt; 1)</span>
<span class="fc" id="L1562">            throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size &lt; 2&quot;);</span>
<span class="fc" id="L1563">        int pubKeyCount = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA)).intValue();</span>
<span class="fc bfc" id="L1564" title="All 4 branches covered.">        if (pubKeyCount &lt; 0 || pubKeyCount &gt; MAX_PUBKEYS_PER_MULTISIG)</span>
<span class="fc" id="L1565">            throw new ScriptException(ScriptError.SCRIPT_ERR_PUBKEY_COUNT, &quot;OP_CHECKMULTISIG(VERIFY) with pubkey count out of range&quot;);</span>
<span class="fc" id="L1566">        opCount += pubKeyCount;</span>
<span class="fc bfc" id="L1567" title="All 2 branches covered.">        if (opCount &gt; MAX_OPS_PER_SCRIPT)</span>
<span class="fc" id="L1568">            throw new ScriptException(ScriptError.SCRIPT_ERR_OP_COUNT, &quot;Total op count &gt; 201 during OP_CHECKMULTISIG(VERIFY)&quot;);</span>
<span class="fc bfc" id="L1569" title="All 2 branches covered.">        if (stack.size() &lt; pubKeyCount + 1)</span>
<span class="fc" id="L1570">            throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size &lt; num_of_pubkeys + 2&quot;);</span>

<span class="fc" id="L1572">        LinkedList&lt;byte[]&gt; pubkeys = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L1573" title="All 2 branches covered.">        for (int i = 0; i &lt; pubKeyCount; i++) {</span>
<span class="fc" id="L1574">            byte[] pubKey = stack.pollLast();</span>
<span class="fc" id="L1575">            pubkeys.add(pubKey);</span>
        }

<span class="fc" id="L1578">        int sigCount = castToBigInteger(stack.pollLast(), verifyFlags.contains(VerifyFlag.MINIMALDATA)).intValue();</span>
<span class="fc bfc" id="L1579" title="All 4 branches covered.">        if (sigCount &lt; 0 || sigCount &gt; pubKeyCount)</span>
<span class="fc" id="L1580">            throw new ScriptException(ScriptError.SCRIPT_ERR_SIG_COUNT, &quot;OP_CHECKMULTISIG(VERIFY) with sig count out of range&quot;);</span>
<span class="fc bfc" id="L1581" title="All 2 branches covered.">        if (stack.size() &lt; sigCount + 1)</span>
<span class="fc" id="L1582">            throw new ScriptException(ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, &quot;Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size &lt; num_of_pubkeys + num_of_signatures + 3&quot;);</span>

<span class="fc" id="L1584">        LinkedList&lt;byte[]&gt; sigs = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L1585" title="All 2 branches covered.">        for (int i = 0; i &lt; sigCount; i++) {</span>
<span class="fc" id="L1586">            byte[] sig = stack.pollLast();</span>
<span class="fc" id="L1587">            sigs.add(sig);</span>
        }

<span class="fc" id="L1590">        byte[] prog = script.getProgram();</span>
<span class="fc" id="L1591">        byte[] connectedScript = Arrays.copyOfRange(prog, lastCodeSepLocation, prog.length);</span>

<span class="fc bfc" id="L1593" title="All 2 branches covered.">        for (byte[] sig : sigs) {</span>
<span class="fc" id="L1594">            UnsafeByteArrayOutputStream outStream = new UnsafeByteArrayOutputStream(sig.length + 1);</span>
            try {
<span class="fc" id="L1596">                writeBytes(outStream, sig);</span>
<span class="nc" id="L1597">            } catch (IOException e) {</span>
<span class="nc" id="L1598">                throw new RuntimeException(e); // Cannot happen</span>
<span class="fc" id="L1599">            }</span>
<span class="fc" id="L1600">            connectedScript = removeAllInstancesOf(connectedScript, outStream.toByteArray());</span>
<span class="fc" id="L1601">        }</span>

<span class="fc" id="L1603">        boolean valid = true;</span>
<span class="fc bfc" id="L1604" title="All 2 branches covered.">        while (sigs.size() &gt; 0) {</span>
<span class="fc" id="L1605">            byte[] pubKey = pubkeys.pollFirst();</span>
            // We could reasonably move this out of the loop, but because signature verification is significantly
            // more expensive than hashing, its not a big deal.
            try {
<span class="fc" id="L1609">                TransactionSignature sig = TransactionSignature.decodeFromBitcoin(sigs.getFirst(), requireCanonical);</span>
<span class="fc" id="L1610">                Sha256Hash hash = txContainingThis.hashForSignature(index, connectedScript, (byte) sig.sighashFlags);</span>
<span class="fc bfc" id="L1611" title="All 2 branches covered.">                if (ECKey.verify(hash.getBytes(), sig, pubKey))</span>
<span class="fc" id="L1612">                    sigs.pollFirst();</span>
<span class="fc" id="L1613">            } catch (Exception e) {</span>
                // There is (at least) one exception that could be hit here (EOFException, if the sig is too short)
                // Because I can't verify there aren't more, we use a very generic Exception catch
<span class="fc" id="L1616">            }</span>

<span class="fc bfc" id="L1618" title="All 2 branches covered.">            if (sigs.size() &gt; pubkeys.size()) {</span>
<span class="fc" id="L1619">                valid = false;</span>
<span class="fc" id="L1620">                break;</span>
            }
<span class="fc" id="L1622">        }</span>

        // We uselessly remove a stack object to emulate a Bitcoin Core bug.
<span class="fc" id="L1625">        byte[] nullDummy = stack.pollLast();</span>
<span class="fc bfc" id="L1626" title="All 4 branches covered.">        if (verifyFlags.contains(VerifyFlag.NULLDUMMY) &amp;&amp; nullDummy.length &gt; 0)</span>
<span class="fc" id="L1627">            throw new ScriptException(ScriptError.SCRIPT_ERR_SIG_NULLFAIL, &quot;OP_CHECKMULTISIG(VERIFY) with non-null nulldummy: &quot; + Arrays.toString(nullDummy));</span>

<span class="fc bfc" id="L1629" title="All 2 branches covered.">        if (opcode == OP_CHECKMULTISIG) {</span>
<span class="fc bfc" id="L1630" title="All 2 branches covered.">            stack.add(valid ? new byte[] {1} : new byte[] {});</span>
<span class="pc bpc" id="L1631" title="1 of 2 branches missed.">        } else if (opcode == OP_CHECKMULTISIGVERIFY) {</span>
<span class="pc bpc" id="L1632" title="1 of 2 branches missed.">            if (!valid)</span>
<span class="nc" id="L1633">                throw new ScriptException(ScriptError.SCRIPT_ERR_SIG_NULLFAIL, &quot;Script failed OP_CHECKMULTISIGVERIFY&quot;);</span>
        }
<span class="fc" id="L1635">        return opCount;</span>
    }

    /**
     * Verifies that this script (interpreted as a scriptSig) correctly spends the given scriptPubKey, enabling all
     * validation rules.
     * @param txContainingThis The transaction in which this input scriptSig resides.
     *                         Accessing txContainingThis from another thread while this method runs results in undefined behavior.
     * @param scriptSigIndex The index in txContainingThis of the scriptSig (note: NOT the index of the scriptPubKey).
     * @param scriptPubKey The connected scriptPubKey containing the conditions needed to claim the value.
     * @deprecated Use {@link #correctlySpends(org.bitcoinj.core.Transaction, long, org.bitcoinj.script.Script, java.util.Set)}
     * instead so that verification flags do not change as new verification options
     * are added.
     */
    @Deprecated
    public void correctlySpends(Transaction txContainingThis, long scriptSigIndex, Script scriptPubKey)
            throws ScriptException {
<span class="fc" id="L1652">        correctlySpends(txContainingThis, scriptSigIndex, scriptPubKey, ALL_VERIFY_FLAGS);</span>
<span class="fc" id="L1653">    }</span>

    /**
     * Verifies that this script (interpreted as a scriptSig) correctly spends the given scriptPubKey.
     * @param txContainingThis The transaction in which this input scriptSig resides.
     *                         Accessing txContainingThis from another thread while this method runs results in undefined behavior.
     * @param scriptSigIndex The index in txContainingThis of the scriptSig (note: NOT the index of the scriptPubKey).
     * @param scriptPubKey The connected scriptPubKey containing the conditions needed to claim the value.
     * @param verifyFlags Each flag enables one validation rule. If in doubt, use {@link #correctlySpends(Transaction, long, Script)}
     *                    which sets all flags.
     */
    public void correctlySpends(Transaction txContainingThis, long scriptSigIndex, Script scriptPubKey,
                                Set&lt;VerifyFlag&gt; verifyFlags) throws ScriptException {
        // Clone the transaction because executing the script involves editing it, and if we die, we'll leave
        // the tx half broken (also it's not so thread safe to work on it directly.
        try {
<span class="fc" id="L1669">            txContainingThis = txContainingThis.getParams().getDefaultSerializer().makeTransaction(txContainingThis.bitcoinSerialize());</span>
<span class="nc" id="L1670">        } catch (ProtocolException e) {</span>
<span class="nc" id="L1671">            throw new RuntimeException(e);   // Should not happen unless we were given a totally broken transaction.</span>
<span class="fc" id="L1672">        }</span>
<span class="pc bpc" id="L1673" title="1 of 4 branches missed.">        if (getProgram().length &gt; MAX_SCRIPT_SIZE || scriptPubKey.getProgram().length &gt; MAX_SCRIPT_SIZE)</span>
<span class="fc" id="L1674">            throw new ScriptException(ScriptError.SCRIPT_ERR_SCRIPT_SIZE, &quot;Script larger than 10,000 bytes&quot;);</span>
        
<span class="fc" id="L1676">        LinkedList&lt;byte[]&gt; stack = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L1677">        LinkedList&lt;byte[]&gt; p2shStack = null;</span>
        
<span class="fc" id="L1679">        executeScript(txContainingThis, scriptSigIndex, this, stack, verifyFlags);</span>
<span class="fc bfc" id="L1680" title="All 2 branches covered.">        if (verifyFlags.contains(VerifyFlag.P2SH))</span>
<span class="fc" id="L1681">            p2shStack = new LinkedList&lt;&gt;(stack);</span>
<span class="fc" id="L1682">        executeScript(txContainingThis, scriptSigIndex, scriptPubKey, stack, verifyFlags);</span>
        
<span class="fc bfc" id="L1684" title="All 2 branches covered.">        if (stack.size() == 0)</span>
<span class="fc" id="L1685">            throw new ScriptException(ScriptError.SCRIPT_ERR_EVAL_FALSE, &quot;Stack empty at end of script execution.&quot;);</span>
        
<span class="fc bfc" id="L1687" title="All 2 branches covered.">        if (!castToBool(stack.pollLast()))</span>
<span class="fc" id="L1688">            throw new ScriptException(ScriptError.SCRIPT_ERR_EVAL_FALSE, &quot;Script resulted in a non-true stack: &quot; + stack);</span>

        // P2SH is pay to script hash. It means that the scriptPubKey has a special form which is a valid
        // program but it has &quot;useless&quot; form that if evaluated as a normal program always returns true.
        // Instead, miners recognize it as special based on its template - it provides a hash of the real scriptPubKey
        // and that must be provided by the input. The goal of this bizarre arrangement is twofold:
        //
        // (1) You can sum up a large, complex script (like a CHECKMULTISIG script) with an address that's the same
        //     size as a regular address. This means it doesn't overload scannable QR codes/NFC tags or become
        //     un-wieldy to copy/paste.
        // (2) It allows the working set to be smaller: nodes perform best when they can store as many unspent outputs
        //     in RAM as possible, so if the outputs are made smaller and the inputs get bigger, then it's better for
        //     overall scalability and performance.

        // TODO: Check if we can take out enforceP2SH if there's a checkpoint at the enforcement block.
<span class="fc bfc" id="L1703" title="All 4 branches covered.">        if (verifyFlags.contains(VerifyFlag.P2SH) &amp;&amp; scriptPubKey.isPayToScriptHash()) {</span>
<span class="fc bfc" id="L1704" title="All 2 branches covered.">            for (ScriptChunk chunk : chunks)</span>
<span class="fc bfc" id="L1705" title="All 4 branches covered.">                if (chunk.isOpCode() &amp;&amp; chunk.opcode &gt; OP_16)</span>
<span class="fc" id="L1706">                    throw new ScriptException(ScriptError.SCRIPT_ERR_SIG_PUSHONLY, &quot;Attempted to spend a P2SH scriptPubKey with a script that contained script ops&quot;);</span>
            
<span class="fc" id="L1708">            byte[] scriptPubKeyBytes = p2shStack.pollLast();</span>
<span class="fc" id="L1709">            Script scriptPubKeyP2SH = new Script(scriptPubKeyBytes);</span>
            
<span class="fc" id="L1711">            executeScript(txContainingThis, scriptSigIndex, scriptPubKeyP2SH, p2shStack, verifyFlags);</span>
            
<span class="pc bpc" id="L1713" title="1 of 2 branches missed.">            if (p2shStack.size() == 0)</span>
<span class="nc" id="L1714">                throw new ScriptException(ScriptError.SCRIPT_ERR_EVAL_FALSE, &quot;P2SH stack empty at end of script execution.&quot;);</span>
            
<span class="fc bfc" id="L1716" title="All 2 branches covered.">            if (!castToBool(p2shStack.pollLast()))</span>
<span class="fc" id="L1717">                throw new ScriptException(ScriptError.SCRIPT_ERR_EVAL_FALSE, &quot;P2SH script execution resulted in a non-true stack&quot;);</span>
        }
<span class="fc" id="L1719">    }</span>

    // Utility that doesn't copy for internal use
    private byte[] getQuickProgram() {
<span class="fc bfc" id="L1723" title="All 2 branches covered.">        if (program != null)</span>
<span class="fc" id="L1724">            return program;</span>
<span class="fc" id="L1725">        return getProgram();</span>
    }

    /**
     * Get the {@link org.bitcoinj.script.Script.ScriptType}.
     * @return The script type.
     */
    public ScriptType getScriptType() {
<span class="fc" id="L1733">        ScriptType type = ScriptType.NO_TYPE;</span>
<span class="pc bpc" id="L1734" title="1 of 2 branches missed.">        if (isSentToAddress()) {</span>
<span class="nc" id="L1735">            type = ScriptType.P2PKH;</span>
<span class="fc bfc" id="L1736" title="All 2 branches covered.">        } else if (isSentToRawPubKey()) {</span>
<span class="fc" id="L1737">            type = ScriptType.PUB_KEY;</span>
<span class="fc bfc" id="L1738" title="All 2 branches covered.">        } else if (isPayToScriptHash()) {</span>
<span class="fc" id="L1739">            type = ScriptType.P2SH;</span>
        }
<span class="fc" id="L1741">        return type;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L1746" title="1 of 2 branches missed.">        if (this == o) return true;</span>
<span class="pc bpc" id="L1747" title="2 of 4 branches missed.">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L1748">        return Arrays.equals(getQuickProgram(), ((Script)o).getQuickProgram());</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L1753">        return Arrays.hashCode(getQuickProgram());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>