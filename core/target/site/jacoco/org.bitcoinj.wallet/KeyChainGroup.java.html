<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>KeyChainGroup.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bitcoinj</a> &gt; <a href="index.source.html" class="el_package">org.bitcoinj.wallet</a> &gt; <span class="el_source">KeyChainGroup.java</span></div><h1>KeyChainGroup.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2014 Mike Hearn
 * Copyright 2014 Andreas Schildbach
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bitcoinj.wallet;

import com.google.common.collect.*;
import com.google.protobuf.*;
import org.bitcoinj.core.*;
import org.bitcoinj.crypto.*;
import org.bitcoinj.script.*;
import org.bitcoinj.utils.*;
import org.bitcoinj.wallet.listeners.KeyChainEventListener;
import org.slf4j.*;
import org.spongycastle.crypto.params.*;

import javax.annotation.*;
import java.security.*;
import java.util.*;
import java.util.concurrent.*;

import static com.google.common.base.Preconditions.*;

/**
 * &lt;p&gt;A KeyChainGroup is used by the {@link org.bitcoinj.wallet.Wallet} and
 * manages: a {@link BasicKeyChain} object (which will normally be empty), and zero or more
 * {@link DeterministicKeyChain}s. A deterministic key chain will be created lazily/on demand
 * when a fresh or current key is requested, possibly being initialized from the private key bytes of the earliest non
 * rotating key in the basic key chain if one is available, or from a fresh random seed if not.&lt;/p&gt;
 *
 * &lt;p&gt;If a key rotation time is set, it may be necessary to add a new DeterministicKeyChain with a fresh seed
 * and also preserve the old one, so funds can be swept from the rotating keys. In this case, there may be
 * more than one deterministic chain. The latest chain is called the active chain and is where new keys are served
 * from.&lt;/p&gt;
 *
 * &lt;p&gt;The wallet delegates most key management tasks to this class. It is &lt;b&gt;not&lt;/b&gt; thread safe and requires external
 * locking, i.e. by the wallet lock. The group then in turn delegates most operations to the key chain objects,
 * combining their responses together when necessary.&lt;/p&gt;
 *
 * &lt;p&gt;Deterministic key chains have a concept of a lookahead size and threshold. Please see the discussion in the
 * class docs for {@link DeterministicKeyChain} for more information on this topic.&lt;/p&gt;
 */
public class KeyChainGroup implements KeyBag {

    static {
        // Init proper random number generator, as some old Android installations have bugs that make it unsecure.
<span class="pc bpc" id="L60" title="1 of 2 branches missed.">        if (Utils.isAndroidRuntime())</span>
<span class="nc" id="L61">            new LinuxSecureRandom();</span>
    }

<span class="fc" id="L64">    private static final Logger log = LoggerFactory.getLogger(KeyChainGroup.class);</span>

    private BasicKeyChain basic;
    private NetworkParameters params;
    protected final LinkedList&lt;DeterministicKeyChain&gt; chains;
    // currentKeys is used for normal, non-multisig/married wallets. currentAddresses is used when we're handing out
    // P2SH addresses. They're mutually exclusive.
    private final EnumMap&lt;KeyChain.KeyPurpose, DeterministicKey&gt; currentKeys;
    private final EnumMap&lt;KeyChain.KeyPurpose, Address&gt; currentAddresses;
    @Nullable private KeyCrypter keyCrypter;
<span class="fc" id="L74">    private int lookaheadSize = -1;</span>
<span class="fc" id="L75">    private int lookaheadThreshold = -1;</span>

    /** Creates a keychain group with no basic chain, and a single, lazily created HD chain. */
    public KeyChainGroup(NetworkParameters params) {
<span class="fc" id="L79">        this(params, null, new ArrayList&lt;DeterministicKeyChain&gt;(1), null, null);</span>
<span class="fc" id="L80">    }</span>

    /** Creates a keychain group with no basic chain, and an HD chain initialized from the given seed. */
    public KeyChainGroup(NetworkParameters params, DeterministicSeed seed) {
<span class="fc" id="L84">        this(params, null, ImmutableList.of(new DeterministicKeyChain(seed)), null, null);</span>
<span class="fc" id="L85">    }</span>

    /**
     * Creates a keychain group with no basic chain, and an HD chain initialized from the given seed. Account path is
     * provided.
     */
    public KeyChainGroup(NetworkParameters params, DeterministicSeed seed, ImmutableList&lt;ChildNumber&gt; accountPath) {
<span class="nc" id="L92">        this(params, null, ImmutableList.of(new DeterministicKeyChain(seed, accountPath)), null, null);</span>
<span class="nc" id="L93">    }</span>

    /**
     * Creates a keychain group with no basic chain, and an HD chain that is watching the given watching key.
     * This HAS to be an account key as returned by {@link DeterministicKeyChain#getWatchingKey()}.
     */
    public KeyChainGroup(NetworkParameters params, DeterministicKey watchKey) {
<span class="fc" id="L100">        this(params, null, ImmutableList.of(DeterministicKeyChain.watch(watchKey)), null, null);</span>
<span class="fc" id="L101">    }</span>

    /**
     * Creates a keychain group with no basic chain, and an HD chain that is watching the given watching key.
     * This HAS to be an account key as returned by {@link DeterministicKeyChain#getWatchingKey()}.
     */
    public KeyChainGroup(NetworkParameters params, DeterministicKey watchKey, ImmutableList&lt;ChildNumber&gt; accountPath) {
<span class="nc" id="L108">        this(params, null, ImmutableList.of(DeterministicKeyChain.watch(watchKey, accountPath)), null, null);</span>
<span class="nc" id="L109">    }</span>

    // Used for deserialization.
    private KeyChainGroup(NetworkParameters params, @Nullable BasicKeyChain basicKeyChain, List&lt;DeterministicKeyChain&gt; chains,
<span class="fc" id="L113">                          @Nullable EnumMap&lt;KeyChain.KeyPurpose, DeterministicKey&gt; currentKeys, @Nullable KeyCrypter crypter) {</span>
<span class="fc" id="L114">        this.params = params;</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">        this.basic = basicKeyChain == null ? new BasicKeyChain() : basicKeyChain;</span>
<span class="fc" id="L116">        this.chains = new LinkedList&lt;&gt;(checkNotNull(chains));</span>
<span class="fc" id="L117">        this.keyCrypter = crypter;</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">        this.currentKeys = currentKeys == null</span>
                ? new EnumMap&lt;KeyChain.KeyPurpose, DeterministicKey&gt;(KeyChain.KeyPurpose.class)
                : currentKeys;
<span class="fc" id="L121">        this.currentAddresses = new EnumMap&lt;&gt;(KeyChain.KeyPurpose.class);</span>
<span class="fc" id="L122">        maybeLookaheadScripts();</span>

<span class="fc bfc" id="L124" title="All 2 branches covered.">        if (isMarried()) {</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">            for (Map.Entry&lt;KeyChain.KeyPurpose, DeterministicKey&gt; entry : this.currentKeys.entrySet()) {</span>
<span class="fc" id="L126">                Address address = makeP2SHOutputScript(entry.getValue(), getActiveKeyChain()).getToAddress(params);</span>
<span class="fc" id="L127">                currentAddresses.put(entry.getKey(), address);</span>
<span class="fc" id="L128">            }</span>
        }
<span class="fc" id="L130">    }</span>

    // This keeps married redeem data in sync with the number of keys issued
    private void maybeLookaheadScripts() {
<span class="fc bfc" id="L134" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains) {</span>
<span class="fc" id="L135">            chain.maybeLookAheadScripts();</span>
<span class="fc" id="L136">        }</span>
<span class="fc" id="L137">    }</span>

    /** Adds a new HD chain to the chains list, and make it the default chain (from which keys are issued). */
    public void createAndActivateNewHDChain() {
        // We can't do auto upgrade here because we don't know the rotation time, if any.
<span class="fc" id="L142">        final DeterministicKeyChain chain = new DeterministicKeyChain(new SecureRandom());</span>
<span class="fc" id="L143">        addAndActivateHDChain(chain);</span>
<span class="fc" id="L144">    }</span>

    /**
     * Adds an HD chain to the chains list, and make it the default chain (from which keys are issued).
     * Useful for adding a complex pre-configured keychain, such as a married wallet.
     */
    public void addAndActivateHDChain(DeterministicKeyChain chain) {
<span class="fc" id="L151">        log.info(&quot;Creating and activating a new HD chain: {}&quot;, chain);</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">        for (ListenerRegistration&lt;KeyChainEventListener&gt; registration : basic.getListeners())</span>
<span class="nc" id="L153">            chain.addEventListener(registration.listener, registration.executor);</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">        if (lookaheadSize &gt;= 0)</span>
<span class="fc" id="L155">            chain.setLookaheadSize(lookaheadSize);</span>
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">        if (lookaheadThreshold &gt;= 0)</span>
<span class="nc" id="L157">            chain.setLookaheadThreshold(lookaheadThreshold);</span>
<span class="fc" id="L158">        chains.add(chain);</span>
<span class="fc" id="L159">    }</span>

    /**
     * Returns a key that hasn't been seen in a transaction yet, and which is suitable for displaying in a wallet
     * user interface as &quot;a convenient key to receive funds on&quot; when the purpose parameter is
     * {@link KeyChain.KeyPurpose#RECEIVE_FUNDS}. The returned key is stable until
     * it's actually seen in a pending or confirmed transaction, at which point this method will start returning
     * a different key (for each purpose independently).
     * &lt;p&gt;This method is not supposed to be used for married keychains and will throw UnsupportedOperationException if
     * the active chain is married.
     * For married keychains use {@link #currentAddress(KeyChain.KeyPurpose)}
     * to get a proper P2SH address&lt;/p&gt;
     */
    public DeterministicKey currentKey(KeyChain.KeyPurpose purpose) {
<span class="fc" id="L173">        DeterministicKeyChain chain = getActiveKeyChain();</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">        if (chain.isMarried()) {</span>
<span class="fc" id="L175">            throw new UnsupportedOperationException(&quot;Key is not suitable to receive coins for married keychains.&quot; +</span>
                                                    &quot; Use freshAddress to get P2SH address instead&quot;);
        }
<span class="fc" id="L178">        DeterministicKey current = currentKeys.get(purpose);</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">        if (current == null) {</span>
<span class="fc" id="L180">            current = freshKey(purpose);</span>
<span class="fc" id="L181">            currentKeys.put(purpose, current);</span>
        }
<span class="fc" id="L183">        return current;</span>
    }

    /**
     * Returns address for a {@link #currentKey(KeyChain.KeyPurpose)}
     */
    public Address currentAddress(KeyChain.KeyPurpose purpose) {
<span class="fc" id="L190">        DeterministicKeyChain chain = getActiveKeyChain();</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">        if (chain.isMarried()) {</span>
<span class="fc" id="L192">            Address current = currentAddresses.get(purpose);</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">            if (current == null) {</span>
<span class="fc" id="L194">                current = freshAddress(purpose);</span>
<span class="fc" id="L195">                currentAddresses.put(purpose, current);</span>
            }
<span class="fc" id="L197">            return current;</span>
        } else {
<span class="fc" id="L199">            return currentKey(purpose).toAddress(params);</span>
        }
    }

    /**
     * Returns a key that has not been returned by this method before (fresh). You can think of this as being
     * a newly created key, although the notion of &quot;create&quot; is not really valid for a
     * {@link DeterministicKeyChain}. When the parameter is
     * {@link KeyChain.KeyPurpose#RECEIVE_FUNDS} the returned key is suitable for being put
     * into a receive coins wizard type UI. You should use this when the user is definitely going to hand this key out
     * to someone who wishes to send money.
     * &lt;p&gt;This method is not supposed to be used for married keychains and will throw UnsupportedOperationException if
     * the active chain is married.
     * For married keychains use {@link #freshAddress(KeyChain.KeyPurpose)}
     * to get a proper P2SH address&lt;/p&gt;
     */
    public DeterministicKey freshKey(KeyChain.KeyPurpose purpose) {
<span class="fc" id="L216">        return freshKeys(purpose, 1).get(0);</span>
    }

    /**
     * Returns a key/s that have not been returned by this method before (fresh). You can think of this as being
     * newly created key/s, although the notion of &quot;create&quot; is not really valid for a
     * {@link DeterministicKeyChain}. When the parameter is
     * {@link KeyChain.KeyPurpose#RECEIVE_FUNDS} the returned key is suitable for being put
     * into a receive coins wizard type UI. You should use this when the user is definitely going to hand this key out
     * to someone who wishes to send money.
     * &lt;p&gt;This method is not supposed to be used for married keychains and will throw UnsupportedOperationException if
     * the active chain is married.
     * For married keychains use {@link #freshAddress(KeyChain.KeyPurpose)}
     * to get a proper P2SH address&lt;/p&gt;
     */
    public List&lt;DeterministicKey&gt; freshKeys(KeyChain.KeyPurpose purpose, int numberOfKeys) {
<span class="fc" id="L232">        DeterministicKeyChain chain = getActiveKeyChain();</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">        if (chain.isMarried()) {</span>
<span class="fc" id="L234">            throw new UnsupportedOperationException(&quot;Key is not suitable to receive coins for married keychains.&quot; +</span>
                    &quot; Use freshAddress to get P2SH address instead&quot;);
        }
<span class="fc" id="L237">        return chain.getKeys(purpose, numberOfKeys);   // Always returns the next key along the key chain.</span>
    }

    /**
     * Returns address for a {@link #freshKey(KeyChain.KeyPurpose)}
     */
    public Address freshAddress(KeyChain.KeyPurpose purpose) {
<span class="fc" id="L244">        DeterministicKeyChain chain = getActiveKeyChain();</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">        if (chain.isMarried()) {</span>
<span class="fc" id="L246">            Script outputScript = chain.freshOutputScript(purpose);</span>
<span class="fc" id="L247">            checkState(outputScript.isPayToScriptHash()); // Only handle P2SH for now</span>
<span class="fc" id="L248">            Address freshAddress = Address.fromP2SHScript(params, outputScript);</span>
<span class="fc" id="L249">            maybeLookaheadScripts();</span>
<span class="fc" id="L250">            currentAddresses.put(purpose, freshAddress);</span>
<span class="fc" id="L251">            return freshAddress;</span>
        } else {
<span class="fc" id="L253">            return freshKey(purpose).toAddress(params);</span>
        }
    }

    /** Returns the key chain that's used for generation of fresh/current keys. This is always the newest HD chain. */
    public final DeterministicKeyChain getActiveKeyChain() {
<span class="fc bfc" id="L259" title="All 2 branches covered.">        if (chains.isEmpty()) {</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">            if (basic.numKeys() &gt; 0) {</span>
<span class="fc" id="L261">                log.warn(&quot;No HD chain present but random keys are: you probably deserialized an old wallet.&quot;);</span>
                // If called from the wallet (most likely) it'll try to upgrade us, as it knows the rotation time
                // but not the password.
<span class="fc" id="L264">                throw new DeterministicUpgradeRequiredException();</span>
            }
            // Otherwise we have no HD chains and no random keys: we are a new born! So a random seed is fine.
<span class="fc" id="L267">            createAndActivateNewHDChain();</span>
        }
<span class="fc" id="L269">        return chains.get(chains.size() - 1);</span>
    }

    /**
     * Sets the lookahead buffer size for ALL deterministic key chains as well as for following key chains if any exist,
     * see {@link DeterministicKeyChain#setLookaheadSize(int)}
     * for more information.
     */
    public void setLookaheadSize(int lookaheadSize) {
<span class="fc" id="L278">        this.lookaheadSize = lookaheadSize;</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains) {</span>
<span class="fc" id="L280">            chain.setLookaheadSize(lookaheadSize);</span>
<span class="fc" id="L281">        }</span>
<span class="fc" id="L282">    }</span>

    /**
     * Gets the current lookahead size being used for ALL deterministic key chains. See
     * {@link DeterministicKeyChain#setLookaheadSize(int)}
     * for more information.
     */
    public int getLookaheadSize() {
<span class="fc bfc" id="L290" title="All 2 branches covered.">        if (lookaheadSize == -1)</span>
<span class="fc" id="L291">            return getActiveKeyChain().getLookaheadSize();</span>
        else
<span class="fc" id="L293">            return lookaheadSize;</span>
    }

    /**
     * Sets the lookahead buffer threshold for ALL deterministic key chains, see
     * {@link DeterministicKeyChain#setLookaheadThreshold(int)}
     * for more information.
     */
    public void setLookaheadThreshold(int num) {
<span class="fc bfc" id="L302" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains) {</span>
<span class="fc" id="L303">            chain.setLookaheadThreshold(num);</span>
<span class="fc" id="L304">        }</span>
<span class="fc" id="L305">    }</span>

    /**
     * Gets the current lookahead threshold being used for ALL deterministic key chains. See
     * {@link DeterministicKeyChain#setLookaheadThreshold(int)}
     * for more information.
     */
    public int getLookaheadThreshold() {
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        if (lookaheadThreshold == -1)</span>
<span class="fc" id="L314">            return getActiveKeyChain().getLookaheadThreshold();</span>
        else
<span class="nc" id="L316">            return lookaheadThreshold;</span>
    }

    /** Imports the given keys into the basic chain, creating it if necessary. */
    public int importKeys(List&lt;ECKey&gt; keys) {
<span class="fc" id="L321">        return basic.importKeys(keys);</span>
    }

    /** Imports the given keys into the basic chain, creating it if necessary. */
    public int importKeys(ECKey... keys) {
<span class="fc" id="L326">        return importKeys(ImmutableList.copyOf(keys));</span>
    }

    public boolean checkPassword(CharSequence password) {
<span class="fc bfc" id="L330" title="All 2 branches covered.">        checkState(keyCrypter != null, &quot;Not encrypted&quot;);</span>
<span class="fc" id="L331">        return checkAESKey(keyCrypter.deriveKey(password));</span>
    }

    public boolean checkAESKey(KeyParameter aesKey) {
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">        checkState(keyCrypter != null, &quot;Not encrypted&quot;);</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">        if (basic.numKeys() &gt; 0)</span>
<span class="fc" id="L337">            return basic.checkAESKey(aesKey);</span>
<span class="fc" id="L338">        return getActiveKeyChain().checkAESKey(aesKey);</span>
    }

    /** Imports the given unencrypted keys into the basic chain, encrypting them along the way with the given key. */
    public int importKeysAndEncrypt(final List&lt;ECKey&gt; keys, KeyParameter aesKey) {
        // TODO: Firstly check if the aes key can decrypt any of the existing keys successfully.
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">        checkState(keyCrypter != null, &quot;Not encrypted&quot;);</span>
<span class="fc" id="L345">        LinkedList&lt;ECKey&gt; encryptedKeys = Lists.newLinkedList();</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">        for (ECKey key : keys) {</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">            if (key.isEncrypted())</span>
<span class="fc" id="L348">                throw new IllegalArgumentException(&quot;Cannot provide already encrypted keys&quot;);</span>
<span class="fc" id="L349">            encryptedKeys.add(key.encrypt(keyCrypter, aesKey));</span>
<span class="fc" id="L350">        }</span>
<span class="fc" id="L351">        return importKeys(encryptedKeys);</span>
    }

    @Override
    @Nullable
    public RedeemData findRedeemDataFromScriptHash(byte[] scriptHash) {
        // Iterate in reverse order, since the active keychain is the one most likely to have the hit
<span class="fc bfc" id="L358" title="All 2 branches covered.">        for (Iterator&lt;DeterministicKeyChain&gt; iter = chains.descendingIterator() ; iter.hasNext() ; ) {</span>
<span class="fc" id="L359">            DeterministicKeyChain chain = iter.next();</span>
<span class="fc" id="L360">            RedeemData redeemData = chain.findRedeemDataByScriptHash(ByteString.copyFrom(scriptHash));</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">            if (redeemData != null)</span>
<span class="fc" id="L362">                return redeemData;</span>
<span class="fc" id="L363">        }</span>
<span class="fc" id="L364">        return null;</span>
    }

    public void markP2SHAddressAsUsed(Address address) {
<span class="fc" id="L368">        checkArgument(address.isP2SHAddress());</span>
<span class="fc" id="L369">        RedeemData data = findRedeemDataFromScriptHash(address.getHash160());</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">        if (data == null)</span>
<span class="fc" id="L371">            return;   // Not our P2SH address.</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">        for (ECKey key : data.keys) {</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">            for (DeterministicKeyChain chain : chains) {</span>
<span class="fc" id="L374">                DeterministicKey k = chain.findKeyFromPubKey(key.getPubKey());</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">                if (k == null) continue;</span>
<span class="fc" id="L376">                chain.markKeyAsUsed(k);</span>
<span class="fc" id="L377">                maybeMarkCurrentAddressAsUsed(address);</span>
<span class="fc" id="L378">            }</span>
<span class="fc" id="L379">        }</span>
<span class="fc" id="L380">    }</span>

    @Nullable
    @Override
    public ECKey findKeyFromPubHash(byte[] pubkeyHash) {
        ECKey result;
<span class="fc bfc" id="L386" title="All 2 branches covered.">        if ((result = basic.findKeyFromPubHash(pubkeyHash)) != null)</span>
<span class="fc" id="L387">            return result;</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains) {</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">            if ((result = chain.findKeyFromPubHash(pubkeyHash)) != null)</span>
<span class="fc" id="L390">                return result;</span>
<span class="fc" id="L391">        }</span>
<span class="fc" id="L392">        return null;</span>
    }

    /**
     * Mark the DeterministicKeys as used, if they match the pubkeyHash
     * See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     */
    public void markPubKeyHashAsUsed(byte[] pubkeyHash) {
<span class="fc bfc" id="L400" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains) {</span>
            DeterministicKey key;
<span class="fc bfc" id="L402" title="All 2 branches covered.">            if ((key = chain.markPubHashAsUsed(pubkeyHash)) != null) {</span>
<span class="fc" id="L403">                maybeMarkCurrentKeyAsUsed(key);</span>
<span class="fc" id="L404">                return;</span>
            }
<span class="fc" id="L406">        }</span>
<span class="fc" id="L407">    }</span>

    /** If the given P2SH address is &quot;current&quot;, advance it to a new one. */
    private void maybeMarkCurrentAddressAsUsed(Address address) {
<span class="fc" id="L411">        checkArgument(address.isP2SHAddress());</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">        for (Map.Entry&lt;KeyChain.KeyPurpose, Address&gt; entry : currentAddresses.entrySet()) {</span>
<span class="pc bpc" id="L413" title="1 of 4 branches missed.">            if (entry.getValue() != null &amp;&amp; entry.getValue().equals(address)) {</span>
<span class="fc" id="L414">                log.info(&quot;Marking P2SH address as used: {}&quot;, address);</span>
<span class="fc" id="L415">                currentAddresses.put(entry.getKey(), freshAddress(entry.getKey()));</span>
<span class="fc" id="L416">                return;</span>
            }
<span class="fc" id="L418">        }</span>
<span class="fc" id="L419">    }</span>

    /** If the given key is &quot;current&quot;, advance the current key to a new one. */
    private void maybeMarkCurrentKeyAsUsed(DeterministicKey key) {
        // It's OK for currentKeys to be empty here: it means we're a married wallet and the key may be a part of a
        // rotating chain.
<span class="fc bfc" id="L425" title="All 2 branches covered.">        for (Map.Entry&lt;KeyChain.KeyPurpose, DeterministicKey&gt; entry : currentKeys.entrySet()) {</span>
<span class="pc bpc" id="L426" title="1 of 4 branches missed.">            if (entry.getValue() != null &amp;&amp; entry.getValue().equals(key)) {</span>
<span class="fc" id="L427">                log.info(&quot;Marking key as used: {}&quot;, key);</span>
<span class="fc" id="L428">                currentKeys.put(entry.getKey(), freshKey(entry.getKey()));</span>
<span class="fc" id="L429">                return;</span>
            }
<span class="fc" id="L431">        }</span>
<span class="fc" id="L432">    }</span>

    public boolean hasKey(ECKey key) {
<span class="fc bfc" id="L435" title="All 2 branches covered.">        if (basic.hasKey(key))</span>
<span class="fc" id="L436">            return true;</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains)</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">            if (chain.hasKey(key))</span>
<span class="fc" id="L439">                return true;</span>
<span class="fc" id="L440">        return false;</span>
    }

    @Nullable
    @Override
    public ECKey findKeyFromPubKey(byte[] pubkey) {
        ECKey result;
<span class="fc bfc" id="L447" title="All 2 branches covered.">        if ((result = basic.findKeyFromPubKey(pubkey)) != null)</span>
<span class="fc" id="L448">            return result;</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains) {</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">            if ((result = chain.findKeyFromPubKey(pubkey)) != null)</span>
<span class="fc" id="L451">                return result;</span>
<span class="fc" id="L452">        }</span>
<span class="fc" id="L453">        return null;</span>
    }

    /**
     * Mark the DeterministicKeys as used, if they match the pubkey
     * See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     */
    public void markPubKeyAsUsed(byte[] pubkey) {
<span class="fc bfc" id="L461" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains) {</span>
            DeterministicKey key;
<span class="fc bfc" id="L463" title="All 2 branches covered.">            if ((key = chain.markPubKeyAsUsed(pubkey)) != null) {</span>
<span class="fc" id="L464">                maybeMarkCurrentKeyAsUsed(key);</span>
<span class="fc" id="L465">                return;</span>
            }
<span class="fc" id="L467">        }</span>
<span class="fc" id="L468">    }</span>

    /** Returns the number of keys managed by this group, including the lookahead buffers. */
    public int numKeys() {
<span class="fc" id="L472">        int result = basic.numKeys();</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains)</span>
<span class="fc" id="L474">            result += chain.numKeys();</span>
<span class="fc" id="L475">        return result;</span>
    }

    /**
     * Removes a key that was imported into the basic key chain. You cannot remove deterministic keys.
     * @throws java.lang.IllegalArgumentException if the key is deterministic.
     */
    public boolean removeImportedKey(ECKey key) {
<span class="fc" id="L483">        checkNotNull(key);</span>
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">        checkArgument(!(key instanceof DeterministicKey));</span>
<span class="fc" id="L485">        return basic.removeKey(key);</span>
    }

    /**
     * Whether the active keychain is married.  A keychain is married when it vends P2SH addresses
     * from multiple keychains in a multisig relationship.
     * @see org.bitcoinj.wallet.MarriedKeyChain
     */
    public final boolean isMarried() {
<span class="fc bfc" id="L494" title="All 4 branches covered.">        return !chains.isEmpty() &amp;&amp; getActiveKeyChain().isMarried();</span>
    }

    /**
     * Encrypt the keys in the group using the KeyCrypter and the AES key. A good default KeyCrypter to use is
     * {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     *
     * @throws org.bitcoinj.crypto.KeyCrypterException Thrown if the wallet encryption fails for some reason,
     *         leaving the group unchanged.
     * @throws DeterministicUpgradeRequiredException Thrown if there are random keys but no HD chain.
     */
    public void encrypt(KeyCrypter keyCrypter, KeyParameter aesKey) {
<span class="fc" id="L506">        checkNotNull(keyCrypter);</span>
<span class="fc" id="L507">        checkNotNull(aesKey);</span>
        // This code must be exception safe.
<span class="fc" id="L509">        BasicKeyChain newBasic = basic.toEncrypted(keyCrypter, aesKey);</span>
<span class="fc" id="L510">        List&lt;DeterministicKeyChain&gt; newChains = new ArrayList&lt;&gt;(chains.size());</span>
<span class="fc bfc" id="L511" title="All 4 branches covered.">        if (chains.isEmpty() &amp;&amp; basic.numKeys() == 0) {</span>
            // No HD chains and no random keys: encrypting an entirely empty keychain group. But we can't do that, we
            // must have something to encrypt: so instantiate a new HD chain here.
<span class="fc" id="L514">            createAndActivateNewHDChain();</span>
        }
<span class="fc bfc" id="L516" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains)</span>
<span class="fc" id="L517">            newChains.add(chain.toEncrypted(keyCrypter, aesKey));</span>
<span class="fc" id="L518">        this.keyCrypter = keyCrypter;</span>
<span class="fc" id="L519">        basic = newBasic;</span>
<span class="fc" id="L520">        chains.clear();</span>
<span class="fc" id="L521">        chains.addAll(newChains);</span>
<span class="fc" id="L522">    }</span>

    /**
     * Decrypt the keys in the group using the previously given key crypter and the AES key. A good default
     * KeyCrypter to use is {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     *
     * @throws org.bitcoinj.crypto.KeyCrypterException Thrown if the wallet decryption fails for some reason, leaving the group unchanged.
     */
    public void decrypt(KeyParameter aesKey) {
        // This code must be exception safe.
<span class="fc" id="L532">        checkNotNull(aesKey);</span>
<span class="fc" id="L533">        BasicKeyChain newBasic = basic.toDecrypted(aesKey);</span>
<span class="fc" id="L534">        List&lt;DeterministicKeyChain&gt; newChains = new ArrayList&lt;&gt;(chains.size());</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains)</span>
<span class="fc" id="L536">            newChains.add(chain.toDecrypted(aesKey));</span>

<span class="fc" id="L538">        this.keyCrypter = null;</span>
<span class="fc" id="L539">        basic = newBasic;</span>
<span class="fc" id="L540">        chains.clear();</span>
<span class="fc" id="L541">        chains.addAll(newChains);</span>
<span class="fc" id="L542">    }</span>

    /** Returns true if the group is encrypted. */
    public boolean isEncrypted() {
<span class="fc bfc" id="L546" title="All 2 branches covered.">        return keyCrypter != null;</span>
    }

    /**
     * Returns whether this chain has only watching keys (unencrypted keys with no private part). Mixed chains are
     * forbidden.
     * 
     * @throws IllegalStateException if there are no keys, or if there is a mix between watching and non-watching keys.
     */
    public boolean isWatching() {
<span class="fc" id="L556">        BasicKeyChain.State basicState = basic.isWatching();</span>
<span class="fc" id="L557">        BasicKeyChain.State activeState = BasicKeyChain.State.EMPTY;</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">        if (!chains.isEmpty()) {</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">            if (getActiveKeyChain().isWatching())</span>
<span class="fc" id="L560">                activeState = BasicKeyChain.State.WATCHING;</span>
            else
<span class="fc" id="L562">                activeState = BasicKeyChain.State.REGULAR;</span>
        }
<span class="fc bfc" id="L564" title="All 2 branches covered.">        if (basicState == BasicKeyChain.State.EMPTY) {</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">            if (activeState == BasicKeyChain.State.EMPTY)</span>
<span class="fc" id="L566">                throw new IllegalStateException(&quot;Empty key chain group: cannot answer isWatching() query&quot;);</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">            return activeState == BasicKeyChain.State.WATCHING;</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">        } else if (activeState == BasicKeyChain.State.EMPTY)</span>
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">            return basicState == BasicKeyChain.State.WATCHING;</span>
        else {
<span class="fc bfc" id="L571" title="All 2 branches covered.">            if (activeState != basicState)</span>
<span class="fc" id="L572">                throw new IllegalStateException(&quot;Mix of watching and non-watching keys in wallet&quot;);</span>
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">            return activeState == BasicKeyChain.State.WATCHING;</span>
        }
    }

    /** Returns the key crypter or null if the group is not encrypted. */
<span class="fc" id="L578">    @Nullable public KeyCrypter getKeyCrypter() { return keyCrypter; }</span>

    /**
     * Returns a list of the non-deterministic keys that have been imported into the wallet, or the empty list if none.
     */
    public List&lt;ECKey&gt; getImportedKeys() {
<span class="fc" id="L584">        return basic.getKeys();</span>
    }

    public long getEarliestKeyCreationTime() {
<span class="fc" id="L588">        long time = basic.getEarliestKeyCreationTime();   // Long.MAX_VALUE if empty.</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains)</span>
<span class="fc" id="L590">            time = Math.min(time, chain.getEarliestKeyCreationTime());</span>
<span class="fc" id="L591">        return time;</span>
    }

    public int getBloomFilterElementCount() {
<span class="fc" id="L595">        int result = basic.numBloomFilterEntries();</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains) {</span>
<span class="fc" id="L597">            result += chain.numBloomFilterEntries();</span>
<span class="fc" id="L598">        }</span>
<span class="fc" id="L599">        return result;</span>
    }

    public BloomFilter getBloomFilter(int size, double falsePositiveRate, long nTweak) {
<span class="fc" id="L603">        BloomFilter filter = new BloomFilter(size, falsePositiveRate, nTweak);</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">        if (basic.numKeys() &gt; 0)</span>
<span class="fc" id="L605">            filter.merge(basic.getFilter(size, falsePositiveRate, nTweak));</span>

<span class="fc bfc" id="L607" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains) {</span>
<span class="fc" id="L608">            filter.merge(chain.getFilter(size, falsePositiveRate, nTweak));</span>
<span class="fc" id="L609">        }</span>
<span class="fc" id="L610">        return filter;</span>
    }

    public boolean isRequiringUpdateAllBloomFilter() {
<span class="nc" id="L614">        throw new UnsupportedOperationException();   // Unused.</span>
    }

    private Script makeP2SHOutputScript(DeterministicKey followedKey, DeterministicKeyChain chain) {
<span class="fc" id="L618">        return ScriptBuilder.createP2SHOutputScript(chain.getRedeemData(followedKey).redeemScript);</span>
    }

    /** Adds a listener for events that are run when keys are added, on the user thread. */
    public void addEventListener(KeyChainEventListener listener) {
<span class="nc" id="L623">        addEventListener(listener, Threading.USER_THREAD);</span>
<span class="nc" id="L624">    }</span>

    /** Adds a listener for events that are run when keys are added, on the given executor. */
    public void addEventListener(KeyChainEventListener listener, Executor executor) {
<span class="fc" id="L628">        checkNotNull(listener);</span>
<span class="fc" id="L629">        checkNotNull(executor);</span>
<span class="fc" id="L630">        basic.addEventListener(listener, executor);</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains)</span>
<span class="fc" id="L632">            chain.addEventListener(listener, executor);</span>
<span class="fc" id="L633">    }</span>

    /** Removes a listener for events that are run when keys are added. */
    public boolean removeEventListener(KeyChainEventListener listener) {
<span class="fc" id="L637">        checkNotNull(listener);</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains)</span>
<span class="fc" id="L639">            chain.removeEventListener(listener);</span>
<span class="fc" id="L640">        return basic.removeEventListener(listener);</span>
    }

    /** Returns a list of key protobufs obtained by merging the chains. */
    public List&lt;Protos.Key&gt; serializeToProtobuf() {
        List&lt;Protos.Key&gt; result;
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">        if (basic != null)</span>
<span class="fc" id="L647">            result = basic.serializeToProtobuf();</span>
        else
<span class="nc" id="L649">            result = Lists.newArrayList();</span>
<span class="fc bfc" id="L650" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains) {</span>
<span class="fc" id="L651">            List&lt;Protos.Key&gt; protos = chain.serializeToProtobuf();</span>
<span class="fc" id="L652">            result.addAll(protos);</span>
<span class="fc" id="L653">        }</span>
<span class="fc" id="L654">        return result;</span>
    }

    static KeyChainGroup fromProtobufUnencrypted(NetworkParameters params, List&lt;Protos.Key&gt; keys) throws UnreadableWalletException {
<span class="fc" id="L658">        return fromProtobufUnencrypted(params, keys, new DefaultKeyChainFactory());</span>
    }

    public static KeyChainGroup fromProtobufUnencrypted(NetworkParameters params, List&lt;Protos.Key&gt; keys, KeyChainFactory factory) throws UnreadableWalletException {
<span class="fc" id="L662">        BasicKeyChain basicKeyChain = BasicKeyChain.fromProtobufUnencrypted(keys);</span>
<span class="fc" id="L663">        List&lt;DeterministicKeyChain&gt; chains = DeterministicKeyChain.fromProtobuf(keys, null, factory);</span>
<span class="fc" id="L664">        EnumMap&lt;KeyChain.KeyPurpose, DeterministicKey&gt; currentKeys = null;</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">        if (!chains.isEmpty())</span>
<span class="fc" id="L666">            currentKeys = createCurrentKeysMap(chains);</span>
<span class="fc" id="L667">        extractFollowingKeychains(chains);</span>
<span class="fc" id="L668">        return new KeyChainGroup(params, basicKeyChain, chains, currentKeys, null);</span>
    }

    static KeyChainGroup fromProtobufEncrypted(NetworkParameters params, List&lt;Protos.Key&gt; keys, KeyCrypter crypter) throws UnreadableWalletException {
<span class="fc" id="L672">        return fromProtobufEncrypted(params, keys, crypter, new DefaultKeyChainFactory());</span>
    }

    public static KeyChainGroup fromProtobufEncrypted(NetworkParameters params, List&lt;Protos.Key&gt; keys, KeyCrypter crypter, KeyChainFactory factory) throws UnreadableWalletException {
<span class="fc" id="L676">        checkNotNull(crypter);</span>
<span class="fc" id="L677">        BasicKeyChain basicKeyChain = BasicKeyChain.fromProtobufEncrypted(keys, crypter);</span>
<span class="fc" id="L678">        List&lt;DeterministicKeyChain&gt; chains = DeterministicKeyChain.fromProtobuf(keys, crypter, factory);</span>
<span class="fc" id="L679">        EnumMap&lt;KeyChain.KeyPurpose, DeterministicKey&gt; currentKeys = null;</span>
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">        if (!chains.isEmpty())</span>
<span class="fc" id="L681">            currentKeys = createCurrentKeysMap(chains);</span>
<span class="fc" id="L682">        extractFollowingKeychains(chains);</span>
<span class="fc" id="L683">        return new KeyChainGroup(params, basicKeyChain, chains, currentKeys, crypter);</span>
    }

    /**
     * If the key chain contains only random keys and no deterministic key chains, this method will create a chain
     * based on the oldest non-rotating private key (i.e. the seed is derived from the old wallet).
     *
     * @param keyRotationTimeSecs If non-zero, UNIX time for which keys created before this are assumed to be
     *                            compromised or weak, those keys will not be used for deterministic upgrade.
     * @param aesKey If non-null, the encryption key the keychain is encrypted under. If the keychain is encrypted
     *               and this is not supplied, an exception is thrown letting you know you should ask the user for
     *               their password, turn it into a key, and then try again.
     * @throws java.lang.IllegalStateException if there is already a deterministic key chain present or if there are
     *                                         no random keys (i.e. this is not an upgrade scenario), or if aesKey is
     *                                         provided but the wallet is not encrypted.
     * @throws java.lang.IllegalArgumentException if the rotation time specified excludes all keys.
     * @throws DeterministicUpgradeRequiresPassword if the key chain group is encrypted
     *         and you should provide the users encryption key.
     * @return the DeterministicKeyChain that was created by the upgrade.
     */
    public DeterministicKeyChain upgradeToDeterministic(long keyRotationTimeSecs, @Nullable KeyParameter aesKey) throws DeterministicUpgradeRequiresPassword, AllRandomKeysRotating {
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">        checkState(basic.numKeys() &gt; 0);</span>
<span class="pc bpc" id="L705" title="1 of 2 branches missed.">        checkArgument(keyRotationTimeSecs &gt;= 0);</span>
        // Subtract one because the key rotation time might have been set to the creation time of the first known good
        // key, in which case, that's the one we want to find.
<span class="fc" id="L708">        ECKey keyToUse = basic.findOldestKeyAfter(keyRotationTimeSecs - 1);</span>
<span class="pc bpc" id="L709" title="1 of 2 branches missed.">        if (keyToUse == null)</span>
<span class="nc" id="L710">            throw new AllRandomKeysRotating();</span>

<span class="fc bfc" id="L712" title="All 2 branches covered.">        if (keyToUse.isEncrypted()) {</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">            if (aesKey == null) {</span>
                // We can't auto upgrade because we don't know the users password at this point. We throw an
                // exception so the calling code knows to abort the load and ask the user for their password, they can
                // then try loading the wallet again passing in the AES key.
                //
                // There are a few different approaches we could have used here, but they all suck. The most obvious
                // is to try and be as lazy as possible, running in the old random-wallet mode until the user enters
                // their password for some other reason and doing the upgrade then. But this could result in strange
                // and unexpected UI flows for the user, as well as complicating the job of wallet developers who then
                // have to support both &quot;old&quot; and &quot;new&quot; UI modes simultaneously, switching them on the fly. Given that
                // this is a one-off transition, it seems more reasonable to just ask the user for their password
                // on startup, and then the wallet app can have all the widgets for accessing seed words etc active
                // all the time.
<span class="fc" id="L726">                throw new DeterministicUpgradeRequiresPassword();</span>
            }
<span class="fc" id="L728">            keyToUse = keyToUse.decrypt(aesKey);</span>
<span class="pc bpc" id="L729" title="1 of 2 branches missed.">        } else if (aesKey != null) {</span>
<span class="nc" id="L730">            throw new IllegalStateException(&quot;AES Key was provided but wallet is not encrypted.&quot;);</span>
        }

<span class="fc bfc" id="L733" title="All 2 branches covered.">        if (chains.isEmpty()) {</span>
<span class="fc" id="L734">            log.info(&quot;Auto-upgrading pre-HD wallet to HD!&quot;);</span>
        } else {
<span class="fc" id="L736">            log.info(&quot;Wallet with existing HD chain is being re-upgraded due to change in key rotation time.&quot;);</span>
        }
<span class="fc" id="L738">        log.info(&quot;Instantiating new HD chain using oldest non-rotating private key (address: {})&quot;, keyToUse.toAddress(params));</span>
<span class="fc" id="L739">        byte[] entropy = checkNotNull(keyToUse.getSecretBytes());</span>
        // Private keys should be at least 128 bits long.
<span class="pc bpc" id="L741" title="1 of 2 branches missed.">        checkState(entropy.length &gt;= DeterministicSeed.DEFAULT_SEED_ENTROPY_BITS / 8);</span>
        // We reduce the entropy here to 128 bits because people like to write their seeds down on paper, and 128
        // bits should be sufficient forever unless the laws of the universe change or ECC is broken; in either case
        // we all have bigger problems.
<span class="fc" id="L745">        entropy = Arrays.copyOfRange(entropy, 0, DeterministicSeed.DEFAULT_SEED_ENTROPY_BITS / 8);    // final argument is exclusive range.</span>
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">        checkState(entropy.length == DeterministicSeed.DEFAULT_SEED_ENTROPY_BITS / 8);</span>
<span class="fc" id="L747">        String passphrase = &quot;&quot;; // FIXME allow non-empty passphrase</span>
<span class="fc" id="L748">        DeterministicKeyChain chain = new DeterministicKeyChain(entropy, passphrase, keyToUse.getCreationTimeSeconds());</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">        if (aesKey != null) {</span>
<span class="fc" id="L750">            chain = chain.toEncrypted(checkNotNull(basic.getKeyCrypter()), aesKey);</span>
        }
<span class="fc" id="L752">        chains.add(chain);</span>
<span class="fc" id="L753">        return chain;</span>
    }

    /** Returns true if the group contains random keys but no HD chains. */
    public boolean isDeterministicUpgradeRequired() {
<span class="fc bfc" id="L758" title="All 4 branches covered.">        return basic.numKeys() &gt; 0 &amp;&amp; chains.isEmpty();</span>
    }

    private static EnumMap&lt;KeyChain.KeyPurpose, DeterministicKey&gt; createCurrentKeysMap(List&lt;DeterministicKeyChain&gt; chains) {
<span class="fc" id="L762">        DeterministicKeyChain activeChain = chains.get(chains.size() - 1);</span>

<span class="fc" id="L764">        EnumMap&lt;KeyChain.KeyPurpose, DeterministicKey&gt; currentKeys = new EnumMap&lt;&gt;(KeyChain.KeyPurpose.class);</span>

        // assuming that only RECEIVE and CHANGE keys are being used at the moment, we will treat latest issued external key
        // as current RECEIVE key and latest issued internal key as CHANGE key. This should be changed as soon as other
        // kinds of KeyPurpose are introduced.
<span class="fc bfc" id="L769" title="All 2 branches covered.">        if (activeChain.getIssuedExternalKeys() &gt; 0) {</span>
<span class="fc" id="L770">            DeterministicKey currentExternalKey = activeChain.getKeyByPath(</span>
<span class="fc" id="L771">                    HDUtils.append(</span>
<span class="fc" id="L772">                            HDUtils.concat(activeChain.getAccountPath(), DeterministicKeyChain.EXTERNAL_SUBPATH),</span>
<span class="fc" id="L773">                            new ChildNumber(activeChain.getIssuedExternalKeys() - 1)));</span>
<span class="fc" id="L774">            currentKeys.put(KeyChain.KeyPurpose.RECEIVE_FUNDS, currentExternalKey);</span>
        }

<span class="fc bfc" id="L777" title="All 2 branches covered.">        if (activeChain.getIssuedInternalKeys() &gt; 0) {</span>
<span class="fc" id="L778">            DeterministicKey currentInternalKey = activeChain.getKeyByPath(</span>
<span class="fc" id="L779">                    HDUtils.append(</span>
<span class="fc" id="L780">                            HDUtils.concat(activeChain.getAccountPath(), DeterministicKeyChain.INTERNAL_SUBPATH),</span>
<span class="fc" id="L781">                            new ChildNumber(activeChain.getIssuedInternalKeys() - 1)));</span>
<span class="fc" id="L782">            currentKeys.put(KeyChain.KeyPurpose.CHANGE, currentInternalKey);</span>
        }
<span class="fc" id="L784">        return currentKeys;</span>
    }

    private static void extractFollowingKeychains(List&lt;DeterministicKeyChain&gt; chains) {
        // look for following key chains and map them to the watch keys of followed keychains
<span class="fc" id="L789">        List&lt;DeterministicKeyChain&gt; followingChains = Lists.newArrayList();</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">        for (Iterator&lt;DeterministicKeyChain&gt; it = chains.iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L791">            DeterministicKeyChain chain = it.next();</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">            if (chain.isFollowing()) {</span>
<span class="fc" id="L793">                followingChains.add(chain);</span>
<span class="fc" id="L794">                it.remove();</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">            } else if (!followingChains.isEmpty()) {</span>
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">                if (!(chain instanceof MarriedKeyChain))</span>
<span class="nc" id="L797">                    throw new IllegalStateException();</span>
<span class="fc" id="L798">                ((MarriedKeyChain)chain).setFollowingKeyChains(followingChains);</span>
<span class="fc" id="L799">                followingChains = Lists.newArrayList();</span>
            }
<span class="fc" id="L801">        }</span>
<span class="fc" id="L802">    }</span>

    public String toString(boolean includePrivateKeys, @Nullable KeyParameter aesKey) {
<span class="fc" id="L805">        final StringBuilder builder = new StringBuilder();</span>
<span class="pc bpc" id="L806" title="1 of 2 branches missed.">        if (basic != null) {</span>
<span class="fc" id="L807">            List&lt;ECKey&gt; keys = basic.getKeys();</span>
<span class="fc" id="L808">            Collections.sort(keys, ECKey.AGE_COMPARATOR);</span>
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">            for (ECKey key : keys)</span>
<span class="nc" id="L810">                key.formatKeyWithAddress(includePrivateKeys, aesKey, builder, params);</span>
        }
<span class="fc bfc" id="L812" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains)</span>
<span class="fc" id="L813">            builder.append(chain.toString(includePrivateKeys, aesKey, params)).append('\n');</span>
<span class="fc" id="L814">        return builder.toString();</span>
    }

    /** Returns a copy of the current list of chains. */
    public List&lt;DeterministicKeyChain&gt; getDeterministicKeyChains() {
<span class="fc" id="L819">        return new ArrayList&lt;&gt;(chains);</span>
    }
    /**
     * Returns a counter that increases (by an arbitrary amount) each time new keys have been calculated due to
     * lookahead and thus the Bloom filter that was previously calculated has become stale.
     */
    public int getCombinedKeyLookaheadEpochs() {
<span class="fc" id="L826">        int epoch = 0;</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">        for (DeterministicKeyChain chain : chains)</span>
<span class="fc" id="L828">            epoch += chain.getKeyLookaheadEpoch();</span>
<span class="fc" id="L829">        return epoch;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>